package routers

import (
	"context"
	openapiChat "mwchat/apiAutogenerated/chat"
	"mwchat/internal/auth"
	"mwchat/internal/config"
	db "mwchat/internal/db/sqlc"
	"mwchat/internal/openapi"
	"mwchat/pkg/utils"
	"net/http"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestGetRoomById(t *testing.T) {
	newConfig, err := config.LoadConfig("../../")
	if err != nil {
		t.Fatalf("Failed to load config: %v", err)
	}

	chatApi := openapi.MakeChatAPIClient(&newConfig)
	_, err = chatApi.DevAPI.DevResetDbGet(context.Background()).Execute()
	if err != nil {
		t.Fatalf("Failed to reset db: %v", err)
	}

	currentUserID := "d2cb5e1b-44df-48d3-b7a1-34f3d7a5b7e2"
	userID := "3d922e8a-5d58-4b82-9a3d-83e2e73b3f91"
	roomID := "78bdf878-3b83-4f97-8d2e-928c132a10cd"

	t.Run("should return private room by room id with messages and users", func(t *testing.T) {
		token, err := auth.GenerateTestJWT(newConfig.SecretSessionKey, currentUserID)
		if err != nil {
			t.Fatalf("Failed to generate JWT: %v", err)
		}

		ctx := context.WithValue(context.Background(), auth.ContextKeyAuthorization, "Bearer "+token)
		getRoomByIdResponse, response, err := chatApi.RoomAPI.GetRoomById(ctx, roomID).Execute()

		nullableName := openapiChat.NullableString{}
		nullableName.Set(nil)
		expectedData := &openapiChat.SchemasRoomPopulatedResponse{
			RoomId:    roomID,
			Name:      nullableName,
			RoomType:  "private",
			IsBlocked: false,
			Users: []openapiChat.SchemasUserResponse{
				{
					UserId: currentUserID,
					Role:   "regular",
				},
				{
					UserId: userID,
					Role:   "regular",
				},
			},
			Messages: []openapiChat.SchemasMessageResponse{
				{
					MessageId:      "7939af01-e785-445d-b79d-70a433979c7b",
					OwnerId:        currentUserID,
					Message:        "Test message 1",
					MessageReaders: []openapiChat.SchemasMessageReader{},
				},
				{
					MessageId: "91be5d99-eddf-4949-bf15-b4cee3989fa6",
					OwnerId:   userID,
					Message:   "Test message 2",
					MessageReaders: []openapiChat.SchemasMessageReader{
						{
							UserId:   currentUserID,
							ReadDate: "2024-08-09T02:00:00.000Z",
						},
					},
				},
				{
					MessageId:      "88a6d503-a03b-412c-bfab-06649e49d62d",
					OwnerId:        currentUserID,
					Message:        "Test message 3",
					MessageReaders: []openapiChat.SchemasMessageReader{},
				},
				{
					MessageId: "6cea59ef-f0d4-4d8c-aa12-e48a746c93d0",
					OwnerId:   userID,
					Message:   "Test message 4",
					MessageReaders: []openapiChat.SchemasMessageReader{
						{
							UserId:   currentUserID,
							ReadDate: "2024-08-10T13:30:00.000Z",
						},
					},
				},
			},
		}

		assert.Equal(t, http.StatusOK, response.StatusCode)
		assert.Equal(t, expectedData, getRoomByIdResponse)
	})
}

func TestGetChatPreview(t *testing.T) {
	newConfig, err := config.LoadConfig("../../")
	if err != nil {
		t.Fatalf("Failed to load config: %v", err)
	}

	chatApi := openapi.MakeChatAPIClient(&newConfig)
	_, err = chatApi.DevAPI.DevResetDbGet(context.Background()).Execute()
	if err != nil {
		t.Fatalf("Failed to reset db: %v", err)
	}

	currentUserID := "d2cb5e1b-44df-48d3-b7a1-34f3d7a5b7e2"

	t.Run("should return chat preview with correct unread messages amount", func(t *testing.T) {
		token, err := auth.GenerateTestJWT(newConfig.SecretSessionKey, currentUserID)
		if err != nil {
			t.Fatalf("Failed to generate JWT: %v", err)
		}

		ctx := context.WithValue(context.Background(), auth.ContextKeyAuthorization, "Bearer "+token)
		getChatPreviewResponse, response, err := chatApi.RoomAPI.GetChatPreview(ctx).Execute()
		if err != nil {
			t.Fatalf("Failed to get chat preview: %v", err)
		}

		expectedData := openapiChat.SchemasGetChatPreviewResponse{
			UnreadMessagesAmount: 3,
		}

		assert.Equal(t, http.StatusOK, response.StatusCode)
		assert.Equal(t, expectedData.UnreadMessagesAmount, getChatPreviewResponse.UnreadMessagesAmount)
	})
}

func TestGetRooms(t *testing.T) {
	newConfig, err := config.LoadConfig("../../")
	if err != nil {
		t.Fatalf("Failed to load config: %v", err)
	}

	chatApi := openapi.MakeChatAPIClient(&newConfig)
	_, err = chatApi.DevAPI.DevResetDbGet(context.Background()).Execute()
	if err != nil {
		t.Fatalf("Failed to reset db: %v", err)
	}

	roomCreatorID := "d63d2f89-6412-4324-8587-7061bf02dca4"

	t.Run("should return list of private rooms successfully", func(t *testing.T) {
		token, err := auth.GenerateTestJWT(newConfig.SecretSessionKey, roomCreatorID)
		if err != nil {
			t.Fatalf("Failed to generate JWT: %v", err)
		}

		ctx := context.WithValue(context.Background(), auth.ContextKeyAuthorization, "Bearer "+token)
		getRoomsResponse, response, err := chatApi.RoomAPI.GetRooms(ctx, "private").Execute()
		if err != nil {
			t.Fatalf("Failed to get chat preview: %v", err)
		}

		nullableName := openapiChat.NullableString{}
		nullableName.Set(nil)
		expectedData := &openapiChat.SchemasGetRoomsResponse{
			Size: 3,
			Rooms: []openapiChat.SchemasRoomPreviewResponse{
				{
					RoomId:    "85f610df-9f86-4c55-8ee1-02485d42defb",
					Name:      nullableName,
					RoomType:  string(db.RoomTypePrivate),
					IsBlocked: false,
					Users: []openapiChat.SchemasUserResponse{
						{
							UserId: roomCreatorID,
							Role:   "regular",
						},
						{
							UserId: "8a3d1fe1-42da-499a-bf64-248297fd670a",
							Role:   "regular",
						},
					},
				},
				{
					RoomId:    "897f4a0f-fe31-4036-8358-f89a19c9bda6",
					Name:      nullableName,
					RoomType:  string(db.RoomTypePrivate),
					IsBlocked: false,
					Users: []openapiChat.SchemasUserResponse{
						{
							UserId: roomCreatorID,
							Role:   "regular",
						},
						{
							UserId: "5a31e3cb-7e9a-41e5-9a3b-1f1e5d6b7c3e",
							Role:   "regular",
						},
					},
				},
				{
					RoomId:    "e57fc491-69f7-4b30-9979-78879c8873bf",
					Name:      nullableName,
					RoomType:  string(db.RoomTypePrivate),
					IsBlocked: false,
					Users: []openapiChat.SchemasUserResponse{
						{
							UserId: roomCreatorID,
							Role:   "regular",
						},
						{
							UserId: "c31384a6-b811-4a1f-befa-95dd53e3f4b9",
							Role:   "regular",
						},
					},
				},
			},
		}

		assert.Equal(t, http.StatusOK, response.StatusCode)
		assert.Equal(t, expectedData, getRoomsResponse)
	})
}

func TestCreateRoom(t *testing.T) {
	newConfig, err := config.LoadConfig("../../")
	if err != nil {
		t.Fatalf("Failed to load config: %v", err)
	}

	chatApi := openapi.MakeChatAPIClient(&newConfig)
	_, err = chatApi.DevAPI.DevResetDbGet(context.Background()).Execute()
	if err != nil {
		t.Fatalf("Failed to reset db: %v", err)
	}

	roomCreatorID := "5bee7465-220d-40e7-82d7-b9b607fff21c"
	userID := "f4cbdb32-0fc0-4704-a6d9-9cf357e5cd3e"

	token, err := auth.GenerateTestJWT(newConfig.SecretSessionKey, roomCreatorID)
	if err != nil {
		t.Fatalf("Failed to generate JWT: %v", err)
	}

	var userIDNullableString = openapiChat.NullableString{}
	userIDNullableString.Set(&userID)

	request := openapiChat.SchemasCreateRoomPayload{
		Name:     openapiChat.NullableString{},
		RoomType: "private",
		UserId:   userIDNullableString,
	}

	t.Run("should create a private room and return it successfully", func(t *testing.T) {
		ctx := context.WithValue(context.Background(), auth.ContextKeyAuthorization, "Bearer "+token)
		createRoomResponse, response, err := chatApi.RoomAPI.CreateRoom(ctx).Request(request).Execute()
		if err != nil {
			t.Fatalf("Failed to get chat preview: %v", err)
		}

		nullableName := openapiChat.NullableString{}
		nullableName.Set(nil)
		expectedData := openapiChat.SchemasRoomPopulatedResponse{
			RoomType: string(db.RoomTypePrivate),
			Users: []openapiChat.SchemasUserResponse{
				{
					UserId: roomCreatorID,
					Role:   "regular",
				},
				{
					UserId: userID,
					Role:   "regular",
				},
			},
			Name:      nullableName,
			Messages:  []openapiChat.SchemasMessageResponse{},
			IsBlocked: false,
		}

		assert.Equal(t, http.StatusOK, response.StatusCode)

		assert.Equal(t, expectedData.RoomType, createRoomResponse.RoomType)
		assert.Equal(t, expectedData.Users, createRoomResponse.Users)
		assert.Equal(t, expectedData.Name, createRoomResponse.Name)
		assert.Equal(t, expectedData.Messages, createRoomResponse.Messages)
		assert.Equal(t, expectedData.IsBlocked, createRoomResponse.IsBlocked)
	})

	t.Run("should return error if private room already exists", func(t *testing.T) {
		ctx := context.WithValue(context.Background(), auth.ContextKeyAuthorization, "Bearer "+token)
		_, response, err := chatApi.RoomAPI.CreateRoom(ctx).Request(request).Execute()
		if err != nil {
			message, extractErr := utils.ExtractErrorMessageFromResponse(response)
			if extractErr != nil {
				t.Fatalf(extractErr.Error())
			}

			assert.Equal(t, http.StatusInternalServerError, response.StatusCode)
			assert.Equal(t, "A private room for these users already exists", message)
		}
	})
}
