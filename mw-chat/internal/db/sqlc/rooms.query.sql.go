// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: rooms.query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRoom = `-- name: CreateRoom :one
INSERT INTO rooms (created_at, name, type)
VALUES ($1, $2, $3)
RETURNING uuid
`

type CreateRoomParams struct {
	CreatedAt pgtype.Timestamp `json:"created_at"`
	Name      string           `json:"name"`
	Type      RoomType         `json:"type"`
}

func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createRoom, arg.CreatedAt, arg.Name, arg.Type)
	var uuid pgtype.UUID
	err := row.Scan(&uuid)
	return uuid, err
}

const getRoomsByUserUUID = `-- name: GetRoomsByUserUUID :many
SELECT
    rooms.uuid,
    rooms.type
FROM rooms
JOIN users_rooms ON rooms.uuid = users_rooms.room_uuid
WHERE users_rooms.user_uuid = $1 AND rooms.type = $2
`

type GetRoomsByUserUUIDParams struct {
	UserUuid pgtype.UUID `json:"user_uuid"`
	RoomType RoomType    `json:"room_type"`
}

type GetRoomsByUserUUIDRow struct {
	Uuid pgtype.UUID `json:"uuid"`
	Type RoomType    `json:"type"`
}

func (q *Queries) GetRoomsByUserUUID(ctx context.Context, arg GetRoomsByUserUUIDParams) ([]GetRoomsByUserUUIDRow, error) {
	rows, err := q.db.Query(ctx, getRoomsByUserUUID, arg.UserUuid, arg.RoomType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRoomsByUserUUIDRow{}
	for rows.Next() {
		var i GetRoomsByUserUUIDRow
		if err := rows.Scan(&i.Uuid, &i.Type); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
