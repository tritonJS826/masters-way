// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: rooms.query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRoom = `-- name: CreateRoom :one
INSERT INTO rooms (created_at, name, type)
VALUES ($1, $2, $3)
RETURNING uuid, name, type
`

type CreateRoomParams struct {
	CreatedAt pgtype.Timestamp `json:"created_at"`
	Name      pgtype.Text      `json:"name"`
	Type      RoomType         `json:"type"`
}

type CreateRoomRow struct {
	Uuid pgtype.UUID `json:"uuid"`
	Name pgtype.Text `json:"name"`
	Type RoomType    `json:"type"`
}

func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) (CreateRoomRow, error) {
	row := q.db.QueryRow(ctx, createRoom, arg.CreatedAt, arg.Name, arg.Type)
	var i CreateRoomRow
	err := row.Scan(&i.Uuid, &i.Name, &i.Type)
	return i, err
}

const getPrivateRoomByUserUUIDs = `-- name: GetPrivateRoomByUserUUIDs :one
SELECT rooms.uuid
FROM rooms
	JOIN users_rooms AS user1 on user1.room_uuid = rooms.uuid
		and user1.user_uuid = $1
	JOIN users_rooms AS user2 on user2.room_uuid = rooms.uuid
		and user2.user_uuid = $2
WHERE rooms.type = 'private'
`

type GetPrivateRoomByUserUUIDsParams struct {
	User1 pgtype.UUID `json:"user_1"`
	User2 pgtype.UUID `json:"user_2"`
}

func (q *Queries) GetPrivateRoomByUserUUIDs(ctx context.Context, arg GetPrivateRoomByUserUUIDsParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, getPrivateRoomByUserUUIDs, arg.User1, arg.User2)
	var uuid pgtype.UUID
	err := row.Scan(&uuid)
	return uuid, err
}

const getRoomByUUID = `-- name: GetRoomByUUID :one
SELECT
    rooms.uuid,
    rooms.name,
    rooms.type,
    users_rooms.is_room_blocked,
    ARRAY(
        SELECT
            users_rooms.user_uuid
        FROM users_rooms
        WHERE users_rooms.room_uuid = rooms.uuid
        ORDER BY updated_at DESC
    )::UUID[] AS user_uuids,
    ARRAY(
        SELECT
            users_rooms.user_role
        FROM users_rooms
        WHERE users_rooms.room_uuid = rooms.uuid
        ORDER BY updated_at DESC
    )::VARCHAR[] AS user_roles
FROM rooms
JOIN users_rooms ON rooms.uuid = users_rooms.room_uuid
WHERE rooms.uuid = $1
`

type GetRoomByUUIDRow struct {
	Uuid          pgtype.UUID   `json:"uuid"`
	Name          pgtype.Text   `json:"name"`
	Type          RoomType      `json:"type"`
	IsRoomBlocked bool          `json:"is_room_blocked"`
	UserUuids     []pgtype.UUID `json:"user_uuids"`
	UserRoles     []string      `json:"user_roles"`
}

func (q *Queries) GetRoomByUUID(ctx context.Context, roomUuid pgtype.UUID) (GetRoomByUUIDRow, error) {
	row := q.db.QueryRow(ctx, getRoomByUUID, roomUuid)
	var i GetRoomByUUIDRow
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Type,
		&i.IsRoomBlocked,
		&i.UserUuids,
		&i.UserRoles,
	)
	return i, err
}

const getRoomsByUserUUID = `-- name: GetRoomsByUserUUID :many
SELECT
    rooms.uuid,
    rooms.name,
    rooms.type,
    users_rooms.is_room_blocked,
    ARRAY(
        SELECT
            users_rooms.user_uuid
        FROM users_rooms
        WHERE users_rooms.room_uuid = rooms.uuid
        ORDER BY updated_at DESC
    )::UUID[] AS user_uuids,
    ARRAY(
        SELECT
            users_rooms.user_role
        FROM users_rooms
        WHERE users_rooms.room_uuid = rooms.uuid
        ORDER BY updated_at DESC
    )::VARCHAR[] AS user_roles,
    COALESCE(message_counts.unread_message_count, 0) AS unread_message_count                                          
FROM rooms                                                                
JOIN users_rooms ON rooms.uuid = users_rooms.room_uuid                    
LEFT JOIN (                                                                    
    SELECT room_uuid, COUNT(*) AS unread_message_count                           
    FROM messages
    LEFT JOIN message_status ON message_status.message_uuid = messages.uuid
    WHERE message_status.is_read = false
        AND messages.owner_uuid <> $1
    GROUP BY room_uuid
) AS message_counts ON rooms.uuid = message_counts.room_uuid              
WHERE users_rooms.user_uuid = $1 AND rooms.type = $2      
GROUP BY rooms.uuid, rooms.name, rooms.type, users_rooms.is_room_blocked, message_counts.unread_message_count                                                
ORDER BY MAX(users_rooms.updated_at) DESC
`

type GetRoomsByUserUUIDParams struct {
	UserUuid pgtype.UUID `json:"user_uuid"`
	RoomType RoomType    `json:"room_type"`
}

type GetRoomsByUserUUIDRow struct {
	Uuid               pgtype.UUID   `json:"uuid"`
	Name               pgtype.Text   `json:"name"`
	Type               RoomType      `json:"type"`
	IsRoomBlocked      bool          `json:"is_room_blocked"`
	UserUuids          []pgtype.UUID `json:"user_uuids"`
	UserRoles          []string      `json:"user_roles"`
	UnreadMessageCount int64         `json:"unread_message_count"`
}

func (q *Queries) GetRoomsByUserUUID(ctx context.Context, arg GetRoomsByUserUUIDParams) ([]GetRoomsByUserUUIDRow, error) {
	rows, err := q.db.Query(ctx, getRoomsByUserUUID, arg.UserUuid, arg.RoomType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRoomsByUserUUIDRow{}
	for rows.Next() {
		var i GetRoomsByUserUUIDRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Type,
			&i.IsRoomBlocked,
			&i.UserUuids,
			&i.UserRoles,
			&i.UnreadMessageCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
