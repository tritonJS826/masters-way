// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: rooms.query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRoom = `-- name: CreateRoom :one
INSERT INTO rooms (created_at, name, type)
VALUES ($1, $2, $3)
RETURNING uuid
`

type CreateRoomParams struct {
	CreatedAt pgtype.Timestamp `json:"created_at"`
	Name      string           `json:"name"`
	Type      RoomType         `json:"type"`
}

func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) (pgtype.UUID, error) {
	row := q.db.QueryRow(ctx, createRoom, arg.CreatedAt, arg.Name, arg.Type)
	var uuid pgtype.UUID
	err := row.Scan(&uuid)
	return uuid, err
}

const getRoomByUUID = `-- name: GetRoomByUUID :one
SELECT
    rooms.uuid,
    rooms.name,
    rooms.type,
    users_rooms.is_room_blocked,
    ARRAY(
        SELECT
            users_rooms.user_uuid
        FROM users_rooms
        WHERE users_rooms.room_uuid = rooms.uuid
    )::UUID[] AS user_uuids,
    ARRAY(
            SELECT
                users_rooms.role
            FROM users_rooms
            WHERE users_rooms.room_uuid = rooms.uuid
    )::VARCHAR[] AS user_roles
FROM rooms
JOIN users_rooms ON rooms.uuid = users_rooms.room_uuid
WHERE rooms.uuid = $1 AND users_rooms.user_uuid = $2
`

type GetRoomByUUIDParams struct {
	RoomUuid pgtype.UUID `json:"room_uuid"`
	UserUuid pgtype.UUID `json:"user_uuid"`
}

type GetRoomByUUIDRow struct {
	Uuid          pgtype.UUID   `json:"uuid"`
	Name          string        `json:"name"`
	Type          RoomType      `json:"type"`
	IsRoomBlocked bool          `json:"is_room_blocked"`
	UserUuids     []pgtype.UUID `json:"user_uuids"`
	UserRoles     []string      `json:"user_roles"`
}

func (q *Queries) GetRoomByUUID(ctx context.Context, arg GetRoomByUUIDParams) (GetRoomByUUIDRow, error) {
	row := q.db.QueryRow(ctx, getRoomByUUID, arg.RoomUuid, arg.UserUuid)
	var i GetRoomByUUIDRow
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Type,
		&i.IsRoomBlocked,
		&i.UserUuids,
		&i.UserRoles,
	)
	return i, err
}

const getRoomsByUserUUID = `-- name: GetRoomsByUserUUID :many
SELECT
    rooms.uuid,
    rooms.name,
    rooms.type,
    users_rooms.is_room_blocked,
    ARRAY(
        SELECT
            users_rooms.user_uuid
        FROM users_rooms
        WHERE users_rooms.room_uuid = rooms.uuid
    )::UUID[] AS user_uuids,
    ARRAY(
            SELECT
                users_rooms.role
            FROM users_rooms
            WHERE users_rooms.room_uuid = rooms.uuid
    )::VARCHAR[] AS user_roles
FROM rooms
JOIN users_rooms ON rooms.uuid = users_rooms.room_uuid
WHERE users_rooms.user_uuid = $1 AND rooms.type = $2
`

type GetRoomsByUserUUIDParams struct {
	UserUuid pgtype.UUID `json:"user_uuid"`
	RoomType RoomType    `json:"room_type"`
}

type GetRoomsByUserUUIDRow struct {
	Uuid          pgtype.UUID   `json:"uuid"`
	Name          string        `json:"name"`
	Type          RoomType      `json:"type"`
	IsRoomBlocked bool          `json:"is_room_blocked"`
	UserUuids     []pgtype.UUID `json:"user_uuids"`
	UserRoles     []string      `json:"user_roles"`
}

func (q *Queries) GetRoomsByUserUUID(ctx context.Context, arg GetRoomsByUserUUIDParams) ([]GetRoomsByUserUUIDRow, error) {
	rows, err := q.db.Query(ctx, getRoomsByUserUUID, arg.UserUuid, arg.RoomType)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetRoomsByUserUUIDRow{}
	for rows.Next() {
		var i GetRoomsByUserUUIDRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Type,
			&i.IsRoomBlocked,
			&i.UserUuids,
			&i.UserRoles,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
