// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: p2p_rooms.query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createP2PRoom = `-- name: CreateP2PRoom :one
INSERT INTO p2p_rooms (created_at)
VALUES ($1)
RETURNING uuid, blocked_by_user_uuid
`

type CreateP2PRoomRow struct {
	Uuid              pgtype.UUID `json:"uuid"`
	BlockedByUserUuid pgtype.UUID `json:"blocked_by_user_uuid"`
}

func (q *Queries) CreateP2PRoom(ctx context.Context, createdAt pgtype.Timestamp) (CreateP2PRoomRow, error) {
	row := q.db.QueryRow(ctx, createP2PRoom, createdAt)
	var i CreateP2PRoomRow
	err := row.Scan(&i.Uuid, &i.BlockedByUserUuid)
	return i, err
}

const getP2PRoomByUUID = `-- name: GetP2PRoomByUUID :one
SELECT uuid, created_at, blocked_by_user_uuid FROM p2p_rooms
WHERE uuid = $1
`

func (q *Queries) GetP2PRoomByUUID(ctx context.Context, p2pRoomUuid pgtype.UUID) (P2pRoom, error) {
	row := q.db.QueryRow(ctx, getP2PRoomByUUID, p2pRoomUuid)
	var i P2pRoom
	err := row.Scan(&i.Uuid, &i.CreatedAt, &i.BlockedByUserUuid)
	return i, err
}

const getP2PRoomsWithInterlocutorByUserUUID = `-- name: GetP2PRoomsWithInterlocutorByUserUUID :many
SELECT
    p2p_rooms.uuid,
    p2p_rooms.blocked_by_user_uuid,
    (SELECT user_uuid
     FROM users_p2p_rooms
     WHERE room_uuid = p2p_rooms.uuid AND users_p2p_rooms.user_uuid <> $1
    ) AS interlocutor
FROM p2p_rooms
JOIN users_p2p_rooms ON p2p_rooms.uuid = users_p2p_rooms.room_uuid
WHERE users_p2p_rooms.user_uuid = $1
`

type GetP2PRoomsWithInterlocutorByUserUUIDRow struct {
	Uuid              pgtype.UUID `json:"uuid"`
	BlockedByUserUuid pgtype.UUID `json:"blocked_by_user_uuid"`
	Interlocutor      pgtype.UUID `json:"interlocutor"`
}

func (q *Queries) GetP2PRoomsWithInterlocutorByUserUUID(ctx context.Context, userUuid pgtype.UUID) ([]GetP2PRoomsWithInterlocutorByUserUUIDRow, error) {
	rows, err := q.db.Query(ctx, getP2PRoomsWithInterlocutorByUserUUID, userUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetP2PRoomsWithInterlocutorByUserUUIDRow{}
	for rows.Next() {
		var i GetP2PRoomsWithInterlocutorByUserUUIDRow
		if err := rows.Scan(&i.Uuid, &i.BlockedByUserUuid, &i.Interlocutor); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const toggleBlockP2PRoom = `-- name: ToggleBlockP2PRoom :exec
UPDATE p2p_rooms
SET blocked_by_user_uuid = CASE
    WHEN $1 IS NOT NULL THEN $1
    ELSE NULL
END
WHERE uuid = $2
`

type ToggleBlockP2PRoomParams struct {
	UserUuid pgtype.UUID `json:"user_uuid"`
	RoomUuid pgtype.UUID `json:"room_uuid"`
}

func (q *Queries) ToggleBlockP2PRoom(ctx context.Context, arg ToggleBlockP2PRoomParams) error {
	_, err := q.db.Exec(ctx, toggleBlockP2PRoom, arg.UserUuid, arg.RoomUuid)
	return err
}
