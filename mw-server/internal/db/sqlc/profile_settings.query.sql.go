// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: profile_settings.query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCoinsCountByUserId = `-- name: GetCoinsCountByUserId :one
SELECT
    coins
FROM
    profile_settings
WHERE
    owner_uuid = $1
`

func (q *Queries) GetCoinsCountByUserId(ctx context.Context, userUuid pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getCoinsCountByUserId, userUuid)
	var coins int32
	err := row.Scan(&coins)
	return coins, err
}

const getPricingPlanByUserId = `-- name: GetPricingPlanByUserId :one
SELECT pricing_plan
FROM profile_settings
WHERE owner_uuid = $1
`

func (q *Queries) GetPricingPlanByUserId(ctx context.Context, userUuid pgtype.UUID) (PricingPlanType, error) {
	row := q.db.QueryRow(ctx, getPricingPlanByUserId, userUuid)
	var pricing_plan PricingPlanType
	err := row.Scan(&pricing_plan)
	return pricing_plan, err
}

const getProfileSettingUserId = `-- name: GetProfileSettingUserId :one
SELECT 
    uuid,
    pricing_plan,
    coins,
    expiration_date
FROM profile_settings
WHERE owner_uuid = $1
`

type GetProfileSettingUserIdRow struct {
	Uuid           pgtype.UUID      `json:"uuid"`
	PricingPlan    PricingPlanType  `json:"pricing_plan"`
	Coins          int32            `json:"coins"`
	ExpirationDate pgtype.Timestamp `json:"expiration_date"`
}

func (q *Queries) GetProfileSettingUserId(ctx context.Context, userUuid pgtype.UUID) (GetProfileSettingUserIdRow, error) {
	row := q.db.QueryRow(ctx, getProfileSettingUserId, userUuid)
	var i GetProfileSettingUserIdRow
	err := row.Scan(
		&i.Uuid,
		&i.PricingPlan,
		&i.Coins,
		&i.ExpirationDate,
	)
	return i, err
}

const reduceCoinsByUserId = `-- name: ReduceCoinsByUserId :one
UPDATE
    profile_settings
SET
    coins = profile_settings.coins - $1
WHERE
    profile_settings.owner_uuid = $2
RETURNING
    uuid,
    pricing_plan,
    coins,
    expiration_date
`

type ReduceCoinsByUserIdParams struct {
	Coins     int32       `json:"coins"`
	OwnerUuid pgtype.UUID `json:"owner_uuid"`
}

type ReduceCoinsByUserIdRow struct {
	Uuid           pgtype.UUID      `json:"uuid"`
	PricingPlan    PricingPlanType  `json:"pricing_plan"`
	Coins          int32            `json:"coins"`
	ExpirationDate pgtype.Timestamp `json:"expiration_date"`
}

func (q *Queries) ReduceCoinsByUserId(ctx context.Context, arg ReduceCoinsByUserIdParams) (ReduceCoinsByUserIdRow, error) {
	row := q.db.QueryRow(ctx, reduceCoinsByUserId, arg.Coins, arg.OwnerUuid)
	var i ReduceCoinsByUserIdRow
	err := row.Scan(
		&i.Uuid,
		&i.PricingPlan,
		&i.Coins,
		&i.ExpirationDate,
	)
	return i, err
}

const refillCoinsForAll = `-- name: RefillCoinsForAll :many
UPDATE
    profile_settings
SET
    expiration_date = (CURRENT_DATE + INTERVAL '1 month'),
    -- TODO: AFTER ADDING PAYMENTS
    -- We should change coins to 50 for everyone with (expiration_date < CURRENT_DATE)
    -- and also we should change pricing plan to free automatically
    -- in this case payment system should change pricing plan and coins and expiration date by another query 
    coins = CASE
        WHEN pricing_plan = 'free' THEN 50
        WHEN pricing_plan = 'ai-starter' THEN 1500
        WHEN pricing_plan = 'starter' THEN 2000
        WHEN pricing_plan = 'pro' THEN 4000
        ELSE coins
    END
WHERE
    expiration_date < CURRENT_DATE
RETURNING
    uuid,
    pricing_plan,
    coins,
    expiration_date
`

type RefillCoinsForAllRow struct {
	Uuid           pgtype.UUID      `json:"uuid"`
	PricingPlan    PricingPlanType  `json:"pricing_plan"`
	Coins          int32            `json:"coins"`
	ExpirationDate pgtype.Timestamp `json:"expiration_date"`
}

func (q *Queries) RefillCoinsForAll(ctx context.Context) ([]RefillCoinsForAllRow, error) {
	rows, err := q.db.Query(ctx, refillCoinsForAll)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RefillCoinsForAllRow{}
	for rows.Next() {
		var i RefillCoinsForAllRow
		if err := rows.Scan(
			&i.Uuid,
			&i.PricingPlan,
			&i.Coins,
			&i.ExpirationDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProfileSettingByUserId = `-- name: UpdateProfileSettingByUserId :one
UPDATE
    profile_settings
SET
    coins = coalesce($1, coins),
    pricing_plan = coalesce($2, pricing_plan),
    expiration_date = coalesce($3, expiration_date)
WHERE
    owner_uuid = $4
RETURNING 
    uuid,
    pricing_plan,
    coins,
    expiration_date
`

type UpdateProfileSettingByUserIdParams struct {
	Coins          pgtype.Int4         `json:"coins"`
	PricingPlan    NullPricingPlanType `json:"pricing_plan"`
	ExpirationDate pgtype.Timestamp    `json:"expiration_date"`
	UserUuid       pgtype.UUID         `json:"user_uuid"`
}

type UpdateProfileSettingByUserIdRow struct {
	Uuid           pgtype.UUID      `json:"uuid"`
	PricingPlan    PricingPlanType  `json:"pricing_plan"`
	Coins          int32            `json:"coins"`
	ExpirationDate pgtype.Timestamp `json:"expiration_date"`
}

func (q *Queries) UpdateProfileSettingByUserId(ctx context.Context, arg UpdateProfileSettingByUserIdParams) (UpdateProfileSettingByUserIdRow, error) {
	row := q.db.QueryRow(ctx, updateProfileSettingByUserId,
		arg.Coins,
		arg.PricingPlan,
		arg.ExpirationDate,
		arg.UserUuid,
	)
	var i UpdateProfileSettingByUserIdRow
	err := row.Scan(
		&i.Uuid,
		&i.PricingPlan,
		&i.Coins,
		&i.ExpirationDate,
	)
	return i, err
}
