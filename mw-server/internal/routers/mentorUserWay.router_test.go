package routers

import (
	"context"
	openapiGeneral "mw-server/apiAutogenerated/general"
	"mw-server/internal/auth"
	"mw-server/internal/config"
	"mw-server/internal/openapi"
	"net/http"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestAddMentorUserWay(t *testing.T) {
	newConfig, err := config.LoadConfig("../../")
	if err != nil {
		t.Fatalf("Failed to load config: %v", err)
	}

	generalApi := openapi.MakeGeneralAPIClient(&newConfig)
	_, err = generalApi.DevAPI.DevResetDbGet(context.Background()).Execute()
	if err != nil {
		t.Fatalf("Failed to reset db: %v", err)
	}

	userID := "d2cb5e1b-44df-48d3-b7a1-34f3d7a5b7e2"
	newMentorID := "3d922e8a-5d58-4b82-9a3d-83e2e73b3f91"
	wayID := "32cb5e1b-44df-48d3-b7a1-34f3d7a5b7e2"

	t.Run("should successfully create a MentorUserWay and ensure the new mentor is associated with the specified Way", func(t *testing.T) {
		token, err := auth.GenerateJWT(userID, newConfig.SecretSessionKey)
		if err != nil {
			t.Fatalf("Failed to generate JWT: %v", err)
		}

		request := openapiGeneral.MwServerInternalSchemasCreateMentorUserWayPayload{
			UserUuid: newMentorID,
			WayUuid:  wayID,
		}

		ctx := context.WithValue(context.Background(), auth.ContextKeyAuthorization, "Bearer "+token)
		response, err := generalApi.MentorUserWayAPI.CreateMentorUserWay(ctx).Request(request).Execute()
		if err != nil {
			t.Fatalf("Failed to create MentorUserWay: %v", err)
		}

		assert.Equal(t, http.StatusNoContent, response.StatusCode)

		way, response, err := generalApi.WayAPI.GetWayByUuid(ctx, wayID).Execute()
		if err != nil {
			t.Fatalf("Failed to get Way by id: %v", err)
		}

		mentorFound := false
		for _, mentor := range way.Mentors {
			if mentor.Uuid == newMentorID {
				mentorFound = true
				break
			}
		}

		if !mentorFound {
			t.Fatalf("Mentor with UUID %s was not found in the Way", newMentorID)
		}
	})
}

func TestDeleteMentorUserWay(t *testing.T) {
	newConfig, err := config.LoadConfig("../../")
	if err != nil {
		t.Fatalf("Failed to load config: %v", err)
	}

	generalApi := openapi.MakeGeneralAPIClient(&newConfig)
	_, err = generalApi.DevAPI.DevResetDbGet(context.Background()).Execute()
	if err != nil {
		t.Fatalf("Failed to reset db: %v", err)
	}

	userID := "d2cb5e1b-44df-48d3-b7a1-34f3d7a5b7e2"
	newMentorID := "3d922e8a-5d58-4b82-9a3d-83e2e73b3f91"
	wayID := "32cb5e1b-44df-48d3-b7a1-34f3d7a5b7e2"

	t.Run("should successfully delete a MentorUserWay and ensure the mentor is no longer associated with the specified Way", func(t *testing.T) {
		token, err := auth.GenerateJWT(userID, newConfig.SecretSessionKey)
		if err != nil {
			t.Fatalf("Failed to generate JWT: %v", err)
		}

		request := openapiGeneral.MwServerInternalSchemasDeleteMentorUserWayPayload{
			UserUuid: newMentorID,
			WayUuid:  wayID,
		}

		ctx := context.WithValue(context.Background(), auth.ContextKeyAuthorization, "Bearer "+token)
		response, err := generalApi.MentorUserWayAPI.DeleteMentorUserWay(ctx).Request(request).Execute()
		if err != nil {
			t.Fatalf("Failed to delete MentorUserWay: %v", err)
		}

		assert.Equal(t, http.StatusNoContent, response.StatusCode)

		way, response, err := generalApi.WayAPI.GetWayByUuid(ctx, wayID).Execute()
		if err != nil {
			t.Fatalf("Failed to get Way by id: %v", err)
		}
		mentorFound := false
		for _, mentor := range way.Mentors {
			if mentor.Uuid == newMentorID {
				mentorFound = true
				break
			}
		}

		if mentorFound {
			t.Fatalf("Mentor with UUID %s was found in the Way after deletion", newMentorID)
		}
	})
}
