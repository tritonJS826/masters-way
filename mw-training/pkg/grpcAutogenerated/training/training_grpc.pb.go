// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package training

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// TrainingTrainingTagServiceClient is the client API for TrainingTrainingTagService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TrainingTrainingTagServiceClient interface {
	CreateTrainingTrainingTag(ctx context.Context, in *CreateTrainingTagRequest, opts ...grpc.CallOption) (*TrainingTag, error)
	GetTrainingTags(ctx context.Context, in *GetTrainingTagsRequest, opts ...grpc.CallOption) (*TrainingTagList, error)
	DeleteTrainingTrainingTag(ctx context.Context, in *DeleteTrainingTagRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type trainingTrainingTagServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTrainingTrainingTagServiceClient(cc grpc.ClientConnInterface) TrainingTrainingTagServiceClient {
	return &trainingTrainingTagServiceClient{cc}
}

func (c *trainingTrainingTagServiceClient) CreateTrainingTrainingTag(ctx context.Context, in *CreateTrainingTagRequest, opts ...grpc.CallOption) (*TrainingTag, error) {
	out := new(TrainingTag)
	err := c.cc.Invoke(ctx, "/training.TrainingTrainingTagService/CreateTrainingTrainingTag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainingTrainingTagServiceClient) GetTrainingTags(ctx context.Context, in *GetTrainingTagsRequest, opts ...grpc.CallOption) (*TrainingTagList, error) {
	out := new(TrainingTagList)
	err := c.cc.Invoke(ctx, "/training.TrainingTrainingTagService/GetTrainingTags", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainingTrainingTagServiceClient) DeleteTrainingTrainingTag(ctx context.Context, in *DeleteTrainingTagRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/training.TrainingTrainingTagService/DeleteTrainingTrainingTag", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TrainingTrainingTagServiceServer is the server API for TrainingTrainingTagService service.
// All implementations must embed UnimplementedTrainingTrainingTagServiceServer
// for forward compatibility
type TrainingTrainingTagServiceServer interface {
	CreateTrainingTrainingTag(context.Context, *CreateTrainingTagRequest) (*TrainingTag, error)
	GetTrainingTags(context.Context, *GetTrainingTagsRequest) (*TrainingTagList, error)
	DeleteTrainingTrainingTag(context.Context, *DeleteTrainingTagRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedTrainingTrainingTagServiceServer()
}

// UnimplementedTrainingTrainingTagServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTrainingTrainingTagServiceServer struct {
}

func (UnimplementedTrainingTrainingTagServiceServer) CreateTrainingTrainingTag(context.Context, *CreateTrainingTagRequest) (*TrainingTag, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTrainingTrainingTag not implemented")
}
func (UnimplementedTrainingTrainingTagServiceServer) GetTrainingTags(context.Context, *GetTrainingTagsRequest) (*TrainingTagList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrainingTags not implemented")
}
func (UnimplementedTrainingTrainingTagServiceServer) DeleteTrainingTrainingTag(context.Context, *DeleteTrainingTagRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTrainingTrainingTag not implemented")
}
func (UnimplementedTrainingTrainingTagServiceServer) mustEmbedUnimplementedTrainingTrainingTagServiceServer() {
}

// UnsafeTrainingTrainingTagServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TrainingTrainingTagServiceServer will
// result in compilation errors.
type UnsafeTrainingTrainingTagServiceServer interface {
	mustEmbedUnimplementedTrainingTrainingTagServiceServer()
}

func RegisterTrainingTrainingTagServiceServer(s grpc.ServiceRegistrar, srv TrainingTrainingTagServiceServer) {
	s.RegisterService(&TrainingTrainingTagService_ServiceDesc, srv)
}

func _TrainingTrainingTagService_CreateTrainingTrainingTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTrainingTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingTrainingTagServiceServer).CreateTrainingTrainingTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TrainingTrainingTagService/CreateTrainingTrainingTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingTrainingTagServiceServer).CreateTrainingTrainingTag(ctx, req.(*CreateTrainingTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrainingTrainingTagService_GetTrainingTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTrainingTagsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingTrainingTagServiceServer).GetTrainingTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TrainingTrainingTagService/GetTrainingTags",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingTrainingTagServiceServer).GetTrainingTags(ctx, req.(*GetTrainingTagsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrainingTrainingTagService_DeleteTrainingTrainingTag_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTrainingTagRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingTrainingTagServiceServer).DeleteTrainingTrainingTag(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TrainingTrainingTagService/DeleteTrainingTrainingTag",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingTrainingTagServiceServer).DeleteTrainingTrainingTag(ctx, req.(*DeleteTrainingTagRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TrainingTrainingTagService_ServiceDesc is the grpc.ServiceDesc for TrainingTrainingTagService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TrainingTrainingTagService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "training.TrainingTrainingTagService",
	HandlerType: (*TrainingTrainingTagServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTrainingTrainingTag",
			Handler:    _TrainingTrainingTagService_CreateTrainingTrainingTag_Handler,
		},
		{
			MethodName: "GetTrainingTags",
			Handler:    _TrainingTrainingTagService_GetTrainingTags_Handler,
		},
		{
			MethodName: "DeleteTrainingTrainingTag",
			Handler:    _TrainingTrainingTagService_DeleteTrainingTrainingTag_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "training.proto",
}

// TrainingServiceClient is the client API for TrainingService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TrainingServiceClient interface {
	CreateNewTraining(ctx context.Context, in *CreateTrainingRequest, opts ...grpc.CallOption) (*Training, error)
	GetTrainingById(ctx context.Context, in *GetTrainingRequest, opts ...grpc.CallOption) (*Training, error)
	GetTrainingListForUser(ctx context.Context, in *GetTrainingListForUserRequest, opts ...grpc.CallOption) (*TrainingPreviewList, error)
	GetTrainingsAmountByUserId(ctx context.Context, in *GetTrainingsAmountByUserIdRequest, opts ...grpc.CallOption) (*TrainingsAmount, error)
	GetTrainingList(ctx context.Context, in *GetTrainingListRequest, opts ...grpc.CallOption) (*TrainingPreviewList, error)
	UpdateTraining(ctx context.Context, in *UpdateTrainingRequest, opts ...grpc.CallOption) (*Training, error)
	DeleteTraining(ctx context.Context, in *DeleteTrainingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type trainingServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTrainingServiceClient(cc grpc.ClientConnInterface) TrainingServiceClient {
	return &trainingServiceClient{cc}
}

func (c *trainingServiceClient) CreateNewTraining(ctx context.Context, in *CreateTrainingRequest, opts ...grpc.CallOption) (*Training, error) {
	out := new(Training)
	err := c.cc.Invoke(ctx, "/training.TrainingService/CreateNewTraining", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainingServiceClient) GetTrainingById(ctx context.Context, in *GetTrainingRequest, opts ...grpc.CallOption) (*Training, error) {
	out := new(Training)
	err := c.cc.Invoke(ctx, "/training.TrainingService/GetTrainingById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainingServiceClient) GetTrainingListForUser(ctx context.Context, in *GetTrainingListForUserRequest, opts ...grpc.CallOption) (*TrainingPreviewList, error) {
	out := new(TrainingPreviewList)
	err := c.cc.Invoke(ctx, "/training.TrainingService/GetTrainingListForUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainingServiceClient) GetTrainingsAmountByUserId(ctx context.Context, in *GetTrainingsAmountByUserIdRequest, opts ...grpc.CallOption) (*TrainingsAmount, error) {
	out := new(TrainingsAmount)
	err := c.cc.Invoke(ctx, "/training.TrainingService/GetTrainingsAmountByUserId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainingServiceClient) GetTrainingList(ctx context.Context, in *GetTrainingListRequest, opts ...grpc.CallOption) (*TrainingPreviewList, error) {
	out := new(TrainingPreviewList)
	err := c.cc.Invoke(ctx, "/training.TrainingService/GetTrainingList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainingServiceClient) UpdateTraining(ctx context.Context, in *UpdateTrainingRequest, opts ...grpc.CallOption) (*Training, error) {
	out := new(Training)
	err := c.cc.Invoke(ctx, "/training.TrainingService/UpdateTraining", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainingServiceClient) DeleteTraining(ctx context.Context, in *DeleteTrainingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/training.TrainingService/DeleteTraining", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TrainingServiceServer is the server API for TrainingService service.
// All implementations must embed UnimplementedTrainingServiceServer
// for forward compatibility
type TrainingServiceServer interface {
	CreateNewTraining(context.Context, *CreateTrainingRequest) (*Training, error)
	GetTrainingById(context.Context, *GetTrainingRequest) (*Training, error)
	GetTrainingListForUser(context.Context, *GetTrainingListForUserRequest) (*TrainingPreviewList, error)
	GetTrainingsAmountByUserId(context.Context, *GetTrainingsAmountByUserIdRequest) (*TrainingsAmount, error)
	GetTrainingList(context.Context, *GetTrainingListRequest) (*TrainingPreviewList, error)
	UpdateTraining(context.Context, *UpdateTrainingRequest) (*Training, error)
	DeleteTraining(context.Context, *DeleteTrainingRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedTrainingServiceServer()
}

// UnimplementedTrainingServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTrainingServiceServer struct {
}

func (UnimplementedTrainingServiceServer) CreateNewTraining(context.Context, *CreateTrainingRequest) (*Training, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNewTraining not implemented")
}
func (UnimplementedTrainingServiceServer) GetTrainingById(context.Context, *GetTrainingRequest) (*Training, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrainingById not implemented")
}
func (UnimplementedTrainingServiceServer) GetTrainingListForUser(context.Context, *GetTrainingListForUserRequest) (*TrainingPreviewList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrainingListForUser not implemented")
}
func (UnimplementedTrainingServiceServer) GetTrainingsAmountByUserId(context.Context, *GetTrainingsAmountByUserIdRequest) (*TrainingsAmount, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrainingsAmountByUserId not implemented")
}
func (UnimplementedTrainingServiceServer) GetTrainingList(context.Context, *GetTrainingListRequest) (*TrainingPreviewList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTrainingList not implemented")
}
func (UnimplementedTrainingServiceServer) UpdateTraining(context.Context, *UpdateTrainingRequest) (*Training, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTraining not implemented")
}
func (UnimplementedTrainingServiceServer) DeleteTraining(context.Context, *DeleteTrainingRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTraining not implemented")
}
func (UnimplementedTrainingServiceServer) mustEmbedUnimplementedTrainingServiceServer() {}

// UnsafeTrainingServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TrainingServiceServer will
// result in compilation errors.
type UnsafeTrainingServiceServer interface {
	mustEmbedUnimplementedTrainingServiceServer()
}

func RegisterTrainingServiceServer(s grpc.ServiceRegistrar, srv TrainingServiceServer) {
	s.RegisterService(&TrainingService_ServiceDesc, srv)
}

func _TrainingService_CreateNewTraining_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTrainingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingServiceServer).CreateNewTraining(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TrainingService/CreateNewTraining",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingServiceServer).CreateNewTraining(ctx, req.(*CreateTrainingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrainingService_GetTrainingById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTrainingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingServiceServer).GetTrainingById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TrainingService/GetTrainingById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingServiceServer).GetTrainingById(ctx, req.(*GetTrainingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrainingService_GetTrainingListForUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTrainingListForUserRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingServiceServer).GetTrainingListForUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TrainingService/GetTrainingListForUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingServiceServer).GetTrainingListForUser(ctx, req.(*GetTrainingListForUserRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrainingService_GetTrainingsAmountByUserId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTrainingsAmountByUserIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingServiceServer).GetTrainingsAmountByUserId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TrainingService/GetTrainingsAmountByUserId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingServiceServer).GetTrainingsAmountByUserId(ctx, req.(*GetTrainingsAmountByUserIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrainingService_GetTrainingList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTrainingListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingServiceServer).GetTrainingList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TrainingService/GetTrainingList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingServiceServer).GetTrainingList(ctx, req.(*GetTrainingListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrainingService_UpdateTraining_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTrainingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingServiceServer).UpdateTraining(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TrainingService/UpdateTraining",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingServiceServer).UpdateTraining(ctx, req.(*UpdateTrainingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrainingService_DeleteTraining_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTrainingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingServiceServer).DeleteTraining(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TrainingService/DeleteTraining",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingServiceServer).DeleteTraining(ctx, req.(*DeleteTrainingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TrainingService_ServiceDesc is the grpc.ServiceDesc for TrainingService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TrainingService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "training.TrainingService",
	HandlerType: (*TrainingServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateNewTraining",
			Handler:    _TrainingService_CreateNewTraining_Handler,
		},
		{
			MethodName: "GetTrainingById",
			Handler:    _TrainingService_GetTrainingById_Handler,
		},
		{
			MethodName: "GetTrainingListForUser",
			Handler:    _TrainingService_GetTrainingListForUser_Handler,
		},
		{
			MethodName: "GetTrainingsAmountByUserId",
			Handler:    _TrainingService_GetTrainingsAmountByUserId_Handler,
		},
		{
			MethodName: "GetTrainingList",
			Handler:    _TrainingService_GetTrainingList_Handler,
		},
		{
			MethodName: "UpdateTraining",
			Handler:    _TrainingService_UpdateTraining_Handler,
		},
		{
			MethodName: "DeleteTraining",
			Handler:    _TrainingService_DeleteTraining_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "training.proto",
}

// TrainingMentorServiceClient is the client API for TrainingMentorService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TrainingMentorServiceClient interface {
	CreateTrainingMentor(ctx context.Context, in *CreateTrainingMentorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeleteTrainingMentor(ctx context.Context, in *DeleteTrainingMentorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type trainingMentorServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTrainingMentorServiceClient(cc grpc.ClientConnInterface) TrainingMentorServiceClient {
	return &trainingMentorServiceClient{cc}
}

func (c *trainingMentorServiceClient) CreateTrainingMentor(ctx context.Context, in *CreateTrainingMentorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/training.TrainingMentorService/CreateTrainingMentor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainingMentorServiceClient) DeleteTrainingMentor(ctx context.Context, in *DeleteTrainingMentorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/training.TrainingMentorService/DeleteTrainingMentor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TrainingMentorServiceServer is the server API for TrainingMentorService service.
// All implementations must embed UnimplementedTrainingMentorServiceServer
// for forward compatibility
type TrainingMentorServiceServer interface {
	CreateTrainingMentor(context.Context, *CreateTrainingMentorRequest) (*emptypb.Empty, error)
	DeleteTrainingMentor(context.Context, *DeleteTrainingMentorRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedTrainingMentorServiceServer()
}

// UnimplementedTrainingMentorServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTrainingMentorServiceServer struct {
}

func (UnimplementedTrainingMentorServiceServer) CreateTrainingMentor(context.Context, *CreateTrainingMentorRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTrainingMentor not implemented")
}
func (UnimplementedTrainingMentorServiceServer) DeleteTrainingMentor(context.Context, *DeleteTrainingMentorRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTrainingMentor not implemented")
}
func (UnimplementedTrainingMentorServiceServer) mustEmbedUnimplementedTrainingMentorServiceServer() {}

// UnsafeTrainingMentorServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TrainingMentorServiceServer will
// result in compilation errors.
type UnsafeTrainingMentorServiceServer interface {
	mustEmbedUnimplementedTrainingMentorServiceServer()
}

func RegisterTrainingMentorServiceServer(s grpc.ServiceRegistrar, srv TrainingMentorServiceServer) {
	s.RegisterService(&TrainingMentorService_ServiceDesc, srv)
}

func _TrainingMentorService_CreateTrainingMentor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTrainingMentorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingMentorServiceServer).CreateTrainingMentor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TrainingMentorService/CreateTrainingMentor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingMentorServiceServer).CreateTrainingMentor(ctx, req.(*CreateTrainingMentorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrainingMentorService_DeleteTrainingMentor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTrainingMentorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingMentorServiceServer).DeleteTrainingMentor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TrainingMentorService/DeleteTrainingMentor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingMentorServiceServer).DeleteTrainingMentor(ctx, req.(*DeleteTrainingMentorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TrainingMentorService_ServiceDesc is the grpc.ServiceDesc for TrainingMentorService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TrainingMentorService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "training.TrainingMentorService",
	HandlerType: (*TrainingMentorServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTrainingMentor",
			Handler:    _TrainingMentorService_CreateTrainingMentor_Handler,
		},
		{
			MethodName: "DeleteTrainingMentor",
			Handler:    _TrainingMentorService_DeleteTrainingMentor_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "training.proto",
}

// TrainingStudentServiceClient is the client API for TrainingStudentService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TrainingStudentServiceClient interface {
	CreateTrainingStudent(ctx context.Context, in *CreateTrainingStudentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeleteTrainingStudent(ctx context.Context, in *DeleteTrainingStudentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type trainingStudentServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTrainingStudentServiceClient(cc grpc.ClientConnInterface) TrainingStudentServiceClient {
	return &trainingStudentServiceClient{cc}
}

func (c *trainingStudentServiceClient) CreateTrainingStudent(ctx context.Context, in *CreateTrainingStudentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/training.TrainingStudentService/CreateTrainingStudent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainingStudentServiceClient) DeleteTrainingStudent(ctx context.Context, in *DeleteTrainingStudentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/training.TrainingStudentService/DeleteTrainingStudent", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TrainingStudentServiceServer is the server API for TrainingStudentService service.
// All implementations must embed UnimplementedTrainingStudentServiceServer
// for forward compatibility
type TrainingStudentServiceServer interface {
	CreateTrainingStudent(context.Context, *CreateTrainingStudentRequest) (*emptypb.Empty, error)
	DeleteTrainingStudent(context.Context, *DeleteTrainingStudentRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedTrainingStudentServiceServer()
}

// UnimplementedTrainingStudentServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTrainingStudentServiceServer struct {
}

func (UnimplementedTrainingStudentServiceServer) CreateTrainingStudent(context.Context, *CreateTrainingStudentRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTrainingStudent not implemented")
}
func (UnimplementedTrainingStudentServiceServer) DeleteTrainingStudent(context.Context, *DeleteTrainingStudentRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTrainingStudent not implemented")
}
func (UnimplementedTrainingStudentServiceServer) mustEmbedUnimplementedTrainingStudentServiceServer() {
}

// UnsafeTrainingStudentServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TrainingStudentServiceServer will
// result in compilation errors.
type UnsafeTrainingStudentServiceServer interface {
	mustEmbedUnimplementedTrainingStudentServiceServer()
}

func RegisterTrainingStudentServiceServer(s grpc.ServiceRegistrar, srv TrainingStudentServiceServer) {
	s.RegisterService(&TrainingStudentService_ServiceDesc, srv)
}

func _TrainingStudentService_CreateTrainingStudent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTrainingStudentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingStudentServiceServer).CreateTrainingStudent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TrainingStudentService/CreateTrainingStudent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingStudentServiceServer).CreateTrainingStudent(ctx, req.(*CreateTrainingStudentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrainingStudentService_DeleteTrainingStudent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTrainingStudentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingStudentServiceServer).DeleteTrainingStudent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TrainingStudentService/DeleteTrainingStudent",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingStudentServiceServer).DeleteTrainingStudent(ctx, req.(*DeleteTrainingStudentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TrainingStudentService_ServiceDesc is the grpc.ServiceDesc for TrainingStudentService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TrainingStudentService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "training.TrainingStudentService",
	HandlerType: (*TrainingStudentServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTrainingStudent",
			Handler:    _TrainingStudentService_CreateTrainingStudent_Handler,
		},
		{
			MethodName: "DeleteTrainingStudent",
			Handler:    _TrainingStudentService_DeleteTrainingStudent_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "training.proto",
}

// FavoriteUsersTrainingsServiceClient is the client API for FavoriteUsersTrainingsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FavoriteUsersTrainingsServiceClient interface {
	CreateFavoriteUserTraining(ctx context.Context, in *CreateFavoriteUserTrainingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeleteFavoriteUserTraining(ctx context.Context, in *DeleteFavoriteUserTrainingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type favoriteUsersTrainingsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewFavoriteUsersTrainingsServiceClient(cc grpc.ClientConnInterface) FavoriteUsersTrainingsServiceClient {
	return &favoriteUsersTrainingsServiceClient{cc}
}

func (c *favoriteUsersTrainingsServiceClient) CreateFavoriteUserTraining(ctx context.Context, in *CreateFavoriteUserTrainingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/training.FavoriteUsersTrainingsService/CreateFavoriteUserTraining", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *favoriteUsersTrainingsServiceClient) DeleteFavoriteUserTraining(ctx context.Context, in *DeleteFavoriteUserTrainingRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/training.FavoriteUsersTrainingsService/DeleteFavoriteUserTraining", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FavoriteUsersTrainingsServiceServer is the server API for FavoriteUsersTrainingsService service.
// All implementations must embed UnimplementedFavoriteUsersTrainingsServiceServer
// for forward compatibility
type FavoriteUsersTrainingsServiceServer interface {
	CreateFavoriteUserTraining(context.Context, *CreateFavoriteUserTrainingRequest) (*emptypb.Empty, error)
	DeleteFavoriteUserTraining(context.Context, *DeleteFavoriteUserTrainingRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedFavoriteUsersTrainingsServiceServer()
}

// UnimplementedFavoriteUsersTrainingsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedFavoriteUsersTrainingsServiceServer struct {
}

func (UnimplementedFavoriteUsersTrainingsServiceServer) CreateFavoriteUserTraining(context.Context, *CreateFavoriteUserTrainingRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateFavoriteUserTraining not implemented")
}
func (UnimplementedFavoriteUsersTrainingsServiceServer) DeleteFavoriteUserTraining(context.Context, *DeleteFavoriteUserTrainingRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFavoriteUserTraining not implemented")
}
func (UnimplementedFavoriteUsersTrainingsServiceServer) mustEmbedUnimplementedFavoriteUsersTrainingsServiceServer() {
}

// UnsafeFavoriteUsersTrainingsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FavoriteUsersTrainingsServiceServer will
// result in compilation errors.
type UnsafeFavoriteUsersTrainingsServiceServer interface {
	mustEmbedUnimplementedFavoriteUsersTrainingsServiceServer()
}

func RegisterFavoriteUsersTrainingsServiceServer(s grpc.ServiceRegistrar, srv FavoriteUsersTrainingsServiceServer) {
	s.RegisterService(&FavoriteUsersTrainingsService_ServiceDesc, srv)
}

func _FavoriteUsersTrainingsService_CreateFavoriteUserTraining_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateFavoriteUserTrainingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FavoriteUsersTrainingsServiceServer).CreateFavoriteUserTraining(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.FavoriteUsersTrainingsService/CreateFavoriteUserTraining",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FavoriteUsersTrainingsServiceServer).CreateFavoriteUserTraining(ctx, req.(*CreateFavoriteUserTrainingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FavoriteUsersTrainingsService_DeleteFavoriteUserTraining_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFavoriteUserTrainingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FavoriteUsersTrainingsServiceServer).DeleteFavoriteUserTraining(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.FavoriteUsersTrainingsService/DeleteFavoriteUserTraining",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FavoriteUsersTrainingsServiceServer).DeleteFavoriteUserTraining(ctx, req.(*DeleteFavoriteUserTrainingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FavoriteUsersTrainingsService_ServiceDesc is the grpc.ServiceDesc for FavoriteUsersTrainingsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FavoriteUsersTrainingsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "training.FavoriteUsersTrainingsService",
	HandlerType: (*FavoriteUsersTrainingsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateFavoriteUserTraining",
			Handler:    _FavoriteUsersTrainingsService_CreateFavoriteUserTraining_Handler,
		},
		{
			MethodName: "DeleteFavoriteUserTraining",
			Handler:    _FavoriteUsersTrainingsService_DeleteFavoriteUserTraining_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "training.proto",
}

// PracticeMaterialServiceClient is the client API for PracticeMaterialService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PracticeMaterialServiceClient interface {
	CreatePracticeMaterial(ctx context.Context, in *CreatePracticeMaterialRequest, opts ...grpc.CallOption) (*PracticeMaterial, error)
	UpdatePracticeMaterial(ctx context.Context, in *UpdatePracticeMaterialRequest, opts ...grpc.CallOption) (*PracticeMaterial, error)
	DeletePracticeMaterial(ctx context.Context, in *DeletePracticeMaterialRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type practiceMaterialServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPracticeMaterialServiceClient(cc grpc.ClientConnInterface) PracticeMaterialServiceClient {
	return &practiceMaterialServiceClient{cc}
}

func (c *practiceMaterialServiceClient) CreatePracticeMaterial(ctx context.Context, in *CreatePracticeMaterialRequest, opts ...grpc.CallOption) (*PracticeMaterial, error) {
	out := new(PracticeMaterial)
	err := c.cc.Invoke(ctx, "/training.PracticeMaterialService/CreatePracticeMaterial", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *practiceMaterialServiceClient) UpdatePracticeMaterial(ctx context.Context, in *UpdatePracticeMaterialRequest, opts ...grpc.CallOption) (*PracticeMaterial, error) {
	out := new(PracticeMaterial)
	err := c.cc.Invoke(ctx, "/training.PracticeMaterialService/UpdatePracticeMaterial", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *practiceMaterialServiceClient) DeletePracticeMaterial(ctx context.Context, in *DeletePracticeMaterialRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/training.PracticeMaterialService/DeletePracticeMaterial", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PracticeMaterialServiceServer is the server API for PracticeMaterialService service.
// All implementations must embed UnimplementedPracticeMaterialServiceServer
// for forward compatibility
type PracticeMaterialServiceServer interface {
	CreatePracticeMaterial(context.Context, *CreatePracticeMaterialRequest) (*PracticeMaterial, error)
	UpdatePracticeMaterial(context.Context, *UpdatePracticeMaterialRequest) (*PracticeMaterial, error)
	DeletePracticeMaterial(context.Context, *DeletePracticeMaterialRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedPracticeMaterialServiceServer()
}

// UnimplementedPracticeMaterialServiceServer must be embedded to have forward compatible implementations.
type UnimplementedPracticeMaterialServiceServer struct {
}

func (UnimplementedPracticeMaterialServiceServer) CreatePracticeMaterial(context.Context, *CreatePracticeMaterialRequest) (*PracticeMaterial, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreatePracticeMaterial not implemented")
}
func (UnimplementedPracticeMaterialServiceServer) UpdatePracticeMaterial(context.Context, *UpdatePracticeMaterialRequest) (*PracticeMaterial, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePracticeMaterial not implemented")
}
func (UnimplementedPracticeMaterialServiceServer) DeletePracticeMaterial(context.Context, *DeletePracticeMaterialRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePracticeMaterial not implemented")
}
func (UnimplementedPracticeMaterialServiceServer) mustEmbedUnimplementedPracticeMaterialServiceServer() {
}

// UnsafePracticeMaterialServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PracticeMaterialServiceServer will
// result in compilation errors.
type UnsafePracticeMaterialServiceServer interface {
	mustEmbedUnimplementedPracticeMaterialServiceServer()
}

func RegisterPracticeMaterialServiceServer(s grpc.ServiceRegistrar, srv PracticeMaterialServiceServer) {
	s.RegisterService(&PracticeMaterialService_ServiceDesc, srv)
}

func _PracticeMaterialService_CreatePracticeMaterial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreatePracticeMaterialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PracticeMaterialServiceServer).CreatePracticeMaterial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.PracticeMaterialService/CreatePracticeMaterial",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PracticeMaterialServiceServer).CreatePracticeMaterial(ctx, req.(*CreatePracticeMaterialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PracticeMaterialService_UpdatePracticeMaterial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePracticeMaterialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PracticeMaterialServiceServer).UpdatePracticeMaterial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.PracticeMaterialService/UpdatePracticeMaterial",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PracticeMaterialServiceServer).UpdatePracticeMaterial(ctx, req.(*UpdatePracticeMaterialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PracticeMaterialService_DeletePracticeMaterial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePracticeMaterialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PracticeMaterialServiceServer).DeletePracticeMaterial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.PracticeMaterialService/DeletePracticeMaterial",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PracticeMaterialServiceServer).DeletePracticeMaterial(ctx, req.(*DeletePracticeMaterialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PracticeMaterialService_ServiceDesc is the grpc.ServiceDesc for PracticeMaterialService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PracticeMaterialService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "training.PracticeMaterialService",
	HandlerType: (*PracticeMaterialServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreatePracticeMaterial",
			Handler:    _PracticeMaterialService_CreatePracticeMaterial_Handler,
		},
		{
			MethodName: "UpdatePracticeMaterial",
			Handler:    _PracticeMaterialService_UpdatePracticeMaterial_Handler,
		},
		{
			MethodName: "DeletePracticeMaterial",
			Handler:    _PracticeMaterialService_DeletePracticeMaterial_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "training.proto",
}

// TheoryMaterialServiceClient is the client API for TheoryMaterialService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TheoryMaterialServiceClient interface {
	CreateTheoryMaterial(ctx context.Context, in *CreateTheoryMaterialRequest, opts ...grpc.CallOption) (*TheoryMaterial, error)
	UpdateTheoryMaterial(ctx context.Context, in *UpdateTheoryMaterialRequest, opts ...grpc.CallOption) (*TheoryMaterial, error)
	DeleteTheoryMaterial(ctx context.Context, in *DeleteTheoryMaterialRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type theoryMaterialServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTheoryMaterialServiceClient(cc grpc.ClientConnInterface) TheoryMaterialServiceClient {
	return &theoryMaterialServiceClient{cc}
}

func (c *theoryMaterialServiceClient) CreateTheoryMaterial(ctx context.Context, in *CreateTheoryMaterialRequest, opts ...grpc.CallOption) (*TheoryMaterial, error) {
	out := new(TheoryMaterial)
	err := c.cc.Invoke(ctx, "/training.TheoryMaterialService/CreateTheoryMaterial", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *theoryMaterialServiceClient) UpdateTheoryMaterial(ctx context.Context, in *UpdateTheoryMaterialRequest, opts ...grpc.CallOption) (*TheoryMaterial, error) {
	out := new(TheoryMaterial)
	err := c.cc.Invoke(ctx, "/training.TheoryMaterialService/UpdateTheoryMaterial", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *theoryMaterialServiceClient) DeleteTheoryMaterial(ctx context.Context, in *DeleteTheoryMaterialRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/training.TheoryMaterialService/DeleteTheoryMaterial", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TheoryMaterialServiceServer is the server API for TheoryMaterialService service.
// All implementations must embed UnimplementedTheoryMaterialServiceServer
// for forward compatibility
type TheoryMaterialServiceServer interface {
	CreateTheoryMaterial(context.Context, *CreateTheoryMaterialRequest) (*TheoryMaterial, error)
	UpdateTheoryMaterial(context.Context, *UpdateTheoryMaterialRequest) (*TheoryMaterial, error)
	DeleteTheoryMaterial(context.Context, *DeleteTheoryMaterialRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedTheoryMaterialServiceServer()
}

// UnimplementedTheoryMaterialServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTheoryMaterialServiceServer struct {
}

func (UnimplementedTheoryMaterialServiceServer) CreateTheoryMaterial(context.Context, *CreateTheoryMaterialRequest) (*TheoryMaterial, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTheoryMaterial not implemented")
}
func (UnimplementedTheoryMaterialServiceServer) UpdateTheoryMaterial(context.Context, *UpdateTheoryMaterialRequest) (*TheoryMaterial, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTheoryMaterial not implemented")
}
func (UnimplementedTheoryMaterialServiceServer) DeleteTheoryMaterial(context.Context, *DeleteTheoryMaterialRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTheoryMaterial not implemented")
}
func (UnimplementedTheoryMaterialServiceServer) mustEmbedUnimplementedTheoryMaterialServiceServer() {}

// UnsafeTheoryMaterialServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TheoryMaterialServiceServer will
// result in compilation errors.
type UnsafeTheoryMaterialServiceServer interface {
	mustEmbedUnimplementedTheoryMaterialServiceServer()
}

func RegisterTheoryMaterialServiceServer(s grpc.ServiceRegistrar, srv TheoryMaterialServiceServer) {
	s.RegisterService(&TheoryMaterialService_ServiceDesc, srv)
}

func _TheoryMaterialService_CreateTheoryMaterial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTheoryMaterialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TheoryMaterialServiceServer).CreateTheoryMaterial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TheoryMaterialService/CreateTheoryMaterial",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TheoryMaterialServiceServer).CreateTheoryMaterial(ctx, req.(*CreateTheoryMaterialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TheoryMaterialService_UpdateTheoryMaterial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTheoryMaterialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TheoryMaterialServiceServer).UpdateTheoryMaterial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TheoryMaterialService/UpdateTheoryMaterial",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TheoryMaterialServiceServer).UpdateTheoryMaterial(ctx, req.(*UpdateTheoryMaterialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TheoryMaterialService_DeleteTheoryMaterial_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTheoryMaterialRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TheoryMaterialServiceServer).DeleteTheoryMaterial(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TheoryMaterialService/DeleteTheoryMaterial",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TheoryMaterialServiceServer).DeleteTheoryMaterial(ctx, req.(*DeleteTheoryMaterialRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TheoryMaterialService_ServiceDesc is the grpc.ServiceDesc for TheoryMaterialService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TheoryMaterialService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "training.TheoryMaterialService",
	HandlerType: (*TheoryMaterialServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateTheoryMaterial",
			Handler:    _TheoryMaterialService_CreateTheoryMaterial_Handler,
		},
		{
			MethodName: "UpdateTheoryMaterial",
			Handler:    _TheoryMaterialService_UpdateTheoryMaterial_Handler,
		},
		{
			MethodName: "DeleteTheoryMaterial",
			Handler:    _TheoryMaterialService_DeleteTheoryMaterial_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "training.proto",
}

// TopicsServiceClient is the client API for TopicsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TopicsServiceClient interface {
	GetTopicById(ctx context.Context, in *GetTopicByIdRequest, opts ...grpc.CallOption) (*Topic, error)
	CreateTopic(ctx context.Context, in *CreateTopicRequest, opts ...grpc.CallOption) (*TopicPreview, error)
	UpdateTopic(ctx context.Context, in *UpdateTopicRequest, opts ...grpc.CallOption) (*TopicPreview, error)
	DeleteTopic(ctx context.Context, in *DeleteTopicRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type topicsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTopicsServiceClient(cc grpc.ClientConnInterface) TopicsServiceClient {
	return &topicsServiceClient{cc}
}

func (c *topicsServiceClient) GetTopicById(ctx context.Context, in *GetTopicByIdRequest, opts ...grpc.CallOption) (*Topic, error) {
	out := new(Topic)
	err := c.cc.Invoke(ctx, "/training.TopicsService/GetTopicById", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicsServiceClient) CreateTopic(ctx context.Context, in *CreateTopicRequest, opts ...grpc.CallOption) (*TopicPreview, error) {
	out := new(TopicPreview)
	err := c.cc.Invoke(ctx, "/training.TopicsService/CreateTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicsServiceClient) UpdateTopic(ctx context.Context, in *UpdateTopicRequest, opts ...grpc.CallOption) (*TopicPreview, error) {
	out := new(TopicPreview)
	err := c.cc.Invoke(ctx, "/training.TopicsService/UpdateTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *topicsServiceClient) DeleteTopic(ctx context.Context, in *DeleteTopicRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/training.TopicsService/DeleteTopic", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TopicsServiceServer is the server API for TopicsService service.
// All implementations must embed UnimplementedTopicsServiceServer
// for forward compatibility
type TopicsServiceServer interface {
	GetTopicById(context.Context, *GetTopicByIdRequest) (*Topic, error)
	CreateTopic(context.Context, *CreateTopicRequest) (*TopicPreview, error)
	UpdateTopic(context.Context, *UpdateTopicRequest) (*TopicPreview, error)
	DeleteTopic(context.Context, *DeleteTopicRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedTopicsServiceServer()
}

// UnimplementedTopicsServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTopicsServiceServer struct {
}

func (UnimplementedTopicsServiceServer) GetTopicById(context.Context, *GetTopicByIdRequest) (*Topic, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTopicById not implemented")
}
func (UnimplementedTopicsServiceServer) CreateTopic(context.Context, *CreateTopicRequest) (*TopicPreview, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateTopic not implemented")
}
func (UnimplementedTopicsServiceServer) UpdateTopic(context.Context, *UpdateTopicRequest) (*TopicPreview, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateTopic not implemented")
}
func (UnimplementedTopicsServiceServer) DeleteTopic(context.Context, *DeleteTopicRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteTopic not implemented")
}
func (UnimplementedTopicsServiceServer) mustEmbedUnimplementedTopicsServiceServer() {}

// UnsafeTopicsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TopicsServiceServer will
// result in compilation errors.
type UnsafeTopicsServiceServer interface {
	mustEmbedUnimplementedTopicsServiceServer()
}

func RegisterTopicsServiceServer(s grpc.ServiceRegistrar, srv TopicsServiceServer) {
	s.RegisterService(&TopicsService_ServiceDesc, srv)
}

func _TopicsService_GetTopicById_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTopicByIdRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicsServiceServer).GetTopicById(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TopicsService/GetTopicById",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicsServiceServer).GetTopicById(ctx, req.(*GetTopicByIdRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopicsService_CreateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicsServiceServer).CreateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TopicsService/CreateTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicsServiceServer).CreateTopic(ctx, req.(*CreateTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopicsService_UpdateTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicsServiceServer).UpdateTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TopicsService/UpdateTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicsServiceServer).UpdateTopic(ctx, req.(*UpdateTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TopicsService_DeleteTopic_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTopicRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TopicsServiceServer).DeleteTopic(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TopicsService/DeleteTopic",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TopicsServiceServer).DeleteTopic(ctx, req.(*DeleteTopicRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TopicsService_ServiceDesc is the grpc.ServiceDesc for TopicsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TopicsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "training.TopicsService",
	HandlerType: (*TopicsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetTopicById",
			Handler:    _TopicsService_GetTopicById_Handler,
		},
		{
			MethodName: "CreateTopic",
			Handler:    _TopicsService_CreateTopic_Handler,
		},
		{
			MethodName: "UpdateTopic",
			Handler:    _TopicsService_UpdateTopic_Handler,
		},
		{
			MethodName: "DeleteTopic",
			Handler:    _TopicsService_DeleteTopic_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "training.proto",
}

// DevClient is the client API for Dev service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DevClient interface {
	ResetDB(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type devClient struct {
	cc grpc.ClientConnInterface
}

func NewDevClient(cc grpc.ClientConnInterface) DevClient {
	return &devClient{cc}
}

func (c *devClient) ResetDB(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/training.Dev/ResetDB", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DevServer is the server API for Dev service.
// All implementations must embed UnimplementedDevServer
// for forward compatibility
type DevServer interface {
	ResetDB(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	mustEmbedUnimplementedDevServer()
}

// UnimplementedDevServer must be embedded to have forward compatible implementations.
type UnimplementedDevServer struct {
}

func (UnimplementedDevServer) ResetDB(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetDB not implemented")
}
func (UnimplementedDevServer) mustEmbedUnimplementedDevServer() {}

// UnsafeDevServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DevServer will
// result in compilation errors.
type UnsafeDevServer interface {
	mustEmbedUnimplementedDevServer()
}

func RegisterDevServer(s grpc.ServiceRegistrar, srv DevServer) {
	s.RegisterService(&Dev_ServiceDesc, srv)
}

func _Dev_ResetDB_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DevServer).ResetDB(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.Dev/ResetDB",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DevServer).ResetDB(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

// Dev_ServiceDesc is the grpc.ServiceDesc for Dev service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Dev_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "training.Dev",
	HandlerType: (*DevServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ResetDB",
			Handler:    _Dev_ResetDB_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "training.proto",
}

// TrainingMessageToAIServiceClient is the client API for TrainingMessageToAIService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TrainingMessageToAIServiceClient interface {
	GetMessageToAI(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*MessageToAI, error)
	HandleResponseFromAiForItem(ctx context.Context, in *MessageFromAI, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type trainingMessageToAIServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewTrainingMessageToAIServiceClient(cc grpc.ClientConnInterface) TrainingMessageToAIServiceClient {
	return &trainingMessageToAIServiceClient{cc}
}

func (c *trainingMessageToAIServiceClient) GetMessageToAI(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*MessageToAI, error) {
	out := new(MessageToAI)
	err := c.cc.Invoke(ctx, "/training.TrainingMessageToAIService/GetMessageToAI", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *trainingMessageToAIServiceClient) HandleResponseFromAiForItem(ctx context.Context, in *MessageFromAI, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/training.TrainingMessageToAIService/HandleResponseFromAiForItem", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TrainingMessageToAIServiceServer is the server API for TrainingMessageToAIService service.
// All implementations must embed UnimplementedTrainingMessageToAIServiceServer
// for forward compatibility
type TrainingMessageToAIServiceServer interface {
	GetMessageToAI(context.Context, *emptypb.Empty) (*MessageToAI, error)
	HandleResponseFromAiForItem(context.Context, *MessageFromAI) (*emptypb.Empty, error)
	mustEmbedUnimplementedTrainingMessageToAIServiceServer()
}

// UnimplementedTrainingMessageToAIServiceServer must be embedded to have forward compatible implementations.
type UnimplementedTrainingMessageToAIServiceServer struct {
}

func (UnimplementedTrainingMessageToAIServiceServer) GetMessageToAI(context.Context, *emptypb.Empty) (*MessageToAI, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMessageToAI not implemented")
}
func (UnimplementedTrainingMessageToAIServiceServer) HandleResponseFromAiForItem(context.Context, *MessageFromAI) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HandleResponseFromAiForItem not implemented")
}
func (UnimplementedTrainingMessageToAIServiceServer) mustEmbedUnimplementedTrainingMessageToAIServiceServer() {
}

// UnsafeTrainingMessageToAIServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TrainingMessageToAIServiceServer will
// result in compilation errors.
type UnsafeTrainingMessageToAIServiceServer interface {
	mustEmbedUnimplementedTrainingMessageToAIServiceServer()
}

func RegisterTrainingMessageToAIServiceServer(s grpc.ServiceRegistrar, srv TrainingMessageToAIServiceServer) {
	s.RegisterService(&TrainingMessageToAIService_ServiceDesc, srv)
}

func _TrainingMessageToAIService_GetMessageToAI_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingMessageToAIServiceServer).GetMessageToAI(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TrainingMessageToAIService/GetMessageToAI",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingMessageToAIServiceServer).GetMessageToAI(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TrainingMessageToAIService_HandleResponseFromAiForItem_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MessageFromAI)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TrainingMessageToAIServiceServer).HandleResponseFromAiForItem(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/training.TrainingMessageToAIService/HandleResponseFromAiForItem",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TrainingMessageToAIServiceServer).HandleResponseFromAiForItem(ctx, req.(*MessageFromAI))
	}
	return interceptor(ctx, in, info, handler)
}

// TrainingMessageToAIService_ServiceDesc is the grpc.ServiceDesc for TrainingMessageToAIService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TrainingMessageToAIService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "training.TrainingMessageToAIService",
	HandlerType: (*TrainingMessageToAIServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetMessageToAI",
			Handler:    _TrainingMessageToAIService_GetMessageToAI_Handler,
		},
		{
			MethodName: "HandleResponseFromAiForItem",
			Handler:    _TrainingMessageToAIService_HandleResponseFromAiForItem_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "training.proto",
}
