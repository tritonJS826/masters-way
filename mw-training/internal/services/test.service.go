package services

import (
	"context"
	db "mw-training/internal/db/sqlc"
	pb "mw-training/pkg/grpcAutogenerated/training"
	"mw-training/pkg/utils"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/samber/lo"
)

type TestRepository interface {
	// CreateTopicInTraining(ctx context.Context, params db.CreateTopicInTrainingParams) (db.Topic, error)
	// UpdateTopic(ctx context.Context, params db.UpdateTopicParams) (db.Topic, error)
	// DeleteTopic(ctx context.Context, topicUuid pgtype.UUID) (db.Topic, error)
	// GetTopicByUuid(ctx context.Context, topicUuid pgtype.UUID) (db.GetTopicByUuidRow, error)
	// GetPracticeMaterialsByTopicId(ctx context.Context, topicUuid pgtype.UUID) ([]db.PracticeMaterial, error)
	// GetTheoryMaterialsByTopicId(ctx context.Context, topicUuid pgtype.UUID) ([]db.TheoryMaterial, error)
	GetPublicTests(ctx context.Context, params db.GetPublicTestsParams) ([]db.GetPublicTestsRow, error)
	CountPublicTests(ctx context.Context, testName string) (int64, error)
	GetTestsAmountByUserId(ctx context.Context, userUuid pgtype.UUID) (db.GetTestsAmountByUserIdRow, error)
	GetTestsByOwnerId(ctx context.Context, params db.GetTestsByOwnerIdParams) ([]db.GetTestsByOwnerIdRow, error)
	GetTestById(ctx context.Context, testUuid pgtype.UUID) (db.GetTestByIdRow, error)
	CreateTest(ctx context.Context, params db.CreateTestParams) (db.Test, error)
	UpdateTest(ctx context.Context, params db.UpdateTestParams) (db.Test, error)
	DeleteTest(ctx context.Context, testUuid pgtype.UUID) error
	WithTx(tx pgx.Tx) *db.Queries
}

type TestService struct {
	testRepository     TestRepository
	questionRepository QuestionRepository
	pgxPool            *pgxpool.Pool
}

func NewTestService(
	pgxPool *pgxpool.Pool,
	testRepository TestRepository,
	questionRepository QuestionRepository,
) *TestService {
	return &TestService{
		pgxPool:            pgxPool,
		testRepository:     testRepository,
		questionRepository: questionRepository,
	}
}

func (ts *TestService) GetTestList(ctx context.Context, params *db.GetPublicTestsParams) (*pb.TestPreviewList, error) {
	testsAmount, err := ts.testRepository.CountPublicTests(ctx, params.TestName)
	if err != nil {
		return &pb.TestPreviewList{}, err
	}
	if testsAmount == 0 {
		return &pb.TestPreviewList{
			Size:      0,
			TestsList: make([]*pb.TestPreview, 0),
		}, nil
	}

	testPreviewListDb, err := ts.testRepository.GetPublicTests(ctx, *params)
	if err != nil {
		return &pb.TestPreviewList{}, err
	}

	testPreviewList := lo.Map(testPreviewListDb, func(test db.GetPublicTestsRow, _ int) *pb.TestPreview {
		return &pb.TestPreview{
			Uuid:        *utils.MarshalPgUUID(test.Uuid),
			Name:        test.Name,
			Description: test.Description,
			CreatedAt:   test.CreatedAt.Time.String(),
			OwnerUuid:   *utils.MarshalPgUUID(test.OwnerUuid),
			UpdatedAt:   test.UpdatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
		}
	})

	return &pb.TestPreviewList{
		Size:      int32(testsAmount),
		TestsList: testPreviewList,
	}, nil
}

func (ts *TestService) GetTestsAmountByUserId(ctx context.Context, userUuid pgtype.UUID) (*pb.GetTestAmountByUserIdResponse, error) {
	testsAmountByUserId, err := ts.testRepository.GetTestsAmountByUserId(ctx, userUuid)
	if err != nil {
		return &pb.GetTestAmountByUserIdResponse{}, err
	}

	return &pb.GetTestAmountByUserIdResponse{
		Own:       int32(testsAmountByUserId.Owner),
		Completed: int32(testsAmountByUserId.Completed),
	}, nil
}

func (ts *TestService) GetTestsByUserId(ctx context.Context, params *db.GetTestsByOwnerIdParams) (*pb.TestPreviewList, error) {
	testsDb, err := ts.testRepository.GetTestsByOwnerId(ctx, *params)
	if err != nil {
		return &pb.TestPreviewList{}, err
	}

	testPreviewList := lo.Map(testsDb, func(test db.GetTestsByOwnerIdRow, _ int) *pb.TestPreview {
		return &pb.TestPreview{
			Uuid:        *utils.MarshalPgUUID(test.Uuid),
			Name:        test.Name,
			Description: test.Description,
			CreatedAt:   test.CreatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
			OwnerUuid:   *utils.MarshalPgUUID(test.OwnerUuid),
			UpdatedAt:   test.UpdatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
		}
	})

	return &pb.TestPreviewList{
		Size:      int32(len(testPreviewList)),
		TestsList: testPreviewList,
	}, nil
}

type GetTestByIdParams struct {
	TestUuid pgtype.UUID
	UserUuid pgtype.UUID
}

func (ts *TestService) GetTestById(ctx context.Context, params *GetTestByIdParams) (*pb.Test, error) {
	testDb, err := ts.testRepository.GetTestById(ctx, params.TestUuid)
	if err != nil {
		return &pb.Test{}, err
	}

	isIncludePrivate := params.UserUuid == testDb.OwnerUuid

	questionsDb, err := ts.questionRepository.GetQuestionsByTestId(ctx, db.GetQuestionsByTestIdParams{
		TestUuid:        testDb.Uuid,
		IncludeInactive: true,
		IncludePrivate:  isIncludePrivate,
	})
	if err != nil {
		return &pb.Test{}, err
	}

	questionList := lo.Map(questionsDb, func(question db.Question, _ int) *pb.Question {
		return &pb.Question{
			Uuid:         *utils.MarshalPgUUID(question.Uuid),
			Name:         question.Name.String,
			TestUuid:     *utils.MarshalPgUUID(question.TestUuid),
			QuestionText: question.QuestionText,
			Order:        question.QuestionOrder,
			TimeToAnswer: question.TimeToAnswer,
			Answer:       question.Answer,
			IsActive:     question.IsActive,
			CreatedAt:    question.CreatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
			UpdatedAt:    question.UpdatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
		}
	})

	test := &pb.Test{
		Uuid:        *utils.MarshalPgUUID(testDb.Uuid),
		Name:        testDb.Name,
		Description: testDb.Description,
		OwnerUuid:   *utils.MarshalPgUUID(testDb.OwnerUuid),
		UpdatedAt:   testDb.UpdatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
		CreatedAt:   testDb.CreatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
		Questions:   questionList,
	}

	return test, nil
}

func (ts *TestService) CreateTest(ctx context.Context, params *db.CreateTestParams) (*pb.Test, error) {
	testDb, err := ts.testRepository.CreateTest(ctx, *params)
	if err != nil {
		return &pb.Test{}, err
	}

	questions := make([]*pb.Question, 0)

	test := &pb.Test{
		Uuid:        *utils.MarshalPgUUID(testDb.Uuid),
		Name:        testDb.Name,
		Description: testDb.Description,
		OwnerUuid:   *utils.MarshalPgUUID(testDb.OwnerUuid),
		UpdatedAt:   testDb.UpdatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
		CreatedAt:   testDb.CreatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
		Questions:   questions,
	}

	return test, nil
}

func (ts *TestService) UpdateTest(ctx context.Context, params *db.UpdateTestParams, userUuid pgtype.UUID) (*pb.Test, error) {
	testDb, err := ts.testRepository.UpdateTest(ctx, *params)
	if err != nil {
		return &pb.Test{}, err
	}

	isIncludePrivate := userUuid == testDb.OwnerUuid

	questionsDb, err := ts.questionRepository.GetQuestionsByTestId(ctx, db.GetQuestionsByTestIdParams{
		TestUuid:        testDb.Uuid,
		IncludeInactive: true,
		IncludePrivate:  isIncludePrivate,
	})
	if err != nil {
		return &pb.Test{}, err
	}

	questionList := lo.Map(questionsDb, func(question db.Question, _ int) *pb.Question {
		return &pb.Question{
			Uuid:         *utils.MarshalPgUUID(question.Uuid),
			Name:         question.Name.String,
			TestUuid:     *utils.MarshalPgUUID(question.TestUuid),
			QuestionText: question.QuestionText,
			Order:        question.QuestionOrder,
			TimeToAnswer: question.TimeToAnswer,
			Answer:       question.Answer,
			IsActive:     question.IsActive,
			CreatedAt:    question.CreatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
			UpdatedAt:    question.UpdatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
		}
	})

	test := &pb.Test{
		Uuid:        *utils.MarshalPgUUID(testDb.Uuid),
		Name:        testDb.Name,
		Description: testDb.Description,
		OwnerUuid:   *utils.MarshalPgUUID(testDb.OwnerUuid),
		UpdatedAt:   testDb.UpdatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
		CreatedAt:   testDb.CreatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
		Questions:   questionList,
	}

	return test, nil
}

func (ts *TestService) DeleteTest(ctx context.Context, testUuid pgtype.UUID) error {
	err := ts.testRepository.DeleteTest(ctx, testUuid)
	if err != nil {
		return err
	}

	return nil
}
