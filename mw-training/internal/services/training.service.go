package services

import (
	"context"
	db "mw-training/internal/db/sqlc"
	pb "mw-training/pkg/grpcAutogenerated/training"
	"mw-training/pkg/utils"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/samber/lo"
)

type TrainingRepository interface {
	CreateTraining(ctx context.Context, params db.CreateTrainingParams) (db.Training, error)
	UpdateTraining(ctx context.Context, params db.UpdateTrainingParams) (db.Training, error)
	GetTrainingById(ctx context.Context, trainingUuid pgtype.UUID) (db.Training, error)
	GetOwnTrainingList(ctx context.Context, userUuid pgtype.UUID) ([]db.Training, error)
	GetTrainingList(ctx context.Context, params db.GetTrainingListParams) ([]db.GetTrainingListRow, error)
	DeleteTraining(ctx context.Context, trainingUuid pgtype.UUID) error
	WithTx(tx pgx.Tx) *db.Queries
}

type TrainingService struct {
	trainingRepository TrainingRepository
	pgxPool            *pgxpool.Pool
}

func NewTrainingService(pgxPool *pgxpool.Pool, trainingRepository TrainingRepository) *TrainingService {
	return &TrainingService{
		pgxPool:            pgxPool,
		trainingRepository: trainingRepository,
	}
}

// TrainingName
// RequestOffset
// RequestLimit

type GetTrainingListParams struct {
	TrainingName  string
	RequestOffset int32
	RequestLimit  int32
}

func (ts *TrainingService) GetTrainingList(ctx context.Context, params *GetTrainingListParams) ([]*pb.Training, error) {
	args := db.GetTrainingListParams{
		TrainingName:  params.TrainingName,
		RequestOffset: params.RequestOffset,
		RequestLimit:  params.RequestLimit,
	}

	dbTrainings, err := ts.trainingRepository.GetTrainingList(ctx, args)
	if err != nil {
		return []*pb.Training{}, err
	}

	// TODO: add
	// FavoriteCount
	// Tags
	// TrainingMentors
	// TrainingStudents

	trainings := lo.Map(dbTrainings, func(training db.GetTrainingListRow, _ int) *pb.Training {
		return &pb.Training{
			Uuid:      *utils.MarshalPgUUID(training.Uuid),
			Name:      training.Name,
			IsPrivate: false,
			Owner: &pb.User{
				Uuid: *utils.MarshalPgUUID(training.OwnerUuid),
			},
			Description: training.Description,
			CreatedAt:   training.CreatedAt.Time.String(),
			UpdatedAt:   training.UpdatedAt.Time.String(),
		}
	})

	return trainings, nil
}

func (ts *TrainingService) GetTrainingById(ctx context.Context, trainingUuid pgtype.UUID) (pb.Training, error) {
	dbTraining, err := ts.trainingRepository.GetTrainingById(ctx, trainingUuid)
	if err != nil {
		return pb.Training{}, err
	}

	return pb.Training{
		Uuid: *utils.MarshalPgUUID(dbTraining.Uuid),
	}, nil
}

func (ts *TrainingService) CreateTraining(ctx context.Context, params db.CreateTrainingParams) (pb.Training, error) {
	dbTraining, err := ts.trainingRepository.CreateTraining(ctx, params)
	if err != nil {
		return pb.Training{}, err
	}

	return pb.Training{
		Uuid: *utils.MarshalPgUUID(dbTraining.Uuid),
	}, nil
}

func (ts *TrainingService) UpdateTraining(ctx context.Context, params db.UpdateTrainingParams) (pb.Training, error) {
	training, err := ts.trainingRepository.UpdateTraining(ctx, params)
	if err != nil {
		return pb.Training{}, err
	}
	return pb.Training{
		Uuid:        *utils.MarshalPgUUID(training.Uuid),
		Name:        training.Name,
		Description: training.Description,
		Owner: &pb.User{
			Uuid:     *utils.MarshalPgUUID(training.OwnerUuid),
			Name:     "Stub",
			ImageUrl: "Stub",
		},
		CreatedAt: training.CreatedAt.Time.String(),
		UpdatedAt: training.UpdatedAt.Time.String(),
		IsPrivate: training.IsPrivate,
	}, nil
}

func (ts *TrainingService) DeleteTraining(ctx context.Context, trainingUuid pgtype.UUID) error {
	return ts.trainingRepository.DeleteTraining(ctx, trainingUuid)
}
