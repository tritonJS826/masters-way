package services

import (
	"context"
	"log"
	db "mw-training/internal/db/sqlc"
	pb "mw-training/pkg/grpcAutogenerated/training"
	"mw-training/pkg/utils"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/samber/lo"
)

type TrainingRepository interface {
	CreateTraining(ctx context.Context, params db.CreateTrainingParams) (db.Training, error)
	UpdateTraining(ctx context.Context, params db.UpdateTrainingParams) (db.Training, error)
	GetTrainingById(ctx context.Context, trainingUuid pgtype.UUID) (db.GetTrainingByIdRow, error)
	GetOwnTrainingList(ctx context.Context, userUuid pgtype.UUID) ([]db.GetOwnTrainingListRow, error)
	GetMentoringTrainingList(ctx context.Context, userUuid pgtype.UUID) ([]db.GetMentoringTrainingListRow, error)
	GetStudentTrainingList(ctx context.Context, userUuid pgtype.UUID) ([]db.GetStudentTrainingListRow, error)
	GetFavoriteTrainingList(ctx context.Context, userUuid pgtype.UUID) ([]db.GetFavoriteTrainingListRow, error)
	GetTrainingList(ctx context.Context, params db.GetTrainingListParams) ([]db.GetTrainingListRow, error)
	GetTrainingsAmountByUserId(ctx context.Context, userUuid pgtype.UUID) (db.GetTrainingsAmountByUserIdRow, error)
	GetListTrainingTagsByTrainingId(ctx context.Context, trainingUuid pgtype.UUID) ([]db.TrainingTag, error)
	GetTopicsByTrainingId(ctx context.Context, trainingUuid pgtype.UUID) ([]db.GetTopicsByTrainingIdRow, error)
	CountTrainings(ctx context.Context, trainingName string) (int64, error)
	DeleteTraining(ctx context.Context, trainingUuid pgtype.UUID) error
	WithTx(tx pgx.Tx) *db.Queries
}

type TrainingService struct {
	trainingRepository TrainingRepository
	pgxPool            *pgxpool.Pool
}

func NewTrainingService(pgxPool *pgxpool.Pool, trainingRepository TrainingRepository) *TrainingService {
	return &TrainingService{
		pgxPool:            pgxPool,
		trainingRepository: trainingRepository,
	}
}

type GetTrainingListParams struct {
	TrainingName  string
	RequestOffset int32
	RequestLimit  int32
}

func (ts *TrainingService) GetTrainingList(ctx context.Context, params *GetTrainingListParams) (*pb.TrainingPreviewList, error) {
	trainingsSize, err := ts.trainingRepository.CountTrainings(ctx, params.TrainingName)
	if err != nil {
		return &pb.TrainingPreviewList{}, err
	}

	args := db.GetTrainingListParams{
		TrainingName:  params.TrainingName,
		RequestOffset: params.RequestOffset,
		RequestLimit:  params.RequestLimit,
	}

	dbTrainings, err := ts.trainingRepository.GetTrainingList(ctx, args)
	if err != nil {
		return &pb.TrainingPreviewList{}, err
	}

	trainings := lo.Map(dbTrainings, func(training db.GetTrainingListRow, _ int) *pb.TrainingPreview {
		trainingTags := lo.Map(training.Tags, func(tag string, _ int) *pb.TrainingTag {
			return &pb.TrainingTag{TagName: tag}
		})

		students := lo.Map(training.TrainingStudents, func(studentUuid pgtype.UUID, _ int) *pb.User {
			return &pb.User{
				Uuid: *utils.MarshalPgUUID(studentUuid),
			}
		})

		mentors := lo.Map(training.TrainingMentors, func(mentorUuid pgtype.UUID, _ int) *pb.User {
			return &pb.User{
				Uuid: *utils.MarshalPgUUID(mentorUuid),
			}
		})

		return &pb.TrainingPreview{
			Uuid:      *utils.MarshalPgUUID(training.Uuid),
			Name:      training.Name,
			IsPrivate: training.IsPrivate,
			Owner: &pb.User{
				Uuid: *utils.MarshalPgUUID(training.OwnerUuid),
			},
			Description:      training.Description,
			CreatedAt:        training.CreatedAt.Time.String(),
			UpdatedAt:        training.UpdatedAt.Time.String(),
			TrainingTagList:  trainingTags,
			TrainingStudents: students,
			TrainingMentors:  mentors,
			FavoriteCount:    int32(training.FavoriteCount),
		}
	})

	return &pb.TrainingPreviewList{
		Size:         int32(trainingsSize),
		TrainingList: trainings,
	}, nil
}

type TrainingType string

const (
	TrainingTypeStudent  TrainingType = "student"
	TrainingTypeMentor   TrainingType = "mentor"
	TrainingTypeOwner    TrainingType = "owner"
	TrainingTypeFavorite TrainingType = "favorite"
)

type GetTrainingListForUserParams struct {
	TrainingsType TrainingType
	UserUuid      pgtype.UUID
}

type WrongTrainingTypeError struct{}

func (m *WrongTrainingTypeError) Error() string {
	return "customError"
}

func (ts *TrainingService) GetTrainingListForUser(ctx context.Context, params *GetTrainingListForUserParams) (*pb.TrainingPreviewList, error) {
	var trainings []*pb.TrainingPreview

	switch params.TrainingsType {
	case TrainingTypeStudent:
		trainingsRaw, err := ts.trainingRepository.GetStudentTrainingList(ctx, *&params.UserUuid)
		if err != nil {
			return &pb.TrainingPreviewList{}, err
		}

		trainings = lo.Map(trainingsRaw, func(trainingRow db.GetStudentTrainingListRow, _ int) *pb.TrainingPreview {
			return &pb.TrainingPreview{
				Uuid:        *utils.MarshalPgUUID(trainingRow.Uuid),
				Name:        trainingRow.Name,
				Description: trainingRow.Description,
				Owner: &pb.User{
					Uuid: *utils.MarshalPgUUID(trainingRow.OwnerUuid),
				},
				CreatedAt:     trainingRow.CreatedAt.Time.String(),
				UpdatedAt:     trainingRow.UpdatedAt.Time.String(),
				FavoriteCount: int32(trainingRow.FavoriteCount),
				IsPrivate:     trainingRow.IsPrivate,
				TrainingTagList: lo.Map(trainingRow.Tags, func(tag string, _ int) *pb.TrainingTag {
					return &pb.TrainingTag{TagName: tag}
				}),
				TrainingStudents: lo.Map(trainingRow.TrainingStudents, func(studentUuid pgtype.UUID, _ int) *pb.User {
					return &pb.User{
						Uuid: *utils.MarshalPgUUID(studentUuid),
					}
				}),
				TrainingMentors: lo.Map(trainingRow.TrainingMentors, func(mentorUuid pgtype.UUID, _ int) *pb.User {
					return &pb.User{
						Uuid: *utils.MarshalPgUUID(mentorUuid),
					}
				}),
				TopicsAmount: int32(trainingRow.TopicsCount),
			}
		})
	case TrainingTypeMentor:
		trainingsRaw, err := ts.trainingRepository.GetMentoringTrainingList(ctx, *&params.UserUuid)
		if err != nil {
			return &pb.TrainingPreviewList{}, err
		}
		trainings = lo.Map(trainingsRaw, func(trainingRow db.GetMentoringTrainingListRow, _ int) *pb.TrainingPreview {
			return &pb.TrainingPreview{
				Uuid:        *utils.MarshalPgUUID(trainingRow.Uuid),
				Name:        trainingRow.Name,
				Description: trainingRow.Description,
				Owner: &pb.User{
					Uuid: *utils.MarshalPgUUID(trainingRow.OwnerUuid),
				},
				CreatedAt:     trainingRow.CreatedAt.Time.String(),
				UpdatedAt:     trainingRow.UpdatedAt.Time.String(),
				FavoriteCount: int32(trainingRow.FavoriteCount),
				IsPrivate:     trainingRow.IsPrivate,
				TrainingTagList: lo.Map(trainingRow.Tags, func(tag string, _ int) *pb.TrainingTag {
					return &pb.TrainingTag{TagName: tag}
				}),
				TrainingStudents: lo.Map(trainingRow.TrainingStudents, func(studentUuid pgtype.UUID, _ int) *pb.User {
					return &pb.User{
						Uuid: *utils.MarshalPgUUID(studentUuid),
					}
				}),
				TrainingMentors: lo.Map(trainingRow.TrainingMentors, func(mentorUuid pgtype.UUID, _ int) *pb.User {
					return &pb.User{
						Uuid: *utils.MarshalPgUUID(mentorUuid),
					}
				}),
				TopicsAmount: int32(trainingRow.TopicsCount),
			}
		})
	case TrainingTypeOwner:
		trainingsRaw, err := ts.trainingRepository.GetOwnTrainingList(ctx, *&params.UserUuid)
		if err != nil {
			return &pb.TrainingPreviewList{}, err
		}

		trainings = lo.Map(trainingsRaw, func(trainingRow db.GetOwnTrainingListRow, _ int) *pb.TrainingPreview {
			return &pb.TrainingPreview{
				Uuid:        *utils.MarshalPgUUID(trainingRow.Uuid),
				Name:        trainingRow.Name,
				Description: trainingRow.Description,
				Owner: &pb.User{
					Uuid: *utils.MarshalPgUUID(trainingRow.OwnerUuid),
				},
				CreatedAt:     trainingRow.CreatedAt.Time.String(),
				UpdatedAt:     trainingRow.UpdatedAt.Time.String(),
				FavoriteCount: int32(trainingRow.FavoriteCount),
				IsPrivate:     trainingRow.IsPrivate,
				TrainingTagList: lo.Map(trainingRow.Tags, func(tag string, _ int) *pb.TrainingTag {
					return &pb.TrainingTag{TagName: tag}
				}),
				TrainingStudents: lo.Map(trainingRow.TrainingStudents, func(studentUuid pgtype.UUID, _ int) *pb.User {
					return &pb.User{
						Uuid: *utils.MarshalPgUUID(studentUuid),
					}
				}),
				TrainingMentors: lo.Map(trainingRow.TrainingMentors, func(mentorUuid pgtype.UUID, _ int) *pb.User {
					return &pb.User{
						Uuid: *utils.MarshalPgUUID(mentorUuid),
					}
				}),
				TopicsAmount: int32(trainingRow.TopicsCount),
			}
		})
	case TrainingTypeFavorite:
		trainingsRaw, err := ts.trainingRepository.GetFavoriteTrainingList(ctx, *&params.UserUuid)
		if err != nil {
			return &pb.TrainingPreviewList{}, err
		}
		trainings = lo.Map(trainingsRaw, func(trainingRow db.GetFavoriteTrainingListRow, _ int) *pb.TrainingPreview {
			return &pb.TrainingPreview{
				Uuid:        *utils.MarshalPgUUID(trainingRow.Uuid),
				Name:        trainingRow.Name,
				Description: trainingRow.Description,
				Owner: &pb.User{
					Uuid: *utils.MarshalPgUUID(trainingRow.OwnerUuid),
				},
				CreatedAt:     trainingRow.CreatedAt.Time.String(),
				UpdatedAt:     trainingRow.UpdatedAt.Time.String(),
				FavoriteCount: int32(trainingRow.FavoriteCount),
				IsPrivate:     trainingRow.IsPrivate,
				TrainingTagList: lo.Map(trainingRow.Tags, func(tag string, _ int) *pb.TrainingTag {
					return &pb.TrainingTag{TagName: tag}
				}),
				TrainingStudents: lo.Map(trainingRow.TrainingStudents, func(studentUuid pgtype.UUID, _ int) *pb.User {
					return &pb.User{
						Uuid: *utils.MarshalPgUUID(studentUuid),
					}
				}),
				TrainingMentors: lo.Map(trainingRow.TrainingMentors, func(mentorUuid pgtype.UUID, _ int) *pb.User {
					return &pb.User{
						Uuid: *utils.MarshalPgUUID(mentorUuid),
					}
				}),
				TopicsAmount: int32(trainingRow.TopicsCount),
			}
		})
	default:
		return &pb.TrainingPreviewList{}, &WrongTrainingTypeError{}
	}

	trainingList := &pb.TrainingPreviewList{
		Size:         int32(len(trainings)),
		TrainingList: trainings,
	}

	return trainingList, nil
}

type GetGetTrainingsAmountByUserIdParams struct {
	UserUuid pgtype.UUID
}

func (ts *TrainingService) GetTrainingsAmountByUserId(ctx context.Context, params *GetGetTrainingsAmountByUserIdParams) (*pb.TrainingsAmount, error) {
	trainingsAmountRaw, err := ts.trainingRepository.GetTrainingsAmountByUserId(ctx, *&params.UserUuid)
	if err != nil {
		return &pb.TrainingsAmount{}, err
	}

	trainingList := &pb.TrainingsAmount{
		Owner:    int32(trainingsAmountRaw.Owner),
		Mentor:   int32(trainingsAmountRaw.Mentor),
		Student:  int32(trainingsAmountRaw.Student),
		Favorite: int32(trainingsAmountRaw.Favorite),
	}

	return trainingList, nil
}

func (ts *TrainingService) GetTrainingById(ctx context.Context, trainingUuid pgtype.UUID) (pb.Training, error) {
	dbTraining, err := ts.trainingRepository.GetTrainingById(ctx, trainingUuid)
	if err != nil {
		return pb.Training{}, err
	}

	dbTrainingTags, err := ts.trainingRepository.GetListTrainingTagsByTrainingId(ctx, trainingUuid)
	if err != nil {
		return pb.Training{}, err
	}
	tags := lo.Map(dbTrainingTags, func(tag db.TrainingTag, _ int) *pb.TrainingTag {
		return &pb.TrainingTag{TagName: tag.Name}
	})

	topicsRaw, err := ts.trainingRepository.GetTopicsByTrainingId(ctx, dbTraining.Uuid)
	if err != nil {
		return pb.Training{}, err
	}
	topics := lo.Map(topicsRaw, func(topic db.GetTopicsByTrainingIdRow, _ int) *pb.TopicPreview {
		return &pb.TopicPreview{
			Uuid:                    *utils.MarshalPgUUID(topic.Uuid),
			Name:                    topic.Name.String,
			CreatedAt:               topic.CreatedAt.Time.String(),
			TrainingUuid:            *utils.MarshalPgUUID(dbTraining.Uuid),
			TopicOrder:              int32(topic.TopicOrder),
			ParentTopicUuid:         utils.MarshalPgUUID(topic.Parent),
			TheoryMaterialsAmount:   int32(topic.TheoryMaterialsAmount),
			PracticeMaterialsAmount: int32(topic.PracticeMaterialsAmount),
		}
	})

	buildTopicsTree := func(topics []*pb.TopicPreview) []*pb.TopicTreeNode {
		nodeMap := make(map[string]*pb.TopicTreeNode)

		for _, topic := range topics {
			nodeMap[topic.Uuid] = &pb.TopicTreeNode{
				Topic:    topic,
				Children: []*pb.TopicTreeNode{},
			}
		}

		roots := []*pb.TopicTreeNode{}

		for _, topic := range topics {
			node := nodeMap[topic.Uuid]
			if topic.ParentTopicUuid == nil {
				roots = append(roots, node)
			} else {
				parent, exists := nodeMap[*topic.ParentTopicUuid]
				if exists {
					parent.Children = append(parent.Children, node)
				} else {
					log.Printf("Parent with UUID %v not found for node %v", *topic.ParentTopicUuid, topic.Uuid)
				}
			}
		}

		return roots
	}

	topicsTree := buildTopicsTree(topics)

	return pb.Training{
		Uuid: *utils.MarshalPgUUID(dbTraining.Uuid),
		Owner: &pb.User{
			Uuid: *utils.MarshalPgUUID(dbTraining.OwnerUuid),
		},
		Name:            dbTraining.Name,
		Description:     dbTraining.Description,
		CreatedAt:       dbTraining.CreatedAt.Time.String(),
		UpdatedAt:       dbTraining.UpdatedAt.Time.String(),
		IsPrivate:       dbTraining.IsPrivate,
		TrainingTagList: tags,
		TrainingStudents: lo.Map(dbTraining.TrainingStudents, func(studentUuid pgtype.UUID, _ int) *pb.User {
			return &pb.User{
				Uuid: *utils.MarshalPgUUID(studentUuid),
			}
		}),
		TrainingMentors: lo.Map(dbTraining.TrainingMentors, func(mentorUuid pgtype.UUID, _ int) *pb.User {
			return &pb.User{
				Uuid: *utils.MarshalPgUUID(mentorUuid),
			}
		}),
		FavoriteForUsersPreview: lo.Map(dbTraining.FavoriteUsers, func(userUuid pgtype.UUID, _ int) string {
			return *utils.MarshalPgUUID(userUuid)
		}),
		TopicsTree: topicsTree,
	}, nil
}

func (ts *TrainingService) CreateTraining(ctx context.Context, params db.CreateTrainingParams) (pb.Training, error) {
	trainingRaw, err := ts.trainingRepository.CreateTraining(ctx, params)
	if err != nil {
		return pb.Training{}, err
	}

	dbTraining, err := ts.trainingRepository.GetTrainingById(ctx, trainingRaw.Uuid)
	if err != nil {
		return pb.Training{}, err
	}

	return pb.Training{
		Uuid: *utils.MarshalPgUUID(dbTraining.Uuid),
		Owner: &pb.User{
			Uuid: utils.ConvertPgUUIDToUUID(params.OwnerUuid).String(),
		},
		Name:        dbTraining.Name,
		Description: dbTraining.Description,
		CreatedAt:   dbTraining.CreatedAt.Time.String(),
		UpdatedAt:   dbTraining.UpdatedAt.Time.String(),
		IsPrivate:   dbTraining.IsPrivate,
		TrainingTagList: lo.Map(dbTraining.Tags, func(tag string, _ int) *pb.TrainingTag {
			return &pb.TrainingTag{TagName: tag}
		}),
		TrainingStudents: lo.Map(dbTraining.TrainingStudents, func(studentUuid pgtype.UUID, _ int) *pb.User {
			return &pb.User{
				Uuid: *utils.MarshalPgUUID(studentUuid),
			}
		}),
		TrainingMentors: lo.Map(dbTraining.TrainingMentors, func(mentorUuid pgtype.UUID, _ int) *pb.User {
			return &pb.User{
				Uuid: *utils.MarshalPgUUID(mentorUuid),
			}
		}),
	}, nil
}

func (ts *TrainingService) UpdateTraining(ctx context.Context, params db.UpdateTrainingParams) (pb.Training, error) {
	trainingRaw, err := ts.trainingRepository.UpdateTraining(ctx, params)
	if err != nil {
		return pb.Training{}, err
	}

	training, err := ts.trainingRepository.GetTrainingById(ctx, trainingRaw.Uuid)
	if err != nil {
		return pb.Training{}, err
	}

	return pb.Training{
		Uuid:        *utils.MarshalPgUUID(training.Uuid),
		Name:        training.Name,
		Description: training.Description,
		Owner: &pb.User{
			Uuid:     *utils.MarshalPgUUID(training.OwnerUuid),
			Name:     "Stub",
			ImageUrl: "Stub",
		},
		CreatedAt: training.CreatedAt.Time.String(),
		UpdatedAt: training.UpdatedAt.Time.String(),
		IsPrivate: training.IsPrivate,
		TrainingTagList: lo.Map(training.Tags, func(tag string, _ int) *pb.TrainingTag {
			return &pb.TrainingTag{TagName: tag}
		}),
		TrainingStudents: lo.Map(training.TrainingStudents, func(studentUuid pgtype.UUID, _ int) *pb.User {
			return &pb.User{
				Uuid: *utils.MarshalPgUUID(studentUuid),
			}
		}),
		TrainingMentors: lo.Map(training.TrainingMentors, func(mentorUuid pgtype.UUID, _ int) *pb.User {
			return &pb.User{
				Uuid: *utils.MarshalPgUUID(mentorUuid),
			}
		}),
	}, nil
}

func (ts *TrainingService) DeleteTraining(ctx context.Context, trainingUuid pgtype.UUID) error {
	return ts.trainingRepository.DeleteTraining(ctx, trainingUuid)
}
