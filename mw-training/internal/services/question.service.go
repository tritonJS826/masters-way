package services

import (
	"context"
	db "mw-training/internal/db/sqlc"
	pb "mw-training/pkg/grpcAutogenerated/training"
	"mw-training/pkg/utils"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
)

type QuestionRepository interface {
	GetQuestionById(ctx context.Context, questionUuid pgtype.UUID) (db.Question, error)
	CreateQuestion(ctx context.Context, params db.CreateQuestionParams) (db.Question, error)
	UpdateQuestion(ctx context.Context, params db.UpdateQuestionParams) (db.Question, error)
	DeleteQuestion(ctx context.Context, questionUuid pgtype.UUID) error
	GetQuestionsByTestId(ctx context.Context, params db.GetQuestionsByTestIdParams) ([]db.Question, error)
	WithTx(tx pgx.Tx) *db.Queries
}

type QuestionService struct {
	questionRepository QuestionRepository
	pgxPool            *pgxpool.Pool
}

func NewQuestionService(pgxPool *pgxpool.Pool, questionRepository QuestionRepository) *QuestionService {
	return &QuestionService{
		pgxPool:            pgxPool,
		questionRepository: questionRepository,
	}
}

type GetQuestionByIdParams struct {
	QuestionUuid pgtype.UUID
	UserUuid     pgtype.UUID
}

func (ts *QuestionService) GetQuestionById(ctx context.Context, params GetQuestionByIdParams) (*pb.Question, error) {
	questionDb, err := ts.questionRepository.GetQuestionById(ctx, params.QuestionUuid)
	if err != nil {
		return &pb.Question{}, err
	}

	return &pb.Question{
		Uuid:         *utils.MarshalPgUUID(questionDb.Uuid),
		TestUuid:     *utils.MarshalPgUUID(questionDb.TestUuid),
		QuestionText: questionDb.QuestionText,
		Order:        questionDb.QuestionOrder,
		TimeToAnswer: questionDb.TimeToAnswer,
		Answer:       questionDb.Answer,
		IsActive:     questionDb.IsActive,
		CreatedAt:    questionDb.CreatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
		UpdatedAt:    questionDb.UpdatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
	}, nil
}

func (ts *QuestionService) CreateQuestion(ctx context.Context, params db.CreateQuestionParams) (*pb.Question, error) {
	questionDb, err := ts.questionRepository.CreateQuestion(ctx, params)
	if err != nil {
		return &pb.Question{}, err
	}

	return &pb.Question{
		Uuid:         *utils.MarshalPgUUID(questionDb.Uuid),
		TestUuid:     *utils.MarshalPgUUID(questionDb.TestUuid),
		Name:         questionDb.Name.String,
		QuestionText: questionDb.QuestionText,
		Order:        questionDb.QuestionOrder,
		TimeToAnswer: questionDb.TimeToAnswer,
		Answer:       questionDb.Answer,
		IsActive:     questionDb.IsActive,
		CreatedAt:    questionDb.CreatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
		UpdatedAt:    questionDb.UpdatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
	}, nil
}

func (ts *QuestionService) UpdateQuestion(ctx context.Context, params db.UpdateQuestionParams) (*pb.Question, error) {
	questionDb, err := ts.questionRepository.UpdateQuestion(ctx, params)
	if err != nil {
		return &pb.Question{}, err
	}

	return &pb.Question{
		Uuid:         *utils.MarshalPgUUID(questionDb.Uuid),
		TestUuid:     *utils.MarshalPgUUID(questionDb.TestUuid),
		QuestionText: questionDb.QuestionText,
		Order:        questionDb.QuestionOrder,
		TimeToAnswer: questionDb.TimeToAnswer,
		Answer:       questionDb.Answer,
		IsActive:     questionDb.IsActive,
		CreatedAt:    questionDb.CreatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
		UpdatedAt:    questionDb.UpdatedAt.Time.Format(utils.DEFAULT_STRING_LAYOUT),
		Name:         questionDb.Name.String,
	}, nil
}

func (ts *QuestionService) DeleteQuestion(ctx context.Context, questionUuid pgtype.UUID) error {
	return ts.questionRepository.DeleteQuestion(ctx, questionUuid)
}
