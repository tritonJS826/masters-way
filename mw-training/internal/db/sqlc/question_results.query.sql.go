// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: question_results.query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createQuestionResult = `-- name: CreateQuestionResult :one
INSERT INTO question_results (
    question_uuid,
    user_answer,
    test_session_uuid,
    user_uuid,
    test_uuid,
    is_ok,
    result_description
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6,
    $7
) RETURNING uuid, question_uuid, user_uuid, test_uuid, test_session_uuid, is_ok, user_answer, result_description, created_at
`

type CreateQuestionResultParams struct {
	QuestionUuid      pgtype.UUID `json:"question_uuid"`
	UserAnswer        string      `json:"user_answer"`
	TestSessionUuid   pgtype.UUID `json:"test_session_uuid"`
	UserUuid          pgtype.UUID `json:"user_uuid"`
	TestUuid          pgtype.UUID `json:"test_uuid"`
	IsOk              bool        `json:"is_ok"`
	ResultDescription string      `json:"result_description"`
}

func (q *Queries) CreateQuestionResult(ctx context.Context, arg CreateQuestionResultParams) (QuestionResult, error) {
	row := q.db.QueryRow(ctx, createQuestionResult,
		arg.QuestionUuid,
		arg.UserAnswer,
		arg.TestSessionUuid,
		arg.UserUuid,
		arg.TestUuid,
		arg.IsOk,
		arg.ResultDescription,
	)
	var i QuestionResult
	err := row.Scan(
		&i.Uuid,
		&i.QuestionUuid,
		&i.UserUuid,
		&i.TestUuid,
		&i.TestSessionUuid,
		&i.IsOk,
		&i.UserAnswer,
		&i.ResultDescription,
		&i.CreatedAt,
	)
	return i, err
}

const deleteQuestionResult = `-- name: DeleteQuestionResult :exec
DELETE FROM question_results
WHERE question_results.uuid = $1
`

func (q *Queries) DeleteQuestionResult(ctx context.Context, resultUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteQuestionResult, resultUuid)
	return err
}

const getQuestionResultById = `-- name: GetQuestionResultById :one
SELECT
    question_results.uuid,
    question_results.question_uuid,
    question_results.test_session_uuid,
    question_results.user_uuid,
    question_results.test_uuid,
    question_results.is_ok,
    question_results.result_description,
    question_results.created_at,
    questions.uuid AS question_uuid,
    questions.name AS question_name,
    questions.question_text AS question_text,
    questions.question_order AS question_order,
    questions.answer AS question_answer
FROM
    question_results
JOIN questions ON questions.uuid = question_results.question_uuid
WHERE
    question_results.uuid = $1
`

type GetQuestionResultByIdRow struct {
	Uuid              pgtype.UUID      `json:"uuid"`
	QuestionUuid      pgtype.UUID      `json:"question_uuid"`
	TestSessionUuid   pgtype.UUID      `json:"test_session_uuid"`
	UserUuid          pgtype.UUID      `json:"user_uuid"`
	TestUuid          pgtype.UUID      `json:"test_uuid"`
	IsOk              bool             `json:"is_ok"`
	ResultDescription string           `json:"result_description"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	QuestionUuid_2    pgtype.UUID      `json:"question_uuid_2"`
	QuestionName      pgtype.Text      `json:"question_name"`
	QuestionText      string           `json:"question_text"`
	QuestionOrder     int32            `json:"question_order"`
	QuestionAnswer    string           `json:"question_answer"`
}

func (q *Queries) GetQuestionResultById(ctx context.Context, resultUuid pgtype.UUID) (GetQuestionResultByIdRow, error) {
	row := q.db.QueryRow(ctx, getQuestionResultById, resultUuid)
	var i GetQuestionResultByIdRow
	err := row.Scan(
		&i.Uuid,
		&i.QuestionUuid,
		&i.TestSessionUuid,
		&i.UserUuid,
		&i.TestUuid,
		&i.IsOk,
		&i.ResultDescription,
		&i.CreatedAt,
		&i.QuestionUuid_2,
		&i.QuestionName,
		&i.QuestionText,
		&i.QuestionOrder,
		&i.QuestionAnswer,
	)
	return i, err
}

const getQuestionResultsBySessionUuid = `-- name: GetQuestionResultsBySessionUuid :many
SELECT
    question_results.uuid,
    question_results.question_uuid,
    question_results.test_session_uuid,
    question_results.user_uuid,
    question_results.test_uuid,
    question_results.is_ok,
    question_results.result_description,
    question_results.user_answer,
    question_results.created_at,
    questions.uuid AS question_uuid,
    questions.name AS question_name,
    questions.question_text AS question_text,
    questions.question_order AS question_order,
    questions.answer AS question_answer
FROM
    question_results
JOIN questions ON questions.uuid = question_results.question_uuid
WHERE
    question_results.test_session_uuid = $1
ORDER BY
    questions.question_order ASC
`

type GetQuestionResultsBySessionUuidRow struct {
	Uuid              pgtype.UUID      `json:"uuid"`
	QuestionUuid      pgtype.UUID      `json:"question_uuid"`
	TestSessionUuid   pgtype.UUID      `json:"test_session_uuid"`
	UserUuid          pgtype.UUID      `json:"user_uuid"`
	TestUuid          pgtype.UUID      `json:"test_uuid"`
	IsOk              bool             `json:"is_ok"`
	ResultDescription string           `json:"result_description"`
	UserAnswer        string           `json:"user_answer"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	QuestionUuid_2    pgtype.UUID      `json:"question_uuid_2"`
	QuestionName      pgtype.Text      `json:"question_name"`
	QuestionText      string           `json:"question_text"`
	QuestionOrder     int32            `json:"question_order"`
	QuestionAnswer    string           `json:"question_answer"`
}

func (q *Queries) GetQuestionResultsBySessionUuid(ctx context.Context, testSessionUuid pgtype.UUID) ([]GetQuestionResultsBySessionUuidRow, error) {
	rows, err := q.db.Query(ctx, getQuestionResultsBySessionUuid, testSessionUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetQuestionResultsBySessionUuidRow{}
	for rows.Next() {
		var i GetQuestionResultsBySessionUuidRow
		if err := rows.Scan(
			&i.Uuid,
			&i.QuestionUuid,
			&i.TestSessionUuid,
			&i.UserUuid,
			&i.TestUuid,
			&i.IsOk,
			&i.ResultDescription,
			&i.UserAnswer,
			&i.CreatedAt,
			&i.QuestionUuid_2,
			&i.QuestionName,
			&i.QuestionText,
			&i.QuestionOrder,
			&i.QuestionAnswer,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestQuestionStats = `-- name: GetTestQuestionStats :many
SELECT
    question_results.question_uuid,
    COUNT(*) AS total_attempts,
    COUNT(*) FILTER (WHERE is_ok = true) AS correct_answers,
    COUNT(*) FILTER (WHERE is_ok = false) AS incorrect_answers,
    ROUND(
        (COUNT(*) FILTER (WHERE is_ok = true)::float / COUNT(*)::float) * 100, 2
    ) AS success_rate
FROM
    question_results
WHERE
    question_results.test_uuid = $1
GROUP BY
    question_results.question_uuid
`

type GetTestQuestionStatsRow struct {
	QuestionUuid     pgtype.UUID    `json:"question_uuid"`
	TotalAttempts    int64          `json:"total_attempts"`
	CorrectAnswers   int64          `json:"correct_answers"`
	IncorrectAnswers int64          `json:"incorrect_answers"`
	SuccessRate      pgtype.Numeric `json:"success_rate"`
}

func (q *Queries) GetTestQuestionStats(ctx context.Context, testUuid pgtype.UUID) ([]GetTestQuestionStatsRow, error) {
	rows, err := q.db.Query(ctx, getTestQuestionStats, testUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTestQuestionStatsRow{}
	for rows.Next() {
		var i GetTestQuestionStatsRow
		if err := rows.Scan(
			&i.QuestionUuid,
			&i.TotalAttempts,
			&i.CorrectAnswers,
			&i.IncorrectAnswers,
			&i.SuccessRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
