// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: question_results.query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createQuestionResult = `-- name: CreateQuestionResult :one
INSERT INTO question_results (
    question_uuid,
    test_session_uuid,
    user_uuid,
    test_uuid,
    is_ok,
    result_description
) VALUES (
    $1,
    $2,
    $3,
    $4,
    $5,
    $6
) RETURNING uuid, question_uuid, user_uuid, test_uuid, test_session_uuid, is_ok, result_description, created_at
`

type CreateQuestionResultParams struct {
	QuestionUuid      pgtype.UUID `json:"question_uuid"`
	TestSessionUuid   pgtype.UUID `json:"test_session_uuid"`
	UserUuid          pgtype.UUID `json:"user_uuid"`
	TestUuid          pgtype.UUID `json:"test_uuid"`
	IsOk              bool        `json:"is_ok"`
	ResultDescription string      `json:"result_description"`
}

func (q *Queries) CreateQuestionResult(ctx context.Context, arg CreateQuestionResultParams) (QuestionResult, error) {
	row := q.db.QueryRow(ctx, createQuestionResult,
		arg.QuestionUuid,
		arg.TestSessionUuid,
		arg.UserUuid,
		arg.TestUuid,
		arg.IsOk,
		arg.ResultDescription,
	)
	var i QuestionResult
	err := row.Scan(
		&i.Uuid,
		&i.QuestionUuid,
		&i.UserUuid,
		&i.TestUuid,
		&i.TestSessionUuid,
		&i.IsOk,
		&i.ResultDescription,
		&i.CreatedAt,
	)
	return i, err
}

const deleteQuestionResult = `-- name: DeleteQuestionResult :exec
DELETE FROM question_results
WHERE question_results.uuid = $1
`

func (q *Queries) DeleteQuestionResult(ctx context.Context, resultUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteQuestionResult, resultUuid)
	return err
}

const deleteQuestionResultsByQuestion = `-- name: DeleteQuestionResultsByQuestion :exec
DELETE FROM question_results
WHERE question_results.question_uuid = $1
`

func (q *Queries) DeleteQuestionResultsByQuestion(ctx context.Context, questionUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteQuestionResultsByQuestion, questionUuid)
	return err
}

const deleteQuestionResultsByTest = `-- name: DeleteQuestionResultsByTest :exec
DELETE FROM question_results
WHERE question_results.test_uuid = $1
`

func (q *Queries) DeleteQuestionResultsByTest(ctx context.Context, testUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteQuestionResultsByTest, testUuid)
	return err
}

const getQuestionResultById = `-- name: GetQuestionResultById :one
SELECT
    question_results.uuid,
    question_results.question_uuid,
    question_results.test_session_uuid,
    question_results.user_uuid,
    question_results.test_uuid,
    question_results.is_ok,
    question_results.result_description,
    question_results.created_at
FROM
    question_results
WHERE
    question_results.uuid = $1
`

type GetQuestionResultByIdRow struct {
	Uuid              pgtype.UUID      `json:"uuid"`
	QuestionUuid      pgtype.UUID      `json:"question_uuid"`
	TestSessionUuid   pgtype.UUID      `json:"test_session_uuid"`
	UserUuid          pgtype.UUID      `json:"user_uuid"`
	TestUuid          pgtype.UUID      `json:"test_uuid"`
	IsOk              bool             `json:"is_ok"`
	ResultDescription string           `json:"result_description"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetQuestionResultById(ctx context.Context, resultUuid pgtype.UUID) (GetQuestionResultByIdRow, error) {
	row := q.db.QueryRow(ctx, getQuestionResultById, resultUuid)
	var i GetQuestionResultByIdRow
	err := row.Scan(
		&i.Uuid,
		&i.QuestionUuid,
		&i.TestSessionUuid,
		&i.UserUuid,
		&i.TestUuid,
		&i.IsOk,
		&i.ResultDescription,
		&i.CreatedAt,
	)
	return i, err
}

const getQuestionResultsByQuestion = `-- name: GetQuestionResultsByQuestion :many
SELECT
    question_results.uuid,
    question_results.question_uuid,
    question_results.test_session_uuid,
    question_results.user_uuid,
    question_results.test_uuid,
    question_results.is_ok,
    question_results.result_description,
    question_results.created_at
FROM
    question_results
WHERE
    question_results.question_uuid = $1
ORDER BY
    question_results.created_at DESC
`

type GetQuestionResultsByQuestionRow struct {
	Uuid              pgtype.UUID      `json:"uuid"`
	QuestionUuid      pgtype.UUID      `json:"question_uuid"`
	TestSessionUuid   pgtype.UUID      `json:"test_session_uuid"`
	UserUuid          pgtype.UUID      `json:"user_uuid"`
	TestUuid          pgtype.UUID      `json:"test_uuid"`
	IsOk              bool             `json:"is_ok"`
	ResultDescription string           `json:"result_description"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetQuestionResultsByQuestion(ctx context.Context, questionUuid pgtype.UUID) ([]GetQuestionResultsByQuestionRow, error) {
	rows, err := q.db.Query(ctx, getQuestionResultsByQuestion, questionUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetQuestionResultsByQuestionRow{}
	for rows.Next() {
		var i GetQuestionResultsByQuestionRow
		if err := rows.Scan(
			&i.Uuid,
			&i.QuestionUuid,
			&i.TestSessionUuid,
			&i.UserUuid,
			&i.TestUuid,
			&i.IsOk,
			&i.ResultDescription,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionResultsBySessionUser = `-- name: GetQuestionResultsBySessionUser :many
SELECT
    question_results.uuid,
    question_results.question_uuid,
    question_results.test_session_uuid,
    question_results.user_uuid,
    question_results.test_uuid,
    question_results.is_ok,
    question_results.result_description,
    question_results.created_at
FROM
    question_results
WHERE
    question_results.user_uuid = $1
ORDER BY
    question_results.created_at DESC
`

type GetQuestionResultsBySessionUserRow struct {
	Uuid              pgtype.UUID      `json:"uuid"`
	QuestionUuid      pgtype.UUID      `json:"question_uuid"`
	TestSessionUuid   pgtype.UUID      `json:"test_session_uuid"`
	UserUuid          pgtype.UUID      `json:"user_uuid"`
	TestUuid          pgtype.UUID      `json:"test_uuid"`
	IsOk              bool             `json:"is_ok"`
	ResultDescription string           `json:"result_description"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetQuestionResultsBySessionUser(ctx context.Context, userUuid pgtype.UUID) ([]GetQuestionResultsBySessionUserRow, error) {
	rows, err := q.db.Query(ctx, getQuestionResultsBySessionUser, userUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetQuestionResultsBySessionUserRow{}
	for rows.Next() {
		var i GetQuestionResultsBySessionUserRow
		if err := rows.Scan(
			&i.Uuid,
			&i.QuestionUuid,
			&i.TestSessionUuid,
			&i.UserUuid,
			&i.TestUuid,
			&i.IsOk,
			&i.ResultDescription,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionResultsBySessionUuid = `-- name: GetQuestionResultsBySessionUuid :many
SELECT
    question_results.uuid,
    question_results.question_uuid,
    question_results.test_session_uuid,
    question_results.user_uuid,
    question_results.test_uuid,
    question_results.is_ok,
    question_results.result_description,
    question_results.created_at
FROM
    question_results
WHERE
    question_results.test_session_uuid = $1
ORDER BY
    question_results.created_at DESC
`

type GetQuestionResultsBySessionUuidRow struct {
	Uuid              pgtype.UUID      `json:"uuid"`
	QuestionUuid      pgtype.UUID      `json:"question_uuid"`
	TestSessionUuid   pgtype.UUID      `json:"test_session_uuid"`
	UserUuid          pgtype.UUID      `json:"user_uuid"`
	TestUuid          pgtype.UUID      `json:"test_uuid"`
	IsOk              bool             `json:"is_ok"`
	ResultDescription string           `json:"result_description"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetQuestionResultsBySessionUuid(ctx context.Context, testSessionUuid pgtype.UUID) ([]GetQuestionResultsBySessionUuidRow, error) {
	rows, err := q.db.Query(ctx, getQuestionResultsBySessionUuid, testSessionUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetQuestionResultsBySessionUuidRow{}
	for rows.Next() {
		var i GetQuestionResultsBySessionUuidRow
		if err := rows.Scan(
			&i.Uuid,
			&i.QuestionUuid,
			&i.TestSessionUuid,
			&i.UserUuid,
			&i.TestUuid,
			&i.IsOk,
			&i.ResultDescription,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionResultsByTest = `-- name: GetQuestionResultsByTest :many
SELECT
    question_results.uuid,
    question_results.question_uuid,
    question_results.test_session_uuid,
    question_results.user_uuid,
    question_results.test_uuid,
    question_results.is_ok,
    question_results.result_description,
    question_results.created_at
FROM
    question_results
WHERE
    question_results.test_uuid = $1
ORDER BY
    question_results.created_at DESC
`

type GetQuestionResultsByTestRow struct {
	Uuid              pgtype.UUID      `json:"uuid"`
	QuestionUuid      pgtype.UUID      `json:"question_uuid"`
	TestSessionUuid   pgtype.UUID      `json:"test_session_uuid"`
	UserUuid          pgtype.UUID      `json:"user_uuid"`
	TestUuid          pgtype.UUID      `json:"test_uuid"`
	IsOk              bool             `json:"is_ok"`
	ResultDescription string           `json:"result_description"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetQuestionResultsByTest(ctx context.Context, testUuid pgtype.UUID) ([]GetQuestionResultsByTestRow, error) {
	rows, err := q.db.Query(ctx, getQuestionResultsByTest, testUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetQuestionResultsByTestRow{}
	for rows.Next() {
		var i GetQuestionResultsByTestRow
		if err := rows.Scan(
			&i.Uuid,
			&i.QuestionUuid,
			&i.TestSessionUuid,
			&i.UserUuid,
			&i.TestUuid,
			&i.IsOk,
			&i.ResultDescription,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionStats = `-- name: GetQuestionStats :one
SELECT
    COUNT(*) AS total_attempts,
    COUNT(*) FILTER (WHERE is_ok = true) AS correct_answers,
    COUNT(*) FILTER (WHERE is_ok = false) AS incorrect_answers,
    ROUND(
        (COUNT(*) FILTER (WHERE is_ok = true)::float / COUNT(*)::float) * 100, 2
    ) AS success_rate
FROM
    question_results
WHERE
    question_results.question_uuid = $1
`

type GetQuestionStatsRow struct {
	TotalAttempts    int64          `json:"total_attempts"`
	CorrectAnswers   int64          `json:"correct_answers"`
	IncorrectAnswers int64          `json:"incorrect_answers"`
	SuccessRate      pgtype.Numeric `json:"success_rate"`
}

func (q *Queries) GetQuestionStats(ctx context.Context, questionUuid pgtype.UUID) (GetQuestionStatsRow, error) {
	row := q.db.QueryRow(ctx, getQuestionStats, questionUuid)
	var i GetQuestionStatsRow
	err := row.Scan(
		&i.TotalAttempts,
		&i.CorrectAnswers,
		&i.IncorrectAnswers,
		&i.SuccessRate,
	)
	return i, err
}

const getTestQuestionStats = `-- name: GetTestQuestionStats :many
SELECT
    question_results.question_uuid,
    COUNT(*) AS total_attempts,
    COUNT(*) FILTER (WHERE is_ok = true) AS correct_answers,
    COUNT(*) FILTER (WHERE is_ok = false) AS incorrect_answers,
    ROUND(
        (COUNT(*) FILTER (WHERE is_ok = true)::float / COUNT(*)::float) * 100, 2
    ) AS success_rate
FROM
    question_results
WHERE
    question_results.test_uuid = $1
GROUP BY
    question_results.question_uuid
`

type GetTestQuestionStatsRow struct {
	QuestionUuid     pgtype.UUID    `json:"question_uuid"`
	TotalAttempts    int64          `json:"total_attempts"`
	CorrectAnswers   int64          `json:"correct_answers"`
	IncorrectAnswers int64          `json:"incorrect_answers"`
	SuccessRate      pgtype.Numeric `json:"success_rate"`
}

func (q *Queries) GetTestQuestionStats(ctx context.Context, testUuid pgtype.UUID) ([]GetTestQuestionStatsRow, error) {
	rows, err := q.db.Query(ctx, getTestQuestionStats, testUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTestQuestionStatsRow{}
	for rows.Next() {
		var i GetTestQuestionStatsRow
		if err := rows.Scan(
			&i.QuestionUuid,
			&i.TotalAttempts,
			&i.CorrectAnswers,
			&i.IncorrectAnswers,
			&i.SuccessRate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserQuestionResult = `-- name: GetUserQuestionResult :one
SELECT
    question_results.uuid,
    question_results.question_uuid,
    question_results.test_session_uuid,
    question_results.user_uuid,
    question_results.test_uuid,
    question_results.is_ok,
    question_results.result_description,
    question_results.created_at
FROM
    question_results
WHERE
    question_results.user_uuid = $1
    AND question_results.question_uuid = $2
    AND question_results.test_uuid = $3
ORDER BY
    question_results.created_at DESC
LIMIT 1
`

type GetUserQuestionResultParams struct {
	UserUuid     pgtype.UUID `json:"user_uuid"`
	QuestionUuid pgtype.UUID `json:"question_uuid"`
	TestUuid     pgtype.UUID `json:"test_uuid"`
}

type GetUserQuestionResultRow struct {
	Uuid              pgtype.UUID      `json:"uuid"`
	QuestionUuid      pgtype.UUID      `json:"question_uuid"`
	TestSessionUuid   pgtype.UUID      `json:"test_session_uuid"`
	UserUuid          pgtype.UUID      `json:"user_uuid"`
	TestUuid          pgtype.UUID      `json:"test_uuid"`
	IsOk              bool             `json:"is_ok"`
	ResultDescription string           `json:"result_description"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetUserQuestionResult(ctx context.Context, arg GetUserQuestionResultParams) (GetUserQuestionResultRow, error) {
	row := q.db.QueryRow(ctx, getUserQuestionResult, arg.UserUuid, arg.QuestionUuid, arg.TestUuid)
	var i GetUserQuestionResultRow
	err := row.Scan(
		&i.Uuid,
		&i.QuestionUuid,
		&i.TestSessionUuid,
		&i.UserUuid,
		&i.TestUuid,
		&i.IsOk,
		&i.ResultDescription,
		&i.CreatedAt,
	)
	return i, err
}

const getUserTestProgress = `-- name: GetUserTestProgress :one
SELECT
    COUNT(DISTINCT question_results.question_uuid) AS answered_questions,
    COUNT(*) FILTER (WHERE is_ok = true) AS correct_answers,
    COUNT(*) FILTER (WHERE is_ok = false) AS incorrect_answers
FROM
    question_results
WHERE
    question_results.user_uuid = $1
    AND question_results.test_uuid = $2
`

type GetUserTestProgressParams struct {
	UserUuid pgtype.UUID `json:"user_uuid"`
	TestUuid pgtype.UUID `json:"test_uuid"`
}

type GetUserTestProgressRow struct {
	AnsweredQuestions int64 `json:"answered_questions"`
	CorrectAnswers    int64 `json:"correct_answers"`
	IncorrectAnswers  int64 `json:"incorrect_answers"`
}

func (q *Queries) GetUserTestProgress(ctx context.Context, arg GetUserTestProgressParams) (GetUserTestProgressRow, error) {
	row := q.db.QueryRow(ctx, getUserTestProgress, arg.UserUuid, arg.TestUuid)
	var i GetUserTestProgressRow
	err := row.Scan(&i.AnsweredQuestions, &i.CorrectAnswers, &i.IncorrectAnswers)
	return i, err
}
