// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: trainings.query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTraining = `-- name: CreateTraining :one
INSERT INTO trainings (
    name,
    description,
    owner_uuid
) VALUES (
    $1,
    $2,
    $3
) RETURNING uuid, name, description, is_private, updated_at, created_at, owner_uuid
`

type CreateTrainingParams struct {
	Name        pgtype.Text `json:"name"`
	Description pgtype.Text `json:"description"`
	OwnerUuid   pgtype.UUID `json:"owner_uuid"`
}

func (q *Queries) CreateTraining(ctx context.Context, arg CreateTrainingParams) (Training, error) {
	row := q.db.QueryRow(ctx, createTraining, arg.Name, arg.Description, arg.OwnerUuid)
	var i Training
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.IsPrivate,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.OwnerUuid,
	)
	return i, err
}

const deleteTraining = `-- name: DeleteTraining :exec
DELETE FROM trainings
WHERE trainings.uuid = $1
`

func (q *Queries) DeleteTraining(ctx context.Context, trainingUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTraining, trainingUuid)
	return err
}

const getFavoriteTrainingList = `-- name: GetFavoriteTrainingList :many
SELECT 
    uuid, name, description, is_private, updated_at, created_at, owner_uuid
FROM trainings
`

func (q *Queries) GetFavoriteTrainingList(ctx context.Context) ([]Training, error) {
	rows, err := q.db.Query(ctx, getFavoriteTrainingList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Training{}
	for rows.Next() {
		var i Training
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.IsPrivate,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.OwnerUuid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMentoringTrainingList = `-- name: GetMentoringTrainingList :many
SELECT 
    uuid, name, description, is_private, updated_at, created_at, owner_uuid
FROM trainings
`

func (q *Queries) GetMentoringTrainingList(ctx context.Context) ([]Training, error) {
	rows, err := q.db.Query(ctx, getMentoringTrainingList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Training{}
	for rows.Next() {
		var i Training
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.IsPrivate,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.OwnerUuid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnTrainingList = `-- name: GetOwnTrainingList :many

SELECT 
    uuid, name, description, is_private, updated_at, created_at, owner_uuid
FROM trainings
WHERE trainings.owner_uuid = $1
`

// LIMIT @limit
// OFFSET @offset;
func (q *Queries) GetOwnTrainingList(ctx context.Context, ownerUuid pgtype.UUID) ([]Training, error) {
	rows, err := q.db.Query(ctx, getOwnTrainingList, ownerUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Training{}
	for rows.Next() {
		var i Training
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.IsPrivate,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.OwnerUuid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentTrainingList = `-- name: GetStudentTrainingList :many
SELECT 
    uuid, name, description, is_private, updated_at, created_at, owner_uuid
FROM trainings
`

func (q *Queries) GetStudentTrainingList(ctx context.Context) ([]Training, error) {
	rows, err := q.db.Query(ctx, getStudentTrainingList)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Training{}
	for rows.Next() {
		var i Training
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.IsPrivate,
			&i.UpdatedAt,
			&i.CreatedAt,
			&i.OwnerUuid,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrainingById = `-- name: GetTrainingById :one
SELECT
    uuid, name, description, is_private, updated_at, created_at, owner_uuid
FROM trainings
WHERE trainings.uuid = $1
`

func (q *Queries) GetTrainingById(ctx context.Context, trainingUuid pgtype.UUID) (Training, error) {
	row := q.db.QueryRow(ctx, getTrainingById, trainingUuid)
	var i Training
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.IsPrivate,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.OwnerUuid,
	)
	return i, err
}

const getTrainingList = `-- name: GetTrainingList :many
SELECT
    trainings.uuid,
    trainings.name,
    trainings.is_private,
    trainings.owner_uuid,
    trainings.updated_at,
    COALESCE(f.favorite_count, 0) AS favorite_count,
    ARRAY_AGG(training_tags.name) FILTER (WHERE training_tags.name IS NOT NULL) AS tags,
    ARRAY_AGG(trainings_mentors.mentor_uuid) AS training_mentors,
    ARRAY_AGG(trainings_students.student_uuid) AS training_students
FROM
    trainings
LEFT JOIN
    favorite_users_trainings fuc ON trainings.uuid = fuc.training_uuid
LEFT JOIN
    training_tags ON training_tags.uuid IN (
        SELECT tag_uuid
        FROM training_tags
        WHERE training_uuid = trainings.uuid
    )
LEFT JOIN (
    SELECT
        training_uuid,
        COUNT(user_uuid) AS favorite_count
    FROM
        favorite_users_trainings
    GROUP BY
        training_uuid
) f ON f.training_uuid = trainings.uuid
LEFT JOIN
    trainings_mentors ON trainings_mentors.training_uuid = trainings.uuid
LEFT JOIN
    trainings_students ON trainings_students.training_uuid = trainings.uuid
WHERE
    trainings.name ILIKE $1
GROUP BY
    trainings.uuid, trainings.name, trainings.is_private, trainings.owner_uuid, trainings.updated_at, f.favorite_count
ORDER BY
    favorite_count DESC,
    trainings.created_at DESC
`

type GetTrainingListRow struct {
	Uuid             pgtype.UUID      `json:"uuid"`
	Name             pgtype.Text      `json:"name"`
	IsPrivate        bool             `json:"is_private"`
	OwnerUuid        pgtype.UUID      `json:"owner_uuid"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	FavoriteCount    int64            `json:"favorite_count"`
	Tags             interface{}      `json:"tags"`
	TrainingMentors  interface{}      `json:"training_mentors"`
	TrainingStudents interface{}      `json:"training_students"`
}

// TODO: add filter by is private
func (q *Queries) GetTrainingList(ctx context.Context, trainingName pgtype.Text) ([]GetTrainingListRow, error) {
	rows, err := q.db.Query(ctx, getTrainingList, trainingName)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTrainingListRow{}
	for rows.Next() {
		var i GetTrainingListRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.IsPrivate,
			&i.OwnerUuid,
			&i.UpdatedAt,
			&i.FavoriteCount,
			&i.Tags,
			&i.TrainingMentors,
			&i.TrainingStudents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTraining = `-- name: UpdateTraining :one
UPDATE trainings
SET 
    name = coalesce($1, name),
    description = coalesce($2, description),
    is_private = coalesce($3, is_private)
WHERE trainings.uuid = $4
RETURNING uuid, name, description, is_private, updated_at, created_at, owner_uuid
`

type UpdateTrainingParams struct {
	Name         pgtype.Text `json:"name"`
	Description  pgtype.Text `json:"description"`
	IsPrivate    pgtype.Bool `json:"is_private"`
	TrainingUuid pgtype.UUID `json:"training_uuid"`
}

func (q *Queries) UpdateTraining(ctx context.Context, arg UpdateTrainingParams) (Training, error) {
	row := q.db.QueryRow(ctx, updateTraining,
		arg.Name,
		arg.Description,
		arg.IsPrivate,
		arg.TrainingUuid,
	)
	var i Training
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.IsPrivate,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.OwnerUuid,
	)
	return i, err
}
