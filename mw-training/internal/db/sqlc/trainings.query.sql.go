// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: trainings.query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTrainings = `-- name: CountTrainings :one
SELECT
    COUNT(*)
FROM
    trainings
WHERE
    (LOWER(trainings.name) LIKE '%' || LOWER($1) || '%' OR $1 = '')
    AND
    trainings.is_private = false
`

func (q *Queries) CountTrainings(ctx context.Context, trainingName string) (int64, error) {
	row := q.db.QueryRow(ctx, countTrainings, trainingName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTraining = `-- name: CreateTraining :one
INSERT INTO trainings (
    name,
    description,
    owner_uuid,
    is_private
) VALUES (
    $1,
    $2,
    $3,
    $4
) RETURNING uuid, name, description, is_private, updated_at, created_at, owner_uuid
`

type CreateTrainingParams struct {
	Name        string      `json:"name"`
	Description string      `json:"description"`
	OwnerUuid   pgtype.UUID `json:"owner_uuid"`
	IsPrivate   bool        `json:"is_private"`
}

func (q *Queries) CreateTraining(ctx context.Context, arg CreateTrainingParams) (Training, error) {
	row := q.db.QueryRow(ctx, createTraining,
		arg.Name,
		arg.Description,
		arg.OwnerUuid,
		arg.IsPrivate,
	)
	var i Training
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.IsPrivate,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.OwnerUuid,
	)
	return i, err
}

const deleteTraining = `-- name: DeleteTraining :exec
DELETE FROM trainings
WHERE trainings.uuid = $1
`

func (q *Queries) DeleteTraining(ctx context.Context, trainingUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTraining, trainingUuid)
	return err
}

const getFavoriteTrainingList = `-- name: GetFavoriteTrainingList :many
SELECT
    -- TODO: add filter by is private
    trainings.uuid,
    trainings.name,
    trainings.description,
    trainings.owner_uuid,
    trainings.created_at,
    trainings.updated_at,
    COALESCE(f.favorite_count, 0) AS favorite_count,
    ARRAY_AGG(training_tags.name) FILTER (WHERE training_tags.name IS NOT NULL) AS tags,
    ARRAY_AGG(trainings_mentors.mentor_uuid) AS training_mentors,
    ARRAY_AGG(trainings_students.student_uuid) AS training_students
FROM
    trainings
LEFT JOIN
    favorite_users_trainings ON trainings.uuid = favorite_users_trainings.training_uuid
LEFT JOIN
    training_tags ON training_tags.uuid IN (
        SELECT uuid
        FROM training_tags
        WHERE uuid = trainings.uuid
    )
LEFT JOIN (
    SELECT
        training_uuid,
        COUNT(user_uuid) AS favorite_count
    FROM
        favorite_users_trainings
    GROUP BY
        training_uuid
) f ON f.training_uuid = trainings.uuid
LEFT JOIN
    trainings_mentors ON trainings_mentors.training_uuid = trainings.uuid
LEFT JOIN
    trainings_students ON trainings_students.training_uuid = trainings.uuid
WHERE
    favorite_users_trainings.user_uuid = $1
    AND
    trainings.is_private = false
GROUP BY
    trainings.uuid, trainings.name, trainings.is_private, trainings.owner_uuid, trainings.updated_at, f.favorite_count
ORDER BY
    trainings.updated_at DESC
`

type GetFavoriteTrainingListRow struct {
	Uuid             pgtype.UUID      `json:"uuid"`
	Name             string           `json:"name"`
	Description      string           `json:"description"`
	OwnerUuid        pgtype.UUID      `json:"owner_uuid"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	FavoriteCount    int64            `json:"favorite_count"`
	Tags             interface{}      `json:"tags"`
	TrainingMentors  interface{}      `json:"training_mentors"`
	TrainingStudents interface{}      `json:"training_students"`
}

// lets add likes to response
func (q *Queries) GetFavoriteTrainingList(ctx context.Context, userUuid pgtype.UUID) ([]GetFavoriteTrainingListRow, error) {
	rows, err := q.db.Query(ctx, getFavoriteTrainingList, userUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetFavoriteTrainingListRow{}
	for rows.Next() {
		var i GetFavoriteTrainingListRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.OwnerUuid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FavoriteCount,
			&i.Tags,
			&i.TrainingMentors,
			&i.TrainingStudents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMentoringTrainingList = `-- name: GetMentoringTrainingList :many
SELECT
    -- TODO: add filter by is private
    trainings.uuid,
    trainings.name,
    trainings.description,
    trainings.owner_uuid,
    trainings.created_at,
    trainings.updated_at,
    COALESCE(f.favorite_count, 0) AS favorite_count,
    ARRAY_AGG(training_tags.name) FILTER (WHERE training_tags.name IS NOT NULL) AS tags,
    ARRAY_AGG(trainings_mentors.mentor_uuid) AS training_mentors,
    ARRAY_AGG(trainings_students.student_uuid) AS training_students
FROM
    trainings
LEFT JOIN
    favorite_users_trainings ON trainings.uuid = favorite_users_trainings.training_uuid
LEFT JOIN
    training_tags ON training_tags.uuid IN (
        SELECT uuid
        FROM training_tags
        WHERE uuid = trainings.uuid
    )
LEFT JOIN (
    SELECT
        training_uuid,
        COUNT(user_uuid) AS favorite_count
    FROM
        favorite_users_trainings
    GROUP BY
        training_uuid
) f ON f.training_uuid = trainings.uuid
LEFT JOIN
    trainings_mentors ON trainings_mentors.training_uuid = trainings.uuid
LEFT JOIN
    trainings_students ON trainings_students.training_uuid = trainings.uuid
WHERE
    trainings_mentors.mentor_uuid = $1
    AND
    trainings.is_private = false
GROUP BY
    trainings.uuid, trainings.name, trainings.is_private, trainings.owner_uuid, trainings.updated_at, f.favorite_count
ORDER BY
    trainings.updated_at DESC
`

type GetMentoringTrainingListRow struct {
	Uuid             pgtype.UUID      `json:"uuid"`
	Name             string           `json:"name"`
	Description      string           `json:"description"`
	OwnerUuid        pgtype.UUID      `json:"owner_uuid"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	FavoriteCount    int64            `json:"favorite_count"`
	Tags             interface{}      `json:"tags"`
	TrainingMentors  interface{}      `json:"training_mentors"`
	TrainingStudents interface{}      `json:"training_students"`
}

// lets add likes to response
func (q *Queries) GetMentoringTrainingList(ctx context.Context, userUuid pgtype.UUID) ([]GetMentoringTrainingListRow, error) {
	rows, err := q.db.Query(ctx, getMentoringTrainingList, userUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetMentoringTrainingListRow{}
	for rows.Next() {
		var i GetMentoringTrainingListRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.OwnerUuid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FavoriteCount,
			&i.Tags,
			&i.TrainingMentors,
			&i.TrainingStudents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getOwnTrainingList = `-- name: GetOwnTrainingList :many
SELECT
    -- TODO: add filter by is private
    trainings.uuid,
    trainings.name,
    trainings.description,
    trainings.owner_uuid,
    trainings.created_at,
    trainings.updated_at,
    COALESCE(f.favorite_count, 0) AS favorite_count,
    ARRAY_AGG(training_tags.name) FILTER (WHERE training_tags.name IS NOT NULL) AS tags,
    ARRAY_AGG(trainings_mentors.mentor_uuid) AS training_mentors,
    ARRAY_AGG(trainings_students.student_uuid) AS training_students
FROM
    trainings
LEFT JOIN
    favorite_users_trainings ON trainings.uuid = favorite_users_trainings.training_uuid
LEFT JOIN
    training_tags ON training_tags.uuid IN (
        SELECT uuid
        FROM training_tags
        WHERE uuid = trainings.uuid
    )
LEFT JOIN (
    SELECT
        training_uuid,
        COUNT(user_uuid) AS favorite_count
    FROM
        favorite_users_trainings
    GROUP BY
        training_uuid
) f ON f.training_uuid = trainings.uuid
LEFT JOIN
    trainings_mentors ON trainings_mentors.training_uuid = trainings.uuid
LEFT JOIN
    trainings_students ON trainings_students.training_uuid = trainings.uuid
WHERE
    trainings.owner_uuid = $1
    AND
    trainings.is_private = false
GROUP BY
    trainings.uuid, trainings.name, trainings.is_private, trainings.owner_uuid, trainings.updated_at, f.favorite_count
ORDER BY
    trainings.updated_at DESC
`

type GetOwnTrainingListRow struct {
	Uuid             pgtype.UUID      `json:"uuid"`
	Name             string           `json:"name"`
	Description      string           `json:"description"`
	OwnerUuid        pgtype.UUID      `json:"owner_uuid"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	FavoriteCount    int64            `json:"favorite_count"`
	Tags             interface{}      `json:"tags"`
	TrainingMentors  interface{}      `json:"training_mentors"`
	TrainingStudents interface{}      `json:"training_students"`
}

// lets add likes to response
func (q *Queries) GetOwnTrainingList(ctx context.Context, userUuid pgtype.UUID) ([]GetOwnTrainingListRow, error) {
	rows, err := q.db.Query(ctx, getOwnTrainingList, userUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetOwnTrainingListRow{}
	for rows.Next() {
		var i GetOwnTrainingListRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.OwnerUuid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FavoriteCount,
			&i.Tags,
			&i.TrainingMentors,
			&i.TrainingStudents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStudentTrainingList = `-- name: GetStudentTrainingList :many
SELECT
    -- TODO: add filter by is private
    trainings.uuid,
    trainings.name,
    trainings.description,
    trainings.owner_uuid,
    trainings.created_at,
    trainings.updated_at,
    COALESCE(f.favorite_count, 0) AS favorite_count,
    ARRAY_AGG(training_tags.name) FILTER (WHERE training_tags.name IS NOT NULL) AS tags,
    ARRAY_AGG(trainings_mentors.mentor_uuid) AS training_mentors,
    ARRAY_AGG(trainings_students.student_uuid) AS training_students
FROM
    trainings
LEFT JOIN
    favorite_users_trainings ON trainings.uuid = favorite_users_trainings.training_uuid
LEFT JOIN
    training_tags ON training_tags.uuid IN (
        SELECT uuid
        FROM training_tags
        WHERE uuid = trainings.uuid
    )
LEFT JOIN (
    SELECT
        training_uuid,
        COUNT(user_uuid) AS favorite_count
    FROM
        favorite_users_trainings
    GROUP BY
        training_uuid
) f ON f.training_uuid = trainings.uuid
LEFT JOIN
    trainings_mentors ON trainings_mentors.training_uuid = trainings.uuid
LEFT JOIN
    trainings_students ON trainings_students.training_uuid = trainings.uuid
WHERE
    trainings_students.student_uuid = $1
    AND
    trainings.is_private = false
GROUP BY
    trainings.uuid, trainings.name, trainings.is_private, trainings.owner_uuid, trainings.updated_at, f.favorite_count
ORDER BY
    trainings.updated_at DESC
`

type GetStudentTrainingListRow struct {
	Uuid             pgtype.UUID      `json:"uuid"`
	Name             string           `json:"name"`
	Description      string           `json:"description"`
	OwnerUuid        pgtype.UUID      `json:"owner_uuid"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	FavoriteCount    int64            `json:"favorite_count"`
	Tags             interface{}      `json:"tags"`
	TrainingMentors  interface{}      `json:"training_mentors"`
	TrainingStudents interface{}      `json:"training_students"`
}

// lets add likes to response
func (q *Queries) GetStudentTrainingList(ctx context.Context, userUuid pgtype.UUID) ([]GetStudentTrainingListRow, error) {
	rows, err := q.db.Query(ctx, getStudentTrainingList, userUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetStudentTrainingListRow{}
	for rows.Next() {
		var i GetStudentTrainingListRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.OwnerUuid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.FavoriteCount,
			&i.Tags,
			&i.TrainingMentors,
			&i.TrainingStudents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrainingById = `-- name: GetTrainingById :one
SELECT
    uuid, name, description, is_private, updated_at, created_at, owner_uuid
FROM trainings
WHERE trainings.uuid = $1
`

func (q *Queries) GetTrainingById(ctx context.Context, trainingUuid pgtype.UUID) (Training, error) {
	row := q.db.QueryRow(ctx, getTrainingById, trainingUuid)
	var i Training
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.IsPrivate,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.OwnerUuid,
	)
	return i, err
}

const getTrainingList = `-- name: GetTrainingList :many
SELECT
    -- TODO: add filter by is private
    trainings.uuid,
    trainings.name,
    trainings.description,
    trainings.owner_uuid,
    trainings.created_at,
    trainings.updated_at,
    trainings.is_private,
    COALESCE(f.favorite_count, 0) AS favorite_count,
    ARRAY_AGG(training_tags.name) FILTER (WHERE training_tags.name IS NOT NULL)::VARCHAR[] AS tags,
    ARRAY_AGG(trainings_mentors.mentor_uuid) FILTER (WHERE trainings_mentors.mentor_uuid IS NOT NULL)::UUID[] AS training_mentors,
    ARRAY_AGG(trainings_students.student_uuid) FILTER (WHERE trainings_students.student_uuid IS NOT NULL)::UUID[] AS training_students
FROM
    trainings
LEFT JOIN
    favorite_users_trainings ON trainings.uuid = favorite_users_trainings.training_uuid
LEFT JOIN
    training_tags ON training_tags.uuid IN (
        SELECT uuid
        FROM training_tags
        WHERE uuid = trainings.uuid
    )
LEFT JOIN (
    SELECT
        training_uuid,
        COUNT(user_uuid) AS favorite_count
    FROM
        favorite_users_trainings
    GROUP BY
        training_uuid
) f ON f.training_uuid = trainings.uuid
LEFT JOIN
    trainings_mentors ON trainings_mentors.training_uuid = trainings.uuid
LEFT JOIN
    trainings_students ON trainings_students.training_uuid = trainings.uuid
WHERE
    (LOWER(trainings.name) LIKE '%' || LOWER($1) || '%' OR $1 = '')
    AND
    trainings.is_private = false
GROUP BY
    trainings.uuid, trainings.name, trainings.is_private, trainings.owner_uuid, trainings.updated_at, f.favorite_count
ORDER BY
    favorite_count DESC,
    trainings.created_at DESC
LIMIT $3
OFFSET $2
`

type GetTrainingListParams struct {
	TrainingName  string `json:"training_name"`
	RequestOffset int32  `json:"request_offset"`
	RequestLimit  int32  `json:"request_limit"`
}

type GetTrainingListRow struct {
	Uuid             pgtype.UUID      `json:"uuid"`
	Name             string           `json:"name"`
	Description      string           `json:"description"`
	OwnerUuid        pgtype.UUID      `json:"owner_uuid"`
	CreatedAt        pgtype.Timestamp `json:"created_at"`
	UpdatedAt        pgtype.Timestamp `json:"updated_at"`
	IsPrivate        bool             `json:"is_private"`
	FavoriteCount    int64            `json:"favorite_count"`
	Tags             []string         `json:"tags"`
	TrainingMentors  []pgtype.UUID    `json:"training_mentors"`
	TrainingStudents []pgtype.UUID    `json:"training_students"`
}

// lets add likes to response
func (q *Queries) GetTrainingList(ctx context.Context, arg GetTrainingListParams) ([]GetTrainingListRow, error) {
	rows, err := q.db.Query(ctx, getTrainingList, arg.TrainingName, arg.RequestOffset, arg.RequestLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTrainingListRow{}
	for rows.Next() {
		var i GetTrainingListRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.OwnerUuid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPrivate,
			&i.FavoriteCount,
			&i.Tags,
			&i.TrainingMentors,
			&i.TrainingStudents,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrainingsAmountByUserId = `-- name: GetTrainingsAmountByUserId :one
SELECT    
    (SELECT COUNT(*) FROM trainings WHERE trainings.owner_uuid = $1) AS owner,
    (SELECT COUNT(*) FROM trainings_mentors WHERE trainings_mentors.mentor_uuid = $1) AS mentor,
    (SELECT COUNT(*) FROM trainings_students WHERE trainings_students.student_uuid = $1) AS student,
    (SELECT COUNT(*) FROM favorite_users_trainings WHERE favorite_users_trainings.user_uuid = $1) AS favorite
FROM trainings
`

type GetTrainingsAmountByUserIdRow struct {
	Owner    int64 `json:"owner"`
	Mentor   int64 `json:"mentor"`
	Student  int64 `json:"student"`
	Favorite int64 `json:"favorite"`
}

func (q *Queries) GetTrainingsAmountByUserId(ctx context.Context, userUuid pgtype.UUID) (GetTrainingsAmountByUserIdRow, error) {
	row := q.db.QueryRow(ctx, getTrainingsAmountByUserId, userUuid)
	var i GetTrainingsAmountByUserIdRow
	err := row.Scan(
		&i.Owner,
		&i.Mentor,
		&i.Student,
		&i.Favorite,
	)
	return i, err
}

const updateTraining = `-- name: UpdateTraining :one
UPDATE trainings
SET 
    name = coalesce($1, name),
    description = coalesce($2, description),
    is_private = coalesce($3, is_private)
WHERE trainings.uuid = $4
RETURNING uuid, name, description, is_private, updated_at, created_at, owner_uuid
`

type UpdateTrainingParams struct {
	Name         pgtype.Text `json:"name"`
	Description  pgtype.Text `json:"description"`
	IsPrivate    pgtype.Bool `json:"is_private"`
	TrainingUuid pgtype.UUID `json:"training_uuid"`
}

func (q *Queries) UpdateTraining(ctx context.Context, arg UpdateTrainingParams) (Training, error) {
	row := q.db.QueryRow(ctx, updateTraining,
		arg.Name,
		arg.Description,
		arg.IsPrivate,
		arg.TrainingUuid,
	)
	var i Training
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.IsPrivate,
		&i.UpdatedAt,
		&i.CreatedAt,
		&i.OwnerUuid,
	)
	return i, err
}
