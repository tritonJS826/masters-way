// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: questions.query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countQuestionsByTestId = `-- name: CountQuestionsByTestId :one
SELECT
    COUNT(*)
FROM
    questions
WHERE
    questions.test_uuid = $1
    AND ($2::boolean = true OR questions.is_active = true)
`

type CountQuestionsByTestIdParams struct {
	TestUuid        pgtype.UUID `json:"test_uuid"`
	IncludeInactive bool        `json:"include_inactive"`
}

func (q *Queries) CountQuestionsByTestId(ctx context.Context, arg CountQuestionsByTestIdParams) (int64, error) {
	row := q.db.QueryRow(ctx, countQuestionsByTestId, arg.TestUuid, arg.IncludeInactive)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createQuestion = `-- name: CreateQuestion :one
INSERT INTO questions (
    test_uuid,
    name,
    practice_type,
    question_text,
    question_order,
    time_to_answer,
    answer,
    is_active,
    is_private
) VALUES (
    $1,
    $2,
    $3,
    $4,
    (SELECT COALESCE(MAX(question_order), 0) + 1 FROM questions WHERE test_uuid = $1),
    $5,
    $6,
    $7,
    $8
) RETURNING uuid, name, practice_type, test_uuid, question_text, question_order, time_to_answer, answer, is_active, is_private, created_at, updated_at
`

type CreateQuestionParams struct {
	TestUuid     pgtype.UUID  `json:"test_uuid"`
	Name         pgtype.Text  `json:"name"`
	PracticeType PracticeType `json:"practice_type"`
	QuestionText string       `json:"question_text"`
	TimeToAnswer int32        `json:"time_to_answer"`
	Answer       string       `json:"answer"`
	IsActive     bool         `json:"is_active"`
	IsPrivate    bool         `json:"is_private"`
}

func (q *Queries) CreateQuestion(ctx context.Context, arg CreateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, createQuestion,
		arg.TestUuid,
		arg.Name,
		arg.PracticeType,
		arg.QuestionText,
		arg.TimeToAnswer,
		arg.Answer,
		arg.IsActive,
		arg.IsPrivate,
	)
	var i Question
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.PracticeType,
		&i.TestUuid,
		&i.QuestionText,
		&i.QuestionOrder,
		&i.TimeToAnswer,
		&i.Answer,
		&i.IsActive,
		&i.IsPrivate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deactivateQuestion = `-- name: DeactivateQuestion :one
UPDATE questions
SET 
    is_active = false,
    updated_at = CURRENT_TIMESTAMP
WHERE questions.uuid = $1
RETURNING uuid, name, practice_type, test_uuid, question_text, question_order, time_to_answer, answer, is_active, is_private, created_at, updated_at
`

func (q *Queries) DeactivateQuestion(ctx context.Context, questionUuid pgtype.UUID) (Question, error) {
	row := q.db.QueryRow(ctx, deactivateQuestion, questionUuid)
	var i Question
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.PracticeType,
		&i.TestUuid,
		&i.QuestionText,
		&i.QuestionOrder,
		&i.TimeToAnswer,
		&i.Answer,
		&i.IsActive,
		&i.IsPrivate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteQuestion = `-- name: DeleteQuestion :exec
WITH deleted_question AS (
    DELETE FROM questions
    WHERE questions.uuid = $1
    RETURNING test_uuid, question_order
)
UPDATE questions
SET question_order = questions.question_order - 1
FROM deleted_question
WHERE questions.test_uuid = deleted_question.test_uuid
  AND questions.question_order > deleted_question.question_order
`

func (q *Queries) DeleteQuestion(ctx context.Context, questionUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteQuestion, questionUuid)
	return err
}

const getActiveQuestionsByTestId = `-- name: GetActiveQuestionsByTestId :many
SELECT
    questions.uuid,
    questions.name,
    practice_type,
    questions.test_uuid,
    questions.question_text,
    questions.question_order,
    questions.time_to_answer,
    questions.is_active,
    questions.is_private,
    questions.created_at,
    questions.updated_at
FROM
    questions
WHERE
    questions.test_uuid = $1
    AND questions.is_active = true
    AND ($2::boolean = true OR questions.is_private = false)
ORDER BY
    questions.question_order ASC,
    questions.created_at ASC
`

type GetActiveQuestionsByTestIdParams struct {
	TestUuid       pgtype.UUID `json:"test_uuid"`
	IncludePrivate bool        `json:"include_private"`
}

type GetActiveQuestionsByTestIdRow struct {
	Uuid          pgtype.UUID      `json:"uuid"`
	Name          pgtype.Text      `json:"name"`
	PracticeType  PracticeType     `json:"practice_type"`
	TestUuid      pgtype.UUID      `json:"test_uuid"`
	QuestionText  string           `json:"question_text"`
	QuestionOrder int32            `json:"question_order"`
	TimeToAnswer  int32            `json:"time_to_answer"`
	IsActive      bool             `json:"is_active"`
	IsPrivate     bool             `json:"is_private"`
	CreatedAt     pgtype.Timestamp `json:"created_at"`
	UpdatedAt     pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) GetActiveQuestionsByTestId(ctx context.Context, arg GetActiveQuestionsByTestIdParams) ([]GetActiveQuestionsByTestIdRow, error) {
	rows, err := q.db.Query(ctx, getActiveQuestionsByTestId, arg.TestUuid, arg.IncludePrivate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetActiveQuestionsByTestIdRow{}
	for rows.Next() {
		var i GetActiveQuestionsByTestIdRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.PracticeType,
			&i.TestUuid,
			&i.QuestionText,
			&i.QuestionOrder,
			&i.TimeToAnswer,
			&i.IsActive,
			&i.IsPrivate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getQuestionById = `-- name: GetQuestionById :one
SELECT
    uuid, name, practice_type, test_uuid, question_text, question_order, time_to_answer, answer, is_active, is_private, created_at, updated_at
FROM questions
WHERE questions.uuid = $1
`

func (q *Queries) GetQuestionById(ctx context.Context, questionUuid pgtype.UUID) (Question, error) {
	row := q.db.QueryRow(ctx, getQuestionById, questionUuid)
	var i Question
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.PracticeType,
		&i.TestUuid,
		&i.QuestionText,
		&i.QuestionOrder,
		&i.TimeToAnswer,
		&i.Answer,
		&i.IsActive,
		&i.IsPrivate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getQuestionsByTestId = `-- name: GetQuestionsByTestId :many
SELECT
    questions.uuid,
    questions.name,
    practice_type,
    questions.test_uuid,
    questions.question_text,
    questions.question_order,
    questions.time_to_answer,
    questions.answer,
    questions.is_active,
    questions.is_private,
    questions.created_at,
    questions.updated_at
FROM
    questions
WHERE
    questions.test_uuid = $1
    AND ($2::boolean = true OR questions.is_active = true)
    AND ($3::boolean = true OR questions.is_private = false)
ORDER BY
    questions.question_order ASC,
    questions.created_at ASC
`

type GetQuestionsByTestIdParams struct {
	TestUuid        pgtype.UUID `json:"test_uuid"`
	IncludeInactive bool        `json:"include_inactive"`
	IncludePrivate  bool        `json:"include_private"`
}

func (q *Queries) GetQuestionsByTestId(ctx context.Context, arg GetQuestionsByTestIdParams) ([]Question, error) {
	rows, err := q.db.Query(ctx, getQuestionsByTestId, arg.TestUuid, arg.IncludeInactive, arg.IncludePrivate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Question{}
	for rows.Next() {
		var i Question
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.PracticeType,
			&i.TestUuid,
			&i.QuestionText,
			&i.QuestionOrder,
			&i.TimeToAnswer,
			&i.Answer,
			&i.IsActive,
			&i.IsPrivate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const reorderQuestions = `-- name: ReorderQuestions :exec
UPDATE questions
SET question_order = $1,
    updated_at = CURRENT_TIMESTAMP
WHERE questions.uuid = $2
`

type ReorderQuestionsParams struct {
	NewOrder     int32       `json:"new_order"`
	QuestionUuid pgtype.UUID `json:"question_uuid"`
}

func (q *Queries) ReorderQuestions(ctx context.Context, arg ReorderQuestionsParams) error {
	_, err := q.db.Exec(ctx, reorderQuestions, arg.NewOrder, arg.QuestionUuid)
	return err
}

const updateQuestion = `-- name: UpdateQuestion :one
UPDATE questions
SET 
    name = coalesce($1, name),
    practice_type = coalesce($2, practice_type),
    question_text = coalesce($3, question_text),
    question_order = coalesce($4, question_order),
    time_to_answer = coalesce($5, time_to_answer),
    answer = coalesce($6, answer),
    is_active = coalesce($7, is_active),
    is_private = coalesce($8, is_private),
    updated_at = CURRENT_TIMESTAMP
WHERE questions.uuid = $9
RETURNING uuid, name, practice_type, test_uuid, question_text, question_order, time_to_answer, answer, is_active, is_private, created_at, updated_at
`

type UpdateQuestionParams struct {
	Name          pgtype.Text      `json:"name"`
	PracticeType  NullPracticeType `json:"practice_type"`
	QuestionText  pgtype.Text      `json:"question_text"`
	QuestionOrder pgtype.Int4      `json:"question_order"`
	TimeToAnswer  pgtype.Int4      `json:"time_to_answer"`
	Answer        pgtype.Text      `json:"answer"`
	IsActive      pgtype.Bool      `json:"is_active"`
	IsPrivate     pgtype.Bool      `json:"is_private"`
	QuestionUuid  pgtype.UUID      `json:"question_uuid"`
}

func (q *Queries) UpdateQuestion(ctx context.Context, arg UpdateQuestionParams) (Question, error) {
	row := q.db.QueryRow(ctx, updateQuestion,
		arg.Name,
		arg.PracticeType,
		arg.QuestionText,
		arg.QuestionOrder,
		arg.TimeToAnswer,
		arg.Answer,
		arg.IsActive,
		arg.IsPrivate,
		arg.QuestionUuid,
	)
	var i Question
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.PracticeType,
		&i.TestUuid,
		&i.QuestionText,
		&i.QuestionOrder,
		&i.TimeToAnswer,
		&i.Answer,
		&i.IsActive,
		&i.IsPrivate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
