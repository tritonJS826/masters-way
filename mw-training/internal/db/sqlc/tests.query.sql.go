// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tests.query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countPublicTests = `-- name: CountPublicTests :one
SELECT
    COUNT(*)
FROM
    tests
WHERE
    tests.is_private = false
    AND (LOWER(tests.name) LIKE '%' || LOWER($1) || '%' OR $1 = '')
`

func (q *Queries) CountPublicTests(ctx context.Context, testName string) (int64, error) {
	row := q.db.QueryRow(ctx, countPublicTests, testName)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTest = `-- name: CreateTest :one
INSERT INTO tests (
    name,
    description,
    owner_uuid,
    is_private
) VALUES (
    $1,
    $2,
    $3,
    $4
) RETURNING uuid, name, description, is_private, owner_uuid, updated_at, created_at
`

type CreateTestParams struct {
	Name        string      `json:"name"`
	Description string      `json:"description"`
	OwnerUuid   pgtype.UUID `json:"owner_uuid"`
	IsPrivate   bool        `json:"is_private"`
}

func (q *Queries) CreateTest(ctx context.Context, arg CreateTestParams) (Test, error) {
	row := q.db.QueryRow(ctx, createTest,
		arg.Name,
		arg.Description,
		arg.OwnerUuid,
		arg.IsPrivate,
	)
	var i Test
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.IsPrivate,
		&i.OwnerUuid,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}

const deleteTest = `-- name: DeleteTest :exec
DELETE FROM tests
WHERE tests.uuid = $1
`

func (q *Queries) DeleteTest(ctx context.Context, testUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTest, testUuid)
	return err
}

const getPublicTests = `-- name: GetPublicTests :many
SELECT
    tests.uuid,
    tests.name,
    tests.description,
    tests.owner_uuid,
    tests.created_at,
    tests.updated_at,
    tests.is_private,
    COUNT(DISTINCT questions.uuid) FILTER (WHERE questions.uuid IS NOT NULL) AS questions_count
FROM
    tests
LEFT JOIN
    questions ON questions.test_uuid = tests.uuid AND questions.is_active = true
WHERE
    tests.is_private = false
    AND (LOWER(tests.name) LIKE '%' || LOWER($1) || '%' OR $1 = '')
GROUP BY
    tests.uuid, tests.name, tests.description, tests.owner_uuid, tests.created_at, tests.updated_at, tests.is_private
ORDER BY
    tests.created_at DESC
LIMIT $3
OFFSET $2
`

type GetPublicTestsParams struct {
	TestName      string `json:"test_name"`
	RequestOffset int32  `json:"request_offset"`
	RequestLimit  int32  `json:"request_limit"`
}

type GetPublicTestsRow struct {
	Uuid           pgtype.UUID      `json:"uuid"`
	Name           string           `json:"name"`
	Description    string           `json:"description"`
	OwnerUuid      pgtype.UUID      `json:"owner_uuid"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	IsPrivate      bool             `json:"is_private"`
	QuestionsCount int64            `json:"questions_count"`
}

func (q *Queries) GetPublicTests(ctx context.Context, arg GetPublicTestsParams) ([]GetPublicTestsRow, error) {
	rows, err := q.db.Query(ctx, getPublicTests, arg.TestName, arg.RequestOffset, arg.RequestLimit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetPublicTestsRow{}
	for rows.Next() {
		var i GetPublicTestsRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.OwnerUuid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPrivate,
			&i.QuestionsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestById = `-- name: GetTestById :one
SELECT
    tests.uuid,
    tests.name,
    tests.description,
    tests.owner_uuid,
    tests.created_at,
    tests.updated_at,
    tests.is_private,
    COUNT(DISTINCT questions.uuid) FILTER (WHERE questions.uuid IS NOT NULL) AS questions_count
FROM
    tests
LEFT JOIN
    questions ON questions.test_uuid = tests.uuid AND questions.is_active = true
WHERE
    tests.uuid = $1
GROUP BY
    tests.uuid, tests.name, tests.description, tests.owner_uuid, tests.created_at, tests.updated_at, tests.is_private
`

type GetTestByIdRow struct {
	Uuid           pgtype.UUID      `json:"uuid"`
	Name           string           `json:"name"`
	Description    string           `json:"description"`
	OwnerUuid      pgtype.UUID      `json:"owner_uuid"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	IsPrivate      bool             `json:"is_private"`
	QuestionsCount int64            `json:"questions_count"`
}

func (q *Queries) GetTestById(ctx context.Context, testUuid pgtype.UUID) (GetTestByIdRow, error) {
	row := q.db.QueryRow(ctx, getTestById, testUuid)
	var i GetTestByIdRow
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.OwnerUuid,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsPrivate,
		&i.QuestionsCount,
	)
	return i, err
}

const getTestsByOwner = `-- name: GetTestsByOwner :many
SELECT
    tests.uuid,
    tests.name,
    tests.description,
    tests.owner_uuid,
    tests.created_at,
    tests.updated_at,
    tests.is_private,
    COUNT(DISTINCT questions.uuid) FILTER (WHERE questions.uuid IS NOT NULL) AS questions_count
FROM
    tests
LEFT JOIN
    questions ON questions.test_uuid = tests.uuid AND questions.is_active = true
WHERE
    tests.owner_uuid = $1
    AND ($2::boolean = true OR tests.is_private = false)
GROUP BY
    tests.uuid, tests.name, tests.description, tests.owner_uuid, tests.created_at, tests.updated_at, tests.is_private
ORDER BY
    tests.updated_at DESC
`

type GetTestsByOwnerParams struct {
	OwnerUuid      pgtype.UUID `json:"owner_uuid"`
	IncludePrivate bool        `json:"include_private"`
}

type GetTestsByOwnerRow struct {
	Uuid           pgtype.UUID      `json:"uuid"`
	Name           string           `json:"name"`
	Description    string           `json:"description"`
	OwnerUuid      pgtype.UUID      `json:"owner_uuid"`
	CreatedAt      pgtype.Timestamp `json:"created_at"`
	UpdatedAt      pgtype.Timestamp `json:"updated_at"`
	IsPrivate      bool             `json:"is_private"`
	QuestionsCount int64            `json:"questions_count"`
}

func (q *Queries) GetTestsByOwner(ctx context.Context, arg GetTestsByOwnerParams) ([]GetTestsByOwnerRow, error) {
	rows, err := q.db.Query(ctx, getTestsByOwner, arg.OwnerUuid, arg.IncludePrivate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTestsByOwnerRow{}
	for rows.Next() {
		var i GetTestsByOwnerRow
		if err := rows.Scan(
			&i.Uuid,
			&i.Name,
			&i.Description,
			&i.OwnerUuid,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsPrivate,
			&i.QuestionsCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTest = `-- name: UpdateTest :one
UPDATE tests
SET 
    name = coalesce($1, name),
    description = coalesce($2, description),
    is_private = coalesce($3, is_private),
    updated_at = CURRENT_TIMESTAMP
WHERE tests.uuid = $4
RETURNING uuid, name, description, is_private, owner_uuid, updated_at, created_at
`

type UpdateTestParams struct {
	Name        pgtype.Text `json:"name"`
	Description pgtype.Text `json:"description"`
	IsPrivate   pgtype.Bool `json:"is_private"`
	TestUuid    pgtype.UUID `json:"test_uuid"`
}

func (q *Queries) UpdateTest(ctx context.Context, arg UpdateTestParams) (Test, error) {
	row := q.db.QueryRow(ctx, updateTest,
		arg.Name,
		arg.Description,
		arg.IsPrivate,
		arg.TestUuid,
	)
	var i Test
	err := row.Scan(
		&i.Uuid,
		&i.Name,
		&i.Description,
		&i.IsPrivate,
		&i.OwnerUuid,
		&i.UpdatedAt,
		&i.CreatedAt,
	)
	return i, err
}
