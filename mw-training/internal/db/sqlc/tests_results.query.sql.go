// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: tests_results.query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countTestAttempts = `-- name: CountTestAttempts :one
SELECT
    COUNT(*) AS total_attempts,
    COUNT(DISTINCT user_uuid) AS unique_users
FROM
    test_session_results
WHERE
    test_session_results.test_uuid = $1
`

type CountTestAttemptsRow struct {
	TotalAttempts int64 `json:"total_attempts"`
	UniqueUsers   int64 `json:"unique_users"`
}

func (q *Queries) CountTestAttempts(ctx context.Context, testUuid pgtype.UUID) (CountTestAttemptsRow, error) {
	row := q.db.QueryRow(ctx, countTestAttempts, testUuid)
	var i CountTestAttemptsRow
	err := row.Scan(&i.TotalAttempts, &i.UniqueUsers)
	return i, err
}

const createTestSessionResult = `-- name: CreateTestSessionResult :one
INSERT INTO test_session_results (
    test_uuid,
    session_uuid,
    user_uuid,
    result_description
) VALUES (
    $1,
    $2,
    $3,
    $4
) RETURNING uuid, test_uuid, session_uuid, user_uuid, result_description, created_at
`

type CreateTestSessionResultParams struct {
	TestUuid          pgtype.UUID `json:"test_uuid"`
	SessionUuid       pgtype.UUID `json:"session_uuid"`
	UserUuid          pgtype.UUID `json:"user_uuid"`
	ResultDescription string      `json:"result_description"`
}

func (q *Queries) CreateTestSessionResult(ctx context.Context, arg CreateTestSessionResultParams) (TestSessionResult, error) {
	row := q.db.QueryRow(ctx, createTestSessionResult,
		arg.TestUuid,
		arg.SessionUuid,
		arg.UserUuid,
		arg.ResultDescription,
	)
	var i TestSessionResult
	err := row.Scan(
		&i.Uuid,
		&i.TestUuid,
		&i.SessionUuid,
		&i.UserUuid,
		&i.ResultDescription,
		&i.CreatedAt,
	)
	return i, err
}

const deleteTestResult = `-- name: DeleteTestResult :exec
DELETE FROM test_session_results
WHERE test_session_results.uuid = $1
`

func (q *Queries) DeleteTestResult(ctx context.Context, resultUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTestResult, resultUuid)
	return err
}

const deleteTestResultsByTest = `-- name: DeleteTestResultsByTest :exec
DELETE FROM test_session_results
WHERE test_session_results.test_uuid = $1
`

func (q *Queries) DeleteTestResultsByTest(ctx context.Context, testUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTestResultsByTest, testUuid)
	return err
}

const deleteTestResultsByUser = `-- name: DeleteTestResultsByUser :exec
DELETE FROM test_session_results
WHERE test_session_results.user_uuid = $1
`

func (q *Queries) DeleteTestResultsByUser(ctx context.Context, userUuid pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteTestResultsByUser, userUuid)
	return err
}

const getTestAverageScore = `-- name: GetTestAverageScore :one
SELECT
    ROUND(AVG(
        CASE 
            WHEN qr_stats.total_questions > 0 
            THEN (qr_stats.correct_answers::float / qr_stats.total_questions::float) * 100
            ELSE 0
        END
    ), 2) AS average_score
FROM
    test_session_results
LEFT JOIN (
    SELECT
        test_uuid,
        user_uuid,
        COUNT(*) AS total_questions,
        COUNT(*) FILTER (WHERE is_ok = true) AS correct_answers
    FROM
        question_results
    GROUP BY
        test_uuid, user_uuid
) qr_stats ON test_session_results.test_uuid = qr_stats.test_uuid 
    AND test_session_results.user_uuid = qr_stats.user_uuid
WHERE
    test_session_results.test_uuid = $1
`

func (q *Queries) GetTestAverageScore(ctx context.Context, testUuid pgtype.UUID) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getTestAverageScore, testUuid)
	var average_score pgtype.Numeric
	err := row.Scan(&average_score)
	return average_score, err
}

const getTestLeaderboard = `-- name: GetTestLeaderboard :many
SELECT
    test_session_results.user_uuid,
    test_session_results.created_at,
    COALESCE(qr_stats.total_questions, 0) AS total_questions,
    COALESCE(qr_stats.correct_answers, 0) AS correct_answers,
    CASE 
        WHEN COALESCE(qr_stats.total_questions, 0) > 0 
        THEN ROUND((qr_stats.correct_answers::float / qr_stats.total_questions::float) * 100, 2)
        ELSE 0
    END AS score_percentage
FROM
    test_session_results
LEFT JOIN (
    SELECT
        test_uuid,
        user_uuid,
        COUNT(*) AS total_questions,
        COUNT(*) FILTER (WHERE is_ok = true) AS correct_answers
    FROM
        question_results
    GROUP BY
        test_uuid, user_uuid
) qr_stats ON test_session_results.test_uuid = qr_stats.test_uuid 
    AND test_session_results.user_uuid = qr_stats.user_uuid
WHERE
    test_session_results.test_uuid = $1
ORDER BY
    score_percentage DESC,
    test_session_results.created_at ASC
LIMIT $2
`

type GetTestLeaderboardParams struct {
	TestUuid   pgtype.UUID `json:"test_uuid"`
	LimitCount int32       `json:"limit_count"`
}

type GetTestLeaderboardRow struct {
	UserUuid        pgtype.UUID      `json:"user_uuid"`
	CreatedAt       pgtype.Timestamp `json:"created_at"`
	TotalQuestions  int64            `json:"total_questions"`
	CorrectAnswers  int64            `json:"correct_answers"`
	ScorePercentage int32            `json:"score_percentage"`
}

func (q *Queries) GetTestLeaderboard(ctx context.Context, arg GetTestLeaderboardParams) ([]GetTestLeaderboardRow, error) {
	rows, err := q.db.Query(ctx, getTestLeaderboard, arg.TestUuid, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTestLeaderboardRow{}
	for rows.Next() {
		var i GetTestLeaderboardRow
		if err := rows.Scan(
			&i.UserUuid,
			&i.CreatedAt,
			&i.TotalQuestions,
			&i.CorrectAnswers,
			&i.ScorePercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestResultBySessionId = `-- name: GetTestResultBySessionId :one
SELECT
    test_session_results.uuid,
    test_session_results.test_uuid,
    test_session_results.user_uuid,
    test_session_results.result_description,
    test_session_results.created_at
FROM
    test_session_results
WHERE
    test_session_results.session_uuid = $1
`

type GetTestResultBySessionIdRow struct {
	Uuid              pgtype.UUID      `json:"uuid"`
	TestUuid          pgtype.UUID      `json:"test_uuid"`
	UserUuid          pgtype.UUID      `json:"user_uuid"`
	ResultDescription string           `json:"result_description"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetTestResultBySessionId(ctx context.Context, sessionUuid pgtype.UUID) (GetTestResultBySessionIdRow, error) {
	row := q.db.QueryRow(ctx, getTestResultBySessionId, sessionUuid)
	var i GetTestResultBySessionIdRow
	err := row.Scan(
		&i.Uuid,
		&i.TestUuid,
		&i.UserUuid,
		&i.ResultDescription,
		&i.CreatedAt,
	)
	return i, err
}

const getTestResultsByTest = `-- name: GetTestResultsByTest :many
SELECT
    test_session_results.uuid,
    test_session_results.test_uuid,
    test_session_results.user_uuid,
    test_session_results.result_description,
    test_session_results.created_at
FROM
    test_session_results
WHERE
    test_session_results.test_uuid = $1
ORDER BY
    test_session_results.created_at DESC
`

type GetTestResultsByTestRow struct {
	Uuid              pgtype.UUID      `json:"uuid"`
	TestUuid          pgtype.UUID      `json:"test_uuid"`
	UserUuid          pgtype.UUID      `json:"user_uuid"`
	ResultDescription string           `json:"result_description"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetTestResultsByTest(ctx context.Context, testUuid pgtype.UUID) ([]GetTestResultsByTestRow, error) {
	rows, err := q.db.Query(ctx, getTestResultsByTest, testUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTestResultsByTestRow{}
	for rows.Next() {
		var i GetTestResultsByTestRow
		if err := rows.Scan(
			&i.Uuid,
			&i.TestUuid,
			&i.UserUuid,
			&i.ResultDescription,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestResultsByUser = `-- name: GetTestResultsByUser :many
SELECT
    test_session_results.uuid,
    test_session_results.test_uuid,
    test_session_results.user_uuid,
    test_session_results.result_description,
    test_session_results.created_at
FROM
    test_session_results
WHERE
    test_session_results.user_uuid = $1
ORDER BY
    test_session_results.created_at DESC
`

type GetTestResultsByUserRow struct {
	Uuid              pgtype.UUID      `json:"uuid"`
	TestUuid          pgtype.UUID      `json:"test_uuid"`
	UserUuid          pgtype.UUID      `json:"user_uuid"`
	ResultDescription string           `json:"result_description"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetTestResultsByUser(ctx context.Context, userUuid pgtype.UUID) ([]GetTestResultsByUserRow, error) {
	rows, err := q.db.Query(ctx, getTestResultsByUser, userUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTestResultsByUserRow{}
	for rows.Next() {
		var i GetTestResultsByUserRow
		if err := rows.Scan(
			&i.Uuid,
			&i.TestUuid,
			&i.UserUuid,
			&i.ResultDescription,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTestResultsWithStats = `-- name: GetTestResultsWithStats :many
SELECT
    test_session_results.uuid,
    test_session_results.test_uuid,
    test_session_results.user_uuid,
    test_session_results.result_description,
    test_session_results.created_at,
    COALESCE(qr_stats.total_questions, 0) AS total_questions,
    COALESCE(qr_stats.correct_answers, 0) AS correct_answers,
    COALESCE(qr_stats.incorrect_answers, 0) AS incorrect_answers,
    CASE 
        WHEN COALESCE(qr_stats.total_questions, 0) > 0 
        THEN ROUND((qr_stats.correct_answers::float / qr_stats.total_questions::float) * 100, 2)
        ELSE 0
    END AS score_percentage
FROM
    test_session_results
LEFT JOIN (
    SELECT
        test_uuid,
        user_uuid,
        COUNT(*) AS total_questions,
        COUNT(*) FILTER (WHERE is_ok = true) AS correct_answers,
        COUNT(*) FILTER (WHERE is_ok = false) AS incorrect_answers
    FROM
        question_results
    GROUP BY
        test_uuid, user_uuid
) qr_stats ON test_session_results.test_uuid = qr_stats.test_uuid 
    AND test_session_results.user_uuid = qr_stats.user_uuid
WHERE
    test_session_results.test_uuid = $1
ORDER BY
    test_session_results.created_at DESC
`

type GetTestResultsWithStatsRow struct {
	Uuid              pgtype.UUID      `json:"uuid"`
	TestUuid          pgtype.UUID      `json:"test_uuid"`
	UserUuid          pgtype.UUID      `json:"user_uuid"`
	ResultDescription string           `json:"result_description"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	TotalQuestions    int64            `json:"total_questions"`
	CorrectAnswers    int64            `json:"correct_answers"`
	IncorrectAnswers  int64            `json:"incorrect_answers"`
	ScorePercentage   int32            `json:"score_percentage"`
}

func (q *Queries) GetTestResultsWithStats(ctx context.Context, testUuid pgtype.UUID) ([]GetTestResultsWithStatsRow, error) {
	rows, err := q.db.Query(ctx, getTestResultsWithStats, testUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTestResultsWithStatsRow{}
	for rows.Next() {
		var i GetTestResultsWithStatsRow
		if err := rows.Scan(
			&i.Uuid,
			&i.TestUuid,
			&i.UserUuid,
			&i.ResultDescription,
			&i.CreatedAt,
			&i.TotalQuestions,
			&i.CorrectAnswers,
			&i.IncorrectAnswers,
			&i.ScorePercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTestResult = `-- name: GetUserTestResult :one
SELECT
    test_session_results.uuid,
    test_session_results.test_uuid,
    test_session_results.user_uuid,
    test_session_results.result_description,
    test_session_results.created_at
FROM
    test_session_results
WHERE
    test_session_results.user_uuid = $1
    AND test_session_results.test_uuid = $2
ORDER BY
    test_session_results.created_at DESC
LIMIT 1
`

type GetUserTestResultParams struct {
	UserUuid pgtype.UUID `json:"user_uuid"`
	TestUuid pgtype.UUID `json:"test_uuid"`
}

type GetUserTestResultRow struct {
	Uuid              pgtype.UUID      `json:"uuid"`
	TestUuid          pgtype.UUID      `json:"test_uuid"`
	UserUuid          pgtype.UUID      `json:"user_uuid"`
	ResultDescription string           `json:"result_description"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) GetUserTestResult(ctx context.Context, arg GetUserTestResultParams) (GetUserTestResultRow, error) {
	row := q.db.QueryRow(ctx, getUserTestResult, arg.UserUuid, arg.TestUuid)
	var i GetUserTestResultRow
	err := row.Scan(
		&i.Uuid,
		&i.TestUuid,
		&i.UserUuid,
		&i.ResultDescription,
		&i.CreatedAt,
	)
	return i, err
}

const getUserTestResultsWithStats = `-- name: GetUserTestResultsWithStats :many
SELECT
    test_session_results.uuid,
    test_session_results.test_uuid,
    test_session_results.user_uuid,
    test_session_results.result_description,
    test_session_results.created_at,
    COALESCE(qr_stats.total_questions, 0) AS total_questions,
    COALESCE(qr_stats.correct_answers, 0) AS correct_answers,
    COALESCE(qr_stats.incorrect_answers, 0) AS incorrect_answers,
    CASE 
        WHEN COALESCE(qr_stats.total_questions, 0) > 0 
        THEN ROUND((qr_stats.correct_answers::float / qr_stats.total_questions::float) * 100, 2)
        ELSE 0
    END AS score_percentage
FROM
    test_session_results
LEFT JOIN (
    SELECT
        test_uuid,
        user_uuid,
        COUNT(*) AS total_questions,
        COUNT(*) FILTER (WHERE is_ok = true) AS correct_answers,
        COUNT(*) FILTER (WHERE is_ok = false) AS incorrect_answers
    FROM
        question_results
    GROUP BY
        test_uuid, user_uuid
) qr_stats ON test_session_results.test_uuid = qr_stats.test_uuid 
    AND test_session_results.user_uuid = qr_stats.user_uuid
WHERE
    test_session_results.user_uuid = $1
ORDER BY
    test_session_results.created_at DESC
`

type GetUserTestResultsWithStatsRow struct {
	Uuid              pgtype.UUID      `json:"uuid"`
	TestUuid          pgtype.UUID      `json:"test_uuid"`
	UserUuid          pgtype.UUID      `json:"user_uuid"`
	ResultDescription string           `json:"result_description"`
	CreatedAt         pgtype.Timestamp `json:"created_at"`
	TotalQuestions    int64            `json:"total_questions"`
	CorrectAnswers    int64            `json:"correct_answers"`
	IncorrectAnswers  int64            `json:"incorrect_answers"`
	ScorePercentage   int32            `json:"score_percentage"`
}

func (q *Queries) GetUserTestResultsWithStats(ctx context.Context, userUuid pgtype.UUID) ([]GetUserTestResultsWithStatsRow, error) {
	rows, err := q.db.Query(ctx, getUserTestResultsWithStats, userUuid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetUserTestResultsWithStatsRow{}
	for rows.Next() {
		var i GetUserTestResultsWithStatsRow
		if err := rows.Scan(
			&i.Uuid,
			&i.TestUuid,
			&i.UserUuid,
			&i.ResultDescription,
			&i.CreatedAt,
			&i.TotalQuestions,
			&i.CorrectAnswers,
			&i.IncorrectAnswers,
			&i.ScorePercentage,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTestResult = `-- name: UpdateTestResult :one
UPDATE test_session_results
SET 
    result_description = coalesce($1, result_description)
WHERE test_session_results.uuid = $2
RETURNING uuid, test_uuid, session_uuid, user_uuid, result_description, created_at
`

type UpdateTestResultParams struct {
	ResultDescription pgtype.Text `json:"result_description"`
	ResultUuid        pgtype.UUID `json:"result_uuid"`
}

func (q *Queries) UpdateTestResult(ctx context.Context, arg UpdateTestResultParams) (TestSessionResult, error) {
	row := q.db.QueryRow(ctx, updateTestResult, arg.ResultDescription, arg.ResultUuid)
	var i TestSessionResult
	err := row.Scan(
		&i.Uuid,
		&i.TestUuid,
		&i.SessionUuid,
		&i.UserUuid,
		&i.ResultDescription,
		&i.CreatedAt,
	)
	return i, err
}
