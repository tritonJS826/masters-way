package controllers

import (
	"context"

	db "mw-training/internal/db/sqlc"
	services "mw-training/internal/services"
	pb "mw-training/pkg/grpcAutogenerated/training"

	"github.com/jackc/pgx/v5/pgtype"

	"github.com/google/uuid"
	"google.golang.org/protobuf/types/known/emptypb"
)

type QuestionController struct {
	questionService *services.QuestionService
	pb.UnimplementedQuestionServiceServer
}

func NewQuestionController(questionService *services.QuestionService) *QuestionController {
	return &QuestionController{questionService: questionService}
}

func (qc *QuestionController) CreateQuestion(ctx context.Context, in *pb.CreateQuestionRequest) (*pb.Question, error) {
	testUuid := in.GetTestUuid()
	questionText := in.GetQuestionText()
	timeToAnswer := in.GetTimeToAnswer()
	answer := in.GetAnswer()
	name := in.GetName()
	practiceType := in.GetPracticeType()

	// TODO use userUuid for security (check relations)
	// userUuid := in.GetUserUuid()

	arg := db.CreateQuestionParams{
		TestUuid:     pgtype.UUID{Bytes: uuid.MustParse(testUuid), Valid: true},
		QuestionText: questionText,
		TimeToAnswer: timeToAnswer,
		Answer:       answer,
		IsActive:     true,
		IsPrivate:    false,
		Name:         pgtype.Text{String: name, Valid: true},
		PracticeType: db.PracticeType(practiceType),
	}

	question, err := qc.questionService.CreateQuestion(ctx, arg)
	if err != nil {
		return nil, err
	}

	return question, nil
}

func (qc *QuestionController) UpdateQuestion(ctx context.Context, in *pb.UpdateQuestionRequest) (*pb.Question, error) {
	questionUuid := in.GetQuestionUuid()
	name := in.GetName()
	practiceType := in.GetPracticeType()
	questionText := in.GetQuestionText()
	timeToAnswer := in.GetTimeToAnswer()
	answer := in.GetAnswer()
	order := in.GetOrder()

	// TODO use userUuid for security (check relations)
	// userUuid := in.GetUserUuid()

	arg := db.UpdateQuestionParams{
		QuestionUuid:  pgtype.UUID{Bytes: uuid.MustParse(questionUuid), Valid: true},
		Name:          pgtype.Text{String: name, Valid: in.Name != nil},
		PracticeType:  db.NullPracticeType{PracticeType: db.PracticeType(practiceType), Valid: in.PracticeType != nil},
		QuestionText:  pgtype.Text{String: questionText, Valid: in.QuestionText != nil},
		QuestionOrder: pgtype.Int4{Int32: order, Valid: in.Order != nil},
		TimeToAnswer:  pgtype.Int4{Int32: timeToAnswer, Valid: in.TimeToAnswer != nil},
		Answer:        pgtype.Text{String: answer, Valid: in.Answer != nil},
	}
	question, err := qc.questionService.UpdateQuestion(ctx, arg)
	if err != nil {
		return nil, err
	}
	return question, nil
}

func (qc *QuestionController) DeleteQuestion(ctx context.Context, in *pb.DeleteQuestionRequest) (*emptypb.Empty, error) {
	questionUuid := in.GetQuestionUuid()

	err := qc.questionService.DeleteQuestion(ctx, pgtype.UUID{Bytes: uuid.MustParse(questionUuid), Valid: true})
	if err != nil {
		return nil, err
	}

	return &emptypb.Empty{}, nil
}
