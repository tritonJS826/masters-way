package controllers

import (
	"context"

	db "mw-training/internal/db/sqlc"
	services "mw-training/internal/services"
	pb "mw-training/pkg/grpcAutogenerated/training"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
	"google.golang.org/protobuf/types/known/emptypb"
)

type TrainingController struct {
	trainingService *services.TrainingService
	pb.TrainingServiceServer
}

func NewTrainingController(trainingService *services.TrainingService) *TrainingController {
	return &TrainingController{trainingService: trainingService}
}

func (tc *TrainingController) CreateNewTraining(ctx context.Context, in *pb.CreateTrainingRequest) (*pb.Training, error) {
	name := in.GetName()
	description := in.GetDescription()
	isPrivate := in.GetIsPrivate()
	ownerId := in.GetUserId()

	arg := db.CreateTrainingParams{
		Name:        name,
		Description: description,
		OwnerUuid:   pgtype.UUID{Bytes: uuid.MustParse(ownerId), Valid: true},
		IsPrivate:   isPrivate,
	}

	training, err := tc.trainingService.CreateTraining(ctx, arg)
	if err != nil {
		return nil, err
	}

	return &training, nil
}

func (tc *TrainingController) GetTrainingList(ctx context.Context, in *pb.GetTrainingListRequest) (*pb.TrainingPreviewList, error) {
	page := in.GetPage()
	limit := in.GetLimit()
	trainingName := in.GetTrainingName()
	offset := (page - 1) * limit

	args := &services.GetTrainingListParams{
		TrainingName:  trainingName,
		RequestOffset: offset,
		RequestLimit:  limit,
	}

	trainingList, err := tc.trainingService.GetTrainingList(ctx, args)
	if err != nil {
		return nil, err
	}

	return trainingList, nil
}

func (tc *TrainingController) GetTrainingListForUser(ctx context.Context, in *pb.GetTrainingListForUserRequest) (*pb.TrainingPreviewList, error) {
	userUuid := in.GetUserUuid()
	trainingType := in.GetTrainingType()

	args := &services.GetTrainingListForUserParams{
		TrainingsType: services.TrainingType(trainingType),
		UserUuid:      pgtype.UUID{Bytes: uuid.MustParse(userUuid), Valid: true},
	}

	trainings, err := tc.trainingService.GetTrainingListForUser(ctx, args)
	if err != nil {
		return nil, err
	}

	return trainings, nil
}

func (tc *TrainingController) GetTrainingsAmountByUserId(ctx context.Context, in *pb.GetTrainingsAmountByUserIdRequest) (*pb.TrainingsAmount, error) {
	userUuid := in.GetUserUuid()

	args := &services.GetGetTrainingsAmountByUserIdParams{
		UserUuid: pgtype.UUID{Bytes: uuid.MustParse(userUuid), Valid: true},
	}

	trainingsAmount, err := tc.trainingService.GetTrainingsAmountByUserId(ctx, args)
	if err != nil {
		return nil, err
	}

	return trainingsAmount, nil
}

func (tc *TrainingController) GetTrainingById(ctx context.Context, in *pb.GetTrainingRequest) (*pb.Training, error) {
	trainingUuid := in.GetTrainingUuid()

	training, err := tc.trainingService.GetTrainingById(ctx, pgtype.UUID{Bytes: uuid.MustParse(trainingUuid), Valid: true})
	if err != nil {
		return nil, err
	}

	return &training, nil
}

func (tc *TrainingController) UpdateTraining(ctx context.Context, in *pb.UpdateTrainingRequest) (*pb.Training, error) {
	trainingUuid := in.GetUuid()
	var trainingName string
	if in.Name != nil {
		trainingName = *in.Name
	} else {
		trainingName = ""
	}

	var description string
	if in.Description != nil {
		description = *in.Description
	} else {
		description = ""
	}
	var isPrivate bool
	if in.IsPrivate != nil {
		isPrivate = *in.IsPrivate
	} else {
		isPrivate = false
	}

	arg := db.UpdateTrainingParams{
		TrainingUuid: pgtype.UUID{Bytes: uuid.MustParse(trainingUuid), Valid: true},
		Name:         pgtype.Text{String: trainingName, Valid: in.Name != nil},
		Description:  pgtype.Text{String: description, Valid: in.Description != nil},
		IsPrivate:    pgtype.Bool{Bool: isPrivate, Valid: in.IsPrivate != nil},
	}
	training, err := tc.trainingService.UpdateTraining(ctx, arg)
	if err != nil {
		return nil, err
	}
	return &training, nil
}

func (tc *TrainingController) DeleteTraining(ctx context.Context, in *pb.DeleteTrainingRequest) (*emptypb.Empty, error) {
	trainingUuid := in.GetUuid()

	err := tc.trainingService.DeleteTraining(ctx, pgtype.UUID{Bytes: uuid.MustParse(trainingUuid), Valid: true})
	if err != nil {
		return nil, err
	}

	return &emptypb.Empty{}, nil
}
