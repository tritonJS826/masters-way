package services

import (
	"context"
	"mw-training-bff/internal/schemas"

	pb "mw-training-bff/pkg/grpcAutogenerated/training"

	"github.com/google/uuid"
	"github.com/samber/lo"
)

type PracticeMaterialService struct {
	practiceMaterialGRPC pb.PracticeMaterialServiceClient
}

func NewPracticeMaterialService(
	practiceMaterialGRPC pb.PracticeMaterialServiceClient,
) *PracticeMaterialService {
	return &PracticeMaterialService{practiceMaterialGRPC}
}

type GetPracticeMaterialsByTopicIdParams struct {
	TopicId uuid.UUID
}

func (pms *PracticeMaterialService) GetPracticeMaterialsByTopicId(ctx context.Context, params *GetPracticeMaterialsByTopicIdParams) (*schemas.PracticeMaterials, error) {
	// notificationListRaw, err := pms.practiceMaterialGRPC.GetNotificationList(ctx, &pb.GetNotificationListRequest{
	// 	UserUuid:  params.UserUUID,
	// 	Page:      params.Page,
	// 	Limit:     params.Limit,
	// 	IsOnlyNew: params.IsOnlyNew,
	// })
	// if err != nil {
	// 	return nil, err
	// }

	// notificationList := lo.Map(notificationListRaw.Notifications, func(notificationRaw *pb.Notification, i int) schemas.NotificationResponse {
	// 	return schemas.NotificationResponse{
	// 		UUID:        notificationRaw.Uuid,
	// 		UserUUID:    notificationRaw.UserUuid,
	// 		IsRead:      notificationRaw.IsRead,
	// 		Description: notificationRaw.Description,
	// 		Url:         notificationRaw.Url,
	// 		Nature:      notificationRaw.Nature.String(),
	// 		CreatedAt:   notificationRaw.CreatedAt,
	// 	}
	// })

	return &schemas.PracticeMaterials{
		Size:              10,
		PracticeMaterials: []schemas.PracticeMaterial{},
	}, nil
}

func (ns *NotificationService) CreatePracticeMaterial(ctx context.Context, notificationUUID string, isRead bool) (*schemas.NotificationResponse, error) {
	notification, err := ns.notificationGRPC.UpdateNotification(ctx, &pb.UpdateNotificationRequest{
		NotificationUuid: notificationUUID,
		IsRead:           isRead,
	})
	if err != nil {
		return nil, err
	}

	return &schemas.NotificationResponse{
		UUID:        notification.Uuid,
		UserUUID:    notification.UserUuid,
		IsRead:      notification.IsRead,
		Description: notification.Description,
		Url:         notification.Url,
		Nature:      notification.Nature.String(),
		CreatedAt:   notification.CreatedAt,
	}, nil
}

func (ns *NotificationService) UpdatePracticeMaterial(ctx context.Context, userUUID string) (*schemas.GetNotificationSettingListResponse, error) {
	notificationSettingListRaw, err := ns.notificationSettingGRPC.GetNotificationSettingList(
		ctx,
		&pb.GetNotificationSettingListRequest{
			UserUuid: userUUID,
		},
	)
	if err != nil {
		return nil, err
	}

	notificationSettingList := lo.Map(notificationSettingListRaw.NotificationSettings, func(notificationSettingRaw *pb.NotificationSettingResponse, _ int) schemas.NotificationSettingResponse {
		return schemas.NotificationSettingResponse{
			UUID:      notificationSettingRaw.Uuid,
			UserUUID:  notificationSettingRaw.UserUuid,
			Nature:    notificationSettingRaw.Nature.String(),
			Channel:   notificationSettingRaw.Channel,
			IsEnabled: notificationSettingRaw.IsEnabled,
		}
	})

	return &schemas.GetNotificationSettingListResponse{
		NotificationSettings: notificationSettingList,
	}, nil
}

func (ns *NotificationService) DeletePracticeMaterial(ctx context.Context, notificationSettingID string, isEnabled bool) (*schemas.NotificationSettingResponse, error) {
	in := &pb.UpdateNotificationSettingRequest{
		NotificationSettingUuid: notificationSettingID,
		IsEnabled:               isEnabled,
	}
	notificationSetting, err := ns.notificationSettingGRPC.UpdateNotificationSetting(ctx, in)
	if err != nil {
		return nil, err
	}

	return &schemas.NotificationSettingResponse{
		UUID:      notificationSetting.Uuid,
		UserUUID:  notificationSetting.UserUuid,
		Nature:    notificationSetting.Nature.String(),
		Channel:   notificationSetting.Channel,
		IsEnabled: notificationSetting.IsEnabled,
	}, nil
}
