package services

import (
	"context"
	"errors"
	"fmt"
	openapiGeneral "mw-training-bff/apiAutogenerated/general"
	"mw-training-bff/internal/schemas"
	util "mw-training-bff/internal/utils"

	pb "mw-training-bff/pkg/grpcAutogenerated/training"

	"github.com/samber/lo"
)

// service QuestionResultsService {
//   rpc CreateQuestionResult(CreateQuestionResultRequest) returns (QuestionResult);
//   rpc GetQuestionResultsBySessionUuid(GetQuestionResultsBySessionUuidRequest) returns (GetQuestionResultsBySessionUuidResponse);
// }

type QuestionResultService struct {
	questionResultGRPC pb.QuestionResultsServiceClient
	generalAPI         *openapiGeneral.APIClient
}

func NewQuestionResultService(
	questionResultGRPC pb.QuestionResultsServiceClient,
	generalAPI *openapiGeneral.APIClient,
) *QuestionResultService {
	return &QuestionResultService{questionResultGRPC, generalAPI}
}

type CreateQuestionResultParams struct {
	SessionUuid       string
	QuestionUuid      string
	UserUuid          string
	TestUuid          string
	ResultDescription string
	IsCorrect         bool
	UserAnswer        string
}

func (qrs *QuestionResultService) CreateQuestionResult(ctx context.Context, params *CreateQuestionResultParams) (*schemas.QuestionResult, error) {
	questionResult, err := qrs.questionResultGRPC.CreateQuestionResult(ctx, &pb.CreateQuestionResultRequest{
		QuestionUuid:      params.QuestionUuid,
		UserUuid:          params.UserUuid,
		TestUuid:          params.TestUuid,
		TestSessionUuid:   params.SessionUuid,
		IsOk:              params.IsCorrect,
		ResultDescription: params.ResultDescription,
		UserAnswer:        params.UserAnswer,
	})
	if err != nil {
		return nil, err
	}

	users, response, err := qrs.generalAPI.UserAPI.GetUsersByIds(ctx).Request([]string{questionResult.UserUuid}).Execute()
	if err != nil {
		message, extractErr := util.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, errors.New(message)
	}

	return &schemas.QuestionResult{
		UUID:                questionResult.Uuid,
		UserUUID:            questionResult.UserUuid,
		UserName:            users[0].Name,
		UserImageUrl:        users[0].ImageUrl,
		IsOk:                questionResult.IsOk,
		ResultDescription:   questionResult.ResultDescription,
		QuestionName:        questionResult.QuestionName,
		QuestionDescription: questionResult.QuestionDescription,
		UserAnswer:          questionResult.UserAnswer,
		QuestionAnswer:      questionResult.QuestionAnswer,
		QuestionUUID:        questionResult.QuestionUuid,
	}, nil
}

type GetQuestionResultsBySessionUuidParams struct {
	SessionUuid string
	UserUuid    string
}

func (qrs *QuestionResultService) GetQuestionResultsBySessionUuid(ctx context.Context, params *GetQuestionResultsBySessionUuidParams) ([]*schemas.QuestionResult, error) {
	results, err := qrs.questionResultGRPC.GetQuestionResultsBySessionUuid(ctx, &pb.GetQuestionResultsBySessionUuidRequest{
		SessionUuid: params.SessionUuid,
		UserUuid:    params.UserUuid,
	})
	if err != nil {
		return nil, err
	}

	participantUuids := lo.Map(results.Results, func(questionResultDb *pb.QuestionResult, _ int) string {
		return questionResultDb.UserUuid
	})
	uniqParticipantUuids := lo.Uniq(participantUuids)
	users, response, err := qrs.generalAPI.UserAPI.GetUsersByIds(ctx).Request(uniqParticipantUuids).Execute()
	if err != nil {
		message, extractErr := util.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, errors.New(message)
	}
	participantsMap := lo.SliceToMap(users, func(user openapiGeneral.MwServerInternalSchemasShortUser) (string, openapiGeneral.MwServerInternalSchemasShortUser) {
		return user.UserId, user
	})

	questionResults := make([]*schemas.QuestionResult, len(results.Results))
	for i, result := range results.Results {
		questionResults[i] = &schemas.QuestionResult{
			UUID:                result.Uuid,
			UserUUID:            result.UserUuid,
			UserName:            participantsMap[result.UserUuid].Name,
			UserImageUrl:        participantsMap[result.UserUuid].ImageUrl,
			IsOk:                result.IsOk,
			ResultDescription:   result.ResultDescription,
			QuestionName:        result.QuestionName,
			QuestionDescription: result.QuestionDescription,
			UserAnswer:          result.UserAnswer,
			QuestionAnswer:      result.QuestionAnswer,
			QuestionUUID:        result.QuestionUuid,
		}
	}

	return questionResults, nil
}
