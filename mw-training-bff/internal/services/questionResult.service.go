package services

import (
	"context"
	openapiGeneral "mw-training-bff/apiAutogenerated/general"
	"mw-training-bff/internal/schemas"

	pb "mw-training-bff/pkg/grpcAutogenerated/training"
)

// service QuestionResultsService {
//   rpc CreateQuestionResult(CreateQuestionResultRequest) returns (QuestionResult);
//   rpc GetQuestionResultsBySessionUuid(GetQuestionResultsBySessionUuidRequest) returns (GetQuestionResultsBySessionUuidResponse);
// }

type QuestionResultService struct {
	questionResultGRPC pb.QuestionResultsServiceClient
	generalAPI         *openapiGeneral.APIClient
}

func NewQuestionResultService(
	questionResultGRPC pb.QuestionResultsServiceClient,
	generalAPI *openapiGeneral.APIClient,
) *QuestionResultService {
	return &QuestionResultService{questionResultGRPC, generalAPI}
}

type CreateQuestionResultParams struct {
	SessionUuid       string
	QuestionUuid      string
	UserUuid          string
	TestUuid          string
	ResultDescription string
	IsCorrect         bool
	UserAnswer        string
}

func (s *QuestionResultService) CreateQuestionResult(ctx context.Context, params *CreateQuestionResultParams) (*schemas.QuestionResult, error) {
	questionResult, err := s.questionResultGRPC.CreateQuestionResult(ctx, &pb.CreateQuestionResultRequest{
		QuestionUuid:      params.QuestionUuid,
		UserUuid:          params.UserUuid,
		TestUuid:          params.TestUuid,
		TestSessionUuid:   params.SessionUuid,
		IsOk:              params.IsCorrect,
		ResultDescription: params.ResultDescription,
		UserAnswer:        params.UserAnswer,
	})
	if err != nil {
		return nil, err
	}

	return &schemas.QuestionResult{
		UUID:                questionResult.Uuid,
		UserUUID:            questionResult.UserUuid,
		IsOk:                questionResult.IsOk,
		ResultDescription:   questionResult.ResultDescription,
		QuestionName:        questionResult.QuestionName,
		QuestionDescription: questionResult.QuestionDescription,
		UserAnswer:          questionResult.UserAnswer,
		QuestionAnswer:      questionResult.QuestionAnswer,
		QuestionUUID:        questionResult.QuestionUuid,
	}, nil
}

type GetQuestionResultsBySessionUuidParams struct {
	SessionUuid string
	UserUuid    string
}

func (s *QuestionResultService) GetQuestionResultsBySessionUuid(ctx context.Context, params *GetQuestionResultsBySessionUuidParams) ([]*schemas.QuestionResult, error) {
	results, err := s.questionResultGRPC.GetQuestionResultsBySessionUuid(ctx, &pb.GetQuestionResultsBySessionUuidRequest{
		SessionUuid: params.SessionUuid,
		UserUuid:    params.UserUuid,
	})
	if err != nil {
		return nil, err
	}

	questionResults := make([]*schemas.QuestionResult, len(results.Results))
	for i, result := range results.Results {
		questionResults[i] = &schemas.QuestionResult{
			UUID:                result.Uuid,
			UserUUID:            result.UserUuid,
			IsOk:                result.IsOk,
			ResultDescription:   result.ResultDescription,
			QuestionName:        result.QuestionName,
			QuestionDescription: result.QuestionDescription,
			UserAnswer:          result.UserAnswer,
			QuestionAnswer:      result.QuestionAnswer,
			QuestionUUID:        result.QuestionUuid,
		}
	}

	return questionResults, nil
}
