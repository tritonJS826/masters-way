package services

import (
	"context"
	openapiGeneral "mw-training-bff/apiAutogenerated/general"
	"mw-training-bff/internal/schemas"

	pb "mw-training-bff/pkg/grpcAutogenerated/training"

	"github.com/samber/lo"
)

type TopicService struct {
	topicGRPC  pb.TopicsServiceClient
	generalAPI *openapiGeneral.APIClient
}

func NewTopicService(
	topicGRPC pb.TopicsServiceClient,
	generalAPI *openapiGeneral.APIClient,
) *TopicService {
	return &TopicService{topicGRPC, generalAPI}
}

type CreateTopicsParams struct {
	Names           []string
	TrainingUuid    string
	TopicOrder      int32
	ParentTopicUuid *string
}

func (ts *TopicService) GetTopicById(ctx context.Context, topicUuid string) (*schemas.Topic, error) {
	topic, err := ts.topicGRPC.GetTopicById(ctx, &pb.GetTopicByIdRequest{
		TopicUuid: topicUuid,
	})
	if err != nil {
		return nil, err
	}

	ownerUuid := topic.OwnerUuid
	userUuidsRelatedToTopic := []string{ownerUuid}
	usersRelatedToTrainings, _, err := ts.generalAPI.UserAPI.GetUsersByIds(ctx).Request(userUuidsRelatedToTopic).Execute()
	if err != nil {
		return &schemas.Topic{}, err
	}

	usersMap := lo.SliceToMap(usersRelatedToTrainings, func(
		user openapiGeneral.MwServerInternalSchemasShortUser,
	) (string, schemas.User) {
		return user.UserId, schemas.User{
			Uuid:     user.UserId,
			Name:     user.Name,
			ImageUrl: user.ImageUrl,
		}
	})

	return &schemas.Topic{
		Uuid:         topic.Uuid,
		Name:         topic.Name,
		TrainingUuid: topic.TrainingUuid,
		TopicOrder:   topic.TopicOrder,
		ParentUuid:   topic.ParentTopicUuid,
		Owner:        usersMap[ownerUuid],
		CreatedAt:    topic.CreatedAt,
		TheoryMaterials: lo.Map(topic.TheoryMaterials, func(material *pb.TheoryMaterial, _ int) schemas.TheoryMaterial {
			return schemas.TheoryMaterial{
				Uuid:                material.Uuid,
				Name:                material.Name,
				Description:         material.Description,
				TopicUuid:           material.TopicUuid,
				CreatedAt:           material.CreatedAt,
				UpdatedAt:           material.UpdatedAt,
				TheoryMaterialOrder: material.Order,
			}
		}),
		PracticeMaterials: lo.Map(topic.PracticeMaterials, func(material *pb.PracticeMaterial, _ int) schemas.PracticeMaterial {
			return schemas.PracticeMaterial{
				Uuid:                  material.Uuid,
				Name:                  material.Name,
				TopicUuid:             material.TopicUuid,
				TaskDescription:       material.Description,
				CreatedAt:             material.CreatedAt,
				UpdatedAt:             material.UpdatedAt,
				PracticeMaterialOrder: material.Order,
				Answer:                material.Answer,
				PracticeType:          material.PracticeType,
				TimeToAnswer:          material.TimeToAnswer,
			}
		}),
	}, nil
}

func (ts *TopicService) CreateTopics(ctx context.Context, params *CreateTopicsParams) (*schemas.TopicsPreview, error) {
	args := lo.Map(params.Names, func(topicName string, _ int) *pb.CreateTopicRequest {
		return &pb.CreateTopicRequest{
			Name:            topicName,
			TrainingUuid:    params.TrainingUuid,
			TopicOrder:      params.TopicOrder,
			ParentTopicUuid: params.ParentTopicUuid,
		}
	})

	topicsRaw, err := ts.topicGRPC.CreateTopics(ctx, &pb.CreateTopicsRequest{
		CreateTopicRequest: args,
	})
	if err != nil {
		return nil, err
	}

	topics := lo.Map(topicsRaw.TopicsPreview, func(topic *pb.TopicPreview, _ int) *schemas.TopicPreview {
		return &schemas.TopicPreview{
			Uuid:                   topic.Uuid,
			Name:                   topic.Name,
			TrainingUuid:           topic.TrainingUuid,
			TopicOrder:             topic.TopicOrder,
			ParentUuid:             topic.ParentTopicUuid,
			TheoryMaterialAmount:   topic.TheoryMaterialsAmount,
			PracticeMaterialAmount: topic.PracticeMaterialsAmount,
			CreatedAt:              topic.CreatedAt,
		}
	})

	return &schemas.TopicsPreview{
		Topics: topics,
	}, nil
}

type UpdateTopicParams struct {
	Name      string
	TopicUuid string
}

func (ts *TopicService) UpdateTopic(ctx context.Context, params *UpdateTopicParams) (*schemas.TopicPreview, error) {
	topic, err := ts.topicGRPC.UpdateTopic(ctx, &pb.UpdateTopicRequest{
		Uuid: params.TopicUuid,
		Name: params.Name,
	})
	if err != nil {
		return nil, err
	}

	return &schemas.TopicPreview{
		Uuid:         topic.Uuid,
		Name:         topic.Name,
		TrainingUuid: topic.TrainingUuid,
		TopicOrder:   topic.TopicOrder,
		ParentUuid:   topic.ParentTopicUuid,
		CreatedAt:    topic.CreatedAt,
	}, nil
}

type DeleteTopicParams struct {
	TopicUuid string
}

func (ts *TopicService) DeleteTopic(ctx context.Context, params *DeleteTopicParams) error {
	in := &pb.DeleteTopicRequest{
		TopicUuid: params.TopicUuid,
	}
	_, err := ts.topicGRPC.DeleteTopic(ctx, in)
	if err != nil {
		return err
	}

	return nil
}
