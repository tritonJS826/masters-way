package services

import (
	"fmt"
	openapiTraining "mw-training-bff/apiAutogenerated/training"
	"mw-training-bff/internal/schemas"
	utils "mw-training-bff/internal/utils"

	"github.com/gin-gonic/gin"
	"github.com/samber/lo"
)

type ChatService struct {
	trainingAPI *openapiTraining.APIClient
}

func NewChatService(chatAPI *openapiTraining.APIClient) *ChatService {
	return &ChatService{chatAPI}
}

func (cs *ChatService) GetChatPreview(ctx *gin.Context) (*schemas.GetRoomPreviewResponse, error) {
	chatPreviewRaw, _, err := cs.trainingAPI.RoomAPI.GetChatPreview(ctx).Execute()
	if err != nil {
		return nil, err
	}

	chatPreview := schemas.GetRoomPreviewResponse{
		UnreadMessagesAmount: chatPreviewRaw.UnreadMessagesAmount,
	}

	return &chatPreview, nil
}

func (cs *ChatService) GetRooms(ctx *gin.Context, roomType string) (*schemas.GetRoomsResponse, error) {
	roomsRaw, _, err := cs.trainingAPI.RoomAPI.GetRooms(ctx, roomType).Execute()
	if err != nil {
		return nil, err
	}

	rooms := lo.Map(roomsRaw.Rooms, func(roomRaw openapiTraining.MwChatInternalSchemasRoomPreviewResponse, i int) schemas.RoomPreviewResponse {

		usersPopulated := lo.Map(roomRaw.Users, func(rawUser openapiTraining.MwChatInternalSchemasUserResponse, i int) schemas.UserResponse {
			return schemas.UserResponse{
				UserID: rawUser.UserId,
				Role:   rawUser.Role,
			}
		})
		var name string
		if roomRaw.Name.Get() != nil {
			name = *roomRaw.Name.Get()
		}
		response := schemas.RoomPreviewResponse{
			RoomID:    roomRaw.RoomId,
			Name:      name,
			RoomType:  roomRaw.RoomType,
			IsBlocked: roomRaw.IsBlocked,
			Users:     usersPopulated,
		}

		return response
	})

	roomsPreview := schemas.GetRoomsResponse{
		Size:  roomsRaw.Size,
		Rooms: rooms,
	}
	return &roomsPreview, nil
}

func (cs *ChatService) GetRoomById(ctx *gin.Context, roomUuid string) (*schemas.RoomPopulatedResponse, error) {
	roomRaw, _, err := cs.trainingAPI.RoomAPI.GetRoomById(ctx, roomUuid).Execute()
	if err != nil {
		return nil, err
	}

	messages := lo.Map(roomRaw.Messages, func(messageRaw openapiTraining.MwChatInternalSchemasMessageResponse, i int) schemas.MessageResponse {

		messageReaders := lo.Map(messageRaw.MessageReaders, func(messageReaderRaw openapiTraining.MwChatInternalSchemasMessageReader, i int) schemas.MessageReader {
			return schemas.MessageReader{
				UserID:   messageReaderRaw.UserId,
				ReadDate: messageReaderRaw.ReadDate,
			}
		})

		message := schemas.MessageResponse{
			MessageID: messageRaw.MessageId,
			OwnerID:   messageRaw.OwnerId,
			Message:   messageRaw.Message,
			Readers:   messageReaders,
		}

		return message
	})

	users := lo.Map(roomRaw.Users, func(userRaw openapiTraining.MwChatInternalSchemasUserResponse, i int) schemas.UserResponse {
		return schemas.UserResponse{
			UserID: userRaw.UserId,
			Role:   userRaw.Role,
		}
	})

	var name string
	if roomRaw.Name.Get() != nil {
		name = *roomRaw.Name.Get()
	}
	roomPopulated := schemas.RoomPopulatedResponse{
		RoomID:    roomRaw.RoomId,
		Name:      name,
		Messages:  messages,
		IsBlocked: roomRaw.IsBlocked,
		Users:     users,
		RoomType:  roomRaw.RoomType,
	}
	return &roomPopulated, nil

}

func (cs *ChatService) FindOrCreateRoom(ctx *gin.Context, createRoomPayload *schemas.CreateRoomPayload) (*schemas.FindOrCreateRoomResponse, error) {
	var name = openapiTraining.NullableString{}
	if createRoomPayload.Name != nil {
		name.Set(createRoomPayload.Name)
	}
	var userId = openapiTraining.NullableString{}
	if createRoomPayload.UserID != nil {
		userId.Set(createRoomPayload.UserID)
	}

	findOrCreateRoomRaw, response, err := cs.trainingAPI.RoomAPI.FindOrCreateRoom(ctx).Request(openapiTraining.MwChatInternalSchemasCreateRoomPayload{
		Name:     name,
		RoomType: createRoomPayload.RoomType,
		UserId:   userId,
	}).Execute()
	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	messages := lo.Map(findOrCreateRoomRaw.Room.Messages, func(messageRaw openapiTraining.MwChatInternalSchemasMessageResponse, i int) schemas.MessageResponse {
		messageReaders := lo.Map(messageRaw.MessageReaders, func(messageReaderRaw openapiTraining.MwChatInternalSchemasMessageReader, i int) schemas.MessageReader {
			return schemas.MessageReader{
				UserID:   messageReaderRaw.UserId,
				ReadDate: messageReaderRaw.ReadDate,
			}
		})
		message := schemas.MessageResponse{
			MessageID: messageRaw.MessageId,
			OwnerID:   messageRaw.OwnerId,
			Message:   messageRaw.Message,
			Readers:   messageReaders,
		}
		return message
	})

	users := lo.Map(findOrCreateRoomRaw.Room.Users, func(userRaw openapiTraining.MwChatInternalSchemasUserResponse, i int) schemas.UserResponse {
		return schemas.UserResponse{
			UserID: userRaw.UserId,
			Role:   userRaw.Role,
		}
	})

	var roomPopulatedName string
	if findOrCreateRoomRaw.Room.Name.Get() != nil {
		roomPopulatedName = *findOrCreateRoomRaw.Room.Name.Get()
	}

	return &schemas.FindOrCreateRoomResponse{
		Room: &schemas.RoomPopulatedResponse{
			RoomID:    findOrCreateRoomRaw.Room.RoomId,
			Name:      roomPopulatedName,
			ImageURL:  "",
			RoomType:  findOrCreateRoomRaw.Room.RoomType,
			IsBlocked: findOrCreateRoomRaw.Room.IsBlocked,
			Users:     users,
			Messages:  messages,
		},
		IsAlreadyCreated: findOrCreateRoomRaw.IsAlreadyCreated,
	}, nil
}

func (cs *ChatService) UpdateRoom(ctx *gin.Context, roomId string) (*schemas.RoomPopulatedResponse, error) {
	roomRaw, _, err := cs.trainingAPI.RoomAPI.UpdateRoom(ctx, roomId).Execute()
	if err != nil {
		return nil, err
	}
	messages := lo.Map(roomRaw.Messages, func(messageRaw openapiTraining.MwChatInternalSchemasMessageResponse, i int) schemas.MessageResponse {

		readers := lo.Map(messageRaw.MessageReaders, func(messageReaderRaw openapiTraining.MwChatInternalSchemasMessageReader, i int) schemas.MessageReader {
			return schemas.MessageReader{
				UserID:   messageReaderRaw.UserId,
				ReadDate: messageReaderRaw.ReadDate,
			}
		})

		message := schemas.MessageResponse{
			MessageID: messageRaw.MessageId,
			OwnerID:   messageRaw.OwnerId,
			Message:   messageRaw.Message,
			Readers:   readers,
		}

		return message
	})

	users := lo.Map(roomRaw.Users, func(userRaw openapiTraining.MwChatInternalSchemasUserResponse, i int) schemas.UserResponse {
		return schemas.UserResponse{
			UserID: userRaw.UserId,
			Role:   userRaw.Role,
		}
	})

	var name string
	if roomRaw.Name.Get() != nil {
		name = *roomRaw.Name.Get()
	}
	roomPopulatedResponse := schemas.RoomPopulatedResponse{
		RoomID:    roomRaw.RoomId,
		Name:      name,
		Messages:  messages,
		IsBlocked: roomRaw.IsBlocked,
		Users:     users,
		RoomType:  roomRaw.RoomType,
	}

	return &roomPopulatedResponse, nil
}

func (cs *ChatService) CreateMessage(ctx *gin.Context, messageText, roomId string) (*schemas.SendMessagePayload, error) {
	messageRaw, _, err := cs.trainingAPI.MessageAPI.CreateMessage(ctx).Request(openapiTraining.MwChatInternalSchemasCreateMessagePayload{
		Message: messageText,
		RoomId:  roomId,
	}).Execute()
	if err != nil {
		return nil, err
	}

	messageReaders := lo.Map(messageRaw.Message.MessageReaders, func(messageReaderRaw openapiTraining.MwChatInternalSchemasMessageReader, i int) schemas.MessageReader {
		return schemas.MessageReader{
			UserID:   messageReaderRaw.UserId,
			ReadDate: messageReaderRaw.ReadDate,
		}
	})

	message := schemas.SendMessagePayload{
		Message: schemas.MessageResponse{
			MessageID: messageRaw.Message.MessageId,
			OwnerID:   messageRaw.Message.OwnerId,
			Message:   messageRaw.Message.Message,
			Readers:   messageReaders,
		},
		UserIDs: messageRaw.Users,
	}

	return &message, nil
}

func (ChatService *ChatService) AddUserToRoom(ctx *gin.Context, roomId string, userId string) (*schemas.RoomPreviewResponse, error) {
	rawRoom, _, err := ChatService.trainingAPI.RoomAPI.AddUserToRoom(ctx, roomId, userId).Execute()
	if err != nil {
		return nil, err
	}

	usersPopulated := lo.Map(rawRoom.Users, func(rawUser openapiTraining.MwChatInternalSchemasUserResponse, i int) schemas.UserResponse {
		return schemas.UserResponse{
			UserID: rawUser.UserId,
			Role:   rawUser.Role,
		}
	})

	response := schemas.RoomPreviewResponse{
		RoomID:    rawRoom.RoomId,
		Name:      *rawRoom.Name.Get(),
		IsBlocked: rawRoom.IsBlocked,
		Users:     usersPopulated,
	}

	return &response, nil
}

func (cs *ChatService) DeleteUserFromRoom(ctx *gin.Context, roomId string, userId string) error {
	_, err := cs.trainingAPI.RoomAPI.DeleteUserFromRoom(ctx, roomId, userId).Execute()
	if err != nil {
		return err
	}

	return nil
}

func (cs *ChatService) UpdateMessageStatus(ctx *gin.Context, messageID string, isRead bool) error {
	payload := openapiTraining.MwChatInternalSchemasUpdateMessageStatusPayload{
		IsRead: isRead,
	}

	_, err := cs.trainingAPI.MessageAPI.UpdateMessageStatus(ctx, messageID).Request(payload).Execute()
	if err != nil {
		return err
	}

	return nil
}
