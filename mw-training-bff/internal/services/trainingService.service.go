package services

import (
	"context"
	"mw-training-bff/internal/schemas"

	"github.com/samber/lo"

	"mw-training-bff/pkg/grpcAutogenerated/training"
	pb "mw-training-bff/pkg/grpcAutogenerated/training"
)

type TrainingService struct {
	trainingGRPC pb.TrainingServiceClient
	// notificationSettingGRPC pb.NotificationSettingServiceClient
}

func NewTrainingService(
	notificationGRPC pb.TrainingServiceClient,
	// notificationSettingGRPC pb.NotificationSettingServiceClient,
) *TrainingService {
	return &TrainingService{notificationGRPC}
}

type GetTrainingListParams struct {
	UserUUID     string
	Page         int
	Limit        int
	TrainingName string
}

func (ts *TrainingService) GetTrainingList(ctx context.Context, params *GetTrainingListParams) (*schemas.TrainingList, error) {
	trainingListRaw, err := ts.trainingGRPC.GetTrainingList(ctx, &pb.GetTrainingListRequest{
		UserUuid: params.UserUUID,
	})
	if err != nil {
		return &schemas.TrainingList{}, err
	}

	trainingsPreview := lo.Map(trainingListRaw.TrainingList, func(trainingGrpc *pb.Training, _ int) schemas.TrainingPreview {
		owner := schemas.User{
			Uuid:     trainingGrpc.GetOwner().Uuid,
			Name:     trainingGrpc.GetOwner().Name,
			ImageUrl: trainingGrpc.GetOwner().ImageUrl,
		}

		return schemas.TrainingPreview{
			Uuid:        trainingGrpc.GetUuid(),
			Name:        trainingGrpc.GetName(),
			Description: trainingGrpc.GetDescription(),
			IsPrivate:   trainingGrpc.GetIsPrivate(),
			Owner:       owner,
			CreatedAt:   trainingGrpc.GetCreatedAt(),
			UpdatedAt:   trainingGrpc.GetUpdatedAt(),
		}
	})

	return &schemas.TrainingList{
		Size:      trainingListRaw.Size,
		Trainings: trainingsPreview,
	}, nil
}

type CreateTrainingParams struct {
	Name string
}

func (ts *TrainingService) CreateTraining(ctx context.Context, params *CreateTrainingParams) (*schemas.Training, error) {
	trainingRaw, err := ts.trainingGRPC.CreateNewTraining(ctx, &pb.CreateTrainingRequest{
		Name: params.Name,
	})

	if err != nil {
		return &schemas.Training{}, err
	}

	owner := schemas.User{
		Uuid:     trainingRaw.GetOwner().Uuid,
		Name:     trainingRaw.GetOwner().Name,
		ImageUrl: trainingRaw.GetOwner().ImageUrl,
	}

	return &schemas.Training{
		Uuid:        trainingRaw.Uuid,
		Name:        trainingRaw.Name,
		Description: trainingRaw.Description,
		IsPrivate:   trainingRaw.IsPrivate,
		Owner:       owner,
		// Mentors: trainingRaw.,
		// Students: ,
		// TrainingTags: trainingRaw.,
		// FavoriteForUserUuids: trainingRaw.,
		// Topics: trainingRaw.,
		CreatedAt: trainingRaw.CreatedAt,
		UpdatedAt: trainingRaw.UpdatedAt,
	}, err

}

type UpdateTrainingParams struct {
	Uuid        string
	Name        string
	Description string
	IsPrivate   bool
}

func (ts *TrainingService) UpdateTraining(ctx context.Context, params *UpdateTrainingParams) (*schemas.Training, error) {
	trainingRaw, err := ts.trainingGRPC.UpdateTraining(ctx, &pb.UpdateTrainingRequest{
		Uuid:        params.Uuid,
		Name:        params.Name,
		Description: params.Description,
		IsPrivate:   params.IsPrivate,
	})

	if err != nil {
		return &schemas.Training{}, err
	}

	owner := schemas.User{
		Uuid:     trainingRaw.GetOwner().Uuid,
		Name:     trainingRaw.GetOwner().Name,
		ImageUrl: trainingRaw.GetOwner().ImageUrl,
	}

	return &schemas.Training{
		Uuid:        trainingRaw.Uuid,
		Name:        trainingRaw.Name,
		Description: trainingRaw.Description,
		IsPrivate:   trainingRaw.IsPrivate,
		Owner:       owner,
		// Mentors: trainingRaw.,
		// Students: ,
		// TrainingTags: trainingRaw.,
		// FavoriteForUserUuids: trainingRaw.,
		// Topics: trainingRaw.,
		CreatedAt: trainingRaw.CreatedAt,
		UpdatedAt: trainingRaw.UpdatedAt,
	}, err

}

func (ts *TrainingService) DeleteTraining(ctx context.Context, trainingID string) error {
	deleteTrainingRequest := &training.DeleteTrainingRequest{
		Uuid: trainingID,
	}

	_, err := ts.trainingGRPC.DeleteTraining(ctx, deleteTrainingRequest)

	if err != nil {
		return err
	}

	return nil
}

type GetTrainingListByUserParams struct {
	UserUUID     string
	Page         int
	Limit        int
	TrainingName string
}

func (ts *TrainingService) GetTrainingListByUser(ctx context.Context, params *GetTrainingListByUserParams) (*schemas.TrainingList, error) {
	trainingListRaw, err := ts.trainingGRPC.GetTrainingListForUser(ctx, &pb.GetTrainingListForUserRequest{
		UserUuid: params.UserUUID,
	})
	if err != nil {
		return &schemas.TrainingList{}, err
	}

	trainingsPreview := lo.Map(trainingListRaw.TrainingList, func(trainingGrpc *pb.Training, _ int) schemas.TrainingPreview {
		owner := schemas.User{
			Uuid:     trainingGrpc.GetOwner().Uuid,
			Name:     trainingGrpc.GetOwner().Name,
			ImageUrl: trainingGrpc.GetOwner().ImageUrl,
		}

		return schemas.TrainingPreview{
			Uuid:        trainingGrpc.GetUuid(),
			Name:        trainingGrpc.GetName(),
			Description: trainingGrpc.GetDescription(),
			IsPrivate:   trainingGrpc.GetIsPrivate(),
			Owner:       owner,
			CreatedAt:   trainingGrpc.GetCreatedAt(),
			UpdatedAt:   trainingGrpc.GetUpdatedAt(),
		}
	})

	return &schemas.TrainingList{
		Size:      trainingListRaw.Size,
		Trainings: trainingsPreview,
	}, nil
}

func (ts *TrainingService) GetTrainingById(ctx context.Context, trainingID string) (*schemas.Training, error) {
	trainingRaw, err := ts.trainingGRPC.GetTrainingById(ctx, &pb.GetTrainingRequest{
		TrainingUuid: trainingID,
	})
	if err != nil {
		return &schemas.Training{}, err
	}

	owner := schemas.User{
		Uuid:     trainingRaw.GetOwner().Uuid,
		Name:     trainingRaw.GetOwner().Name,
		ImageUrl: trainingRaw.GetOwner().ImageUrl,
	}

	return &schemas.Training{
		Uuid:        trainingRaw.Uuid,
		Name:        trainingRaw.Name,
		Description: trainingRaw.Description,
		IsPrivate:   trainingRaw.IsPrivate,
		Owner:       owner,
		// Mentors: trainingRaw.,
		// Students: ,
		// TrainingTags: trainingRaw.,
		// FavoriteForUserUuids: trainingRaw.,
		// Topics: trainingRaw.,
		CreatedAt: trainingRaw.CreatedAt,
		UpdatedAt: trainingRaw.UpdatedAt,
	}, nil
}
