package services

import (
	"context"
	"fmt"
	openapiGeneral "mw-training-bff/apiAutogenerated/general"
	"mw-training-bff/internal/schemas"

	"github.com/samber/lo"

	pb "mw-training-bff/pkg/grpcAutogenerated/training"
)

type TrainingService struct {
	trainingGRPC pb.TrainingServiceClient
	generalAPI   *openapiGeneral.APIClient
}

func NewTrainingService(
	trainingGRPC pb.TrainingServiceClient,
	generalAPI *openapiGeneral.APIClient,
) *TrainingService {
	return &TrainingService{trainingGRPC, generalAPI}
}

type GetTrainingListParams struct {
	Page         int
	Limit        int
	TrainingName string
}

func (ts *TrainingService) GetTrainingList(ctx context.Context, params *GetTrainingListParams) (*schemas.TrainingList, error) {
	trainingListRaw, err := ts.trainingGRPC.GetTrainingList(ctx, &pb.GetTrainingListRequest{
		Page:         int32(params.Page),
		Limit:        int32(params.Limit),
		TrainingName: params.TrainingName,
	})
	if err != nil {
		return &schemas.TrainingList{}, err
	}

	ownerIds := lo.Map(trainingListRaw.TrainingList, func(training *pb.TrainingPreview, _ int) string {
		return training.GetOwner().Uuid
	})

	studentIds := lo.FlatMap(trainingListRaw.TrainingList, func(training *pb.TrainingPreview, _ int) []string {
		return lo.Map(training.TrainingStudents, func(student *pb.User, _ int) string {
			return student.Uuid
		})
	})

	mentorIds := lo.FlatMap(trainingListRaw.TrainingList, func(training *pb.TrainingPreview, _ int) []string {
		return lo.Map(training.TrainingMentors, func(mentor *pb.User, _ int) string {
			return mentor.Uuid
		})
	})
	userUuidsRelatedToTrainings := append(append(studentIds, mentorIds...), ownerIds...)
	usersRelatedToTrainings, _, err := ts.generalAPI.UserAPI.GetUsersByIds(ctx).Request(userUuidsRelatedToTrainings).Execute()
	if err != nil {
		return &schemas.TrainingList{}, err
	}

	usersMap := lo.SliceToMap(usersRelatedToTrainings, func(
		user openapiGeneral.MwServerInternalSchemasShortUser,
	) (string, openapiGeneral.MwServerInternalSchemasShortUser) {
		return user.UserId, user
	})

	mentors := lo.Map(trainingListRaw.TrainingList, func(trainingGrpc *pb.TrainingPreview, i int) []schemas.User {
		return lo.Map(trainingGrpc.GetTrainingMentors(), func(mentor *pb.User, _ int) schemas.User {
			return schemas.User{
				Uuid:     usersMap[mentor.Uuid].UserId,
				Name:     usersMap[mentor.Uuid].Name,
				ImageUrl: usersMap[mentor.Uuid].ImageUrl,
			}
		})
	})

	trainingsPreview := lo.Map(trainingListRaw.TrainingList, func(trainingGrpc *pb.TrainingPreview, i int) schemas.TrainingPreview {
		trainingsTags := lo.Map(trainingGrpc.TrainingTagList, func(tag *pb.TrainingTag, _ int) schemas.TrainingTag {
			return schemas.TrainingTag{Name: tag.TagName}
		})

		return schemas.TrainingPreview{
			Uuid:        trainingGrpc.GetUuid(),
			Name:        trainingGrpc.GetName(),
			Description: trainingGrpc.GetDescription(),
			IsPrivate:   trainingGrpc.GetIsPrivate(),
			Owner: schemas.User{
				Uuid:     usersMap[trainingGrpc.Owner.Uuid].UserId,
				Name:     usersMap[trainingGrpc.Owner.Uuid].Name,
				ImageUrl: usersMap[trainingGrpc.Owner.Uuid].ImageUrl,
			},
			CreatedAt:              trainingGrpc.GetCreatedAt(),
			UpdatedAt:              trainingGrpc.GetUpdatedAt(),
			TrainingTags:           trainingsTags,
			Mentors:                mentors[i],
			StudentsAmount:         int32(len(trainingGrpc.GetTrainingStudents())),
			FavoriteForUsersAmount: trainingGrpc.GetFavoriteCount(),
			TopicsAmount:           trainingGrpc.TopicsAmount,
		}
	})

	return &schemas.TrainingList{
		Size:      trainingListRaw.Size,
		Trainings: trainingsPreview,
	}, nil
}

type CreateTrainingParams struct {
	Name        string
	UserId      string
	Description string
	IsPrivate   bool
}

func (ts *TrainingService) CreateTraining(ctx context.Context, params *CreateTrainingParams) (*schemas.Training, error) {
	trainingRaw, err := ts.trainingGRPC.CreateNewTraining(ctx, &pb.CreateTrainingRequest{
		Name:        params.Name,
		UserId:      params.UserId,
		Description: params.Description,
		IsPrivate:   params.IsPrivate,
	})

	if err != nil {
		return &schemas.Training{}, err
	}

	owner := schemas.User{
		Uuid:     trainingRaw.GetOwner().Uuid,
		Name:     trainingRaw.GetOwner().Name,
		ImageUrl: trainingRaw.GetOwner().ImageUrl,
	}

	return &schemas.Training{
		Uuid:                 trainingRaw.Uuid,
		Name:                 trainingRaw.Name,
		Description:          trainingRaw.Description,
		IsPrivate:            trainingRaw.IsPrivate,
		Owner:                owner,
		Mentors:              make([]schemas.User, 0),
		Students:             make([]schemas.User, 0),
		TrainingTags:         make([]schemas.TrainingTag, 0),
		FavoriteForUserUuids: make([]string, 0),
		TopicsTree:           make([]*schemas.TopicTreeNode, 0),
		CreatedAt:            trainingRaw.CreatedAt,
		UpdatedAt:            trainingRaw.UpdatedAt,
	}, err

}

type UpdateTrainingParams struct {
	TrainingUuid string
	Name         *string
	Description  *string
	IsPrivate    *bool
	OwnerUuid    string
}

func (ts *TrainingService) UpdateTraining(ctx context.Context, params *UpdateTrainingParams) (*schemas.Training, error) {
	trainingRaw, err := ts.trainingGRPC.UpdateTraining(ctx, &pb.UpdateTrainingRequest{
		Uuid:        params.TrainingUuid,
		OwnerUuid:   params.OwnerUuid,
		Name:        params.Name,
		Description: params.Description,
		IsPrivate:   params.IsPrivate,
	})

	if err != nil {
		return &schemas.Training{}, err
	}

	owner := schemas.User{
		Uuid:     trainingRaw.GetOwner().Uuid,
		Name:     trainingRaw.GetOwner().Name,
		ImageUrl: trainingRaw.GetOwner().ImageUrl,
	}

	return &schemas.Training{
		Uuid:                 trainingRaw.Uuid,
		Name:                 trainingRaw.Name,
		Description:          trainingRaw.Description,
		IsPrivate:            trainingRaw.IsPrivate,
		Owner:                owner,
		Mentors:              make([]schemas.User, 0),
		Students:             make([]schemas.User, 0),
		TrainingTags:         make([]schemas.TrainingTag, 0),
		FavoriteForUserUuids: make([]string, 0),
		TopicsTree:           make([]*schemas.TopicTreeNode, 0),
		CreatedAt:            trainingRaw.CreatedAt,
		UpdatedAt:            trainingRaw.UpdatedAt,
	}, err

}

func (ts *TrainingService) DeleteTraining(ctx context.Context, trainingID string) error {
	deleteTrainingRequest := &pb.DeleteTrainingRequest{
		Uuid: trainingID,
	}

	_, err := ts.trainingGRPC.DeleteTraining(ctx, deleteTrainingRequest)
	if err != nil {
		return err
	}

	return nil
}

type GetTrainingListByUserParams struct {
	UserUUID     string
	TrainingType string
}

func (ts *TrainingService) GetTrainingListByUser(ctx context.Context, params *GetTrainingListByUserParams) (*schemas.TrainingList, error) {
	trainingListRaw, err := ts.trainingGRPC.GetTrainingListForUser(ctx, &pb.GetTrainingListForUserRequest{
		UserUuid:     params.UserUUID,
		TrainingType: params.TrainingType,
	})
	if err != nil {
		return &schemas.TrainingList{}, err
	}

	ownerIds := lo.Map(trainingListRaw.TrainingList, func(training *pb.TrainingPreview, _ int) string {
		return training.GetOwner().Uuid
	})

	studentIds := lo.FlatMap(trainingListRaw.TrainingList, func(training *pb.TrainingPreview, _ int) []string {
		return lo.Map(training.TrainingStudents, func(student *pb.User, _ int) string {
			return student.Uuid
		})
	})

	mentorIds := lo.FlatMap(trainingListRaw.TrainingList, func(training *pb.TrainingPreview, _ int) []string {
		return lo.Map(training.TrainingMentors, func(mentor *pb.User, _ int) string {
			return mentor.Uuid
		})
	})
	userUuidsRelatedToTrainings := append(append(studentIds, mentorIds...), ownerIds...)
	usersRelatedToTrainings, _, err := ts.generalAPI.UserAPI.GetUsersByIds(ctx).Request(userUuidsRelatedToTrainings).Execute()
	if err != nil {
		return &schemas.TrainingList{}, err
	}

	usersMap := lo.SliceToMap(usersRelatedToTrainings, func(
		user openapiGeneral.MwServerInternalSchemasShortUser,
	) (string, schemas.User) {
		return user.UserId, schemas.User{
			Uuid:     user.UserId,
			Name:     user.Name,
			ImageUrl: user.ImageUrl,
		}
	})

	mentors := lo.Map(trainingListRaw.TrainingList, func(trainingGrpc *pb.TrainingPreview, i int) []schemas.User {
		return lo.Map(trainingGrpc.GetTrainingMentors(), func(mentor *pb.User, _ int) schemas.User {
			return schemas.User{
				Uuid:     usersMap[mentor.Uuid].Uuid,
				Name:     usersMap[mentor.Uuid].Name,
				ImageUrl: usersMap[mentor.Uuid].ImageUrl,
			}
		})
	})

	trainingsPreview := lo.Map(trainingListRaw.TrainingList, func(trainingGrpc *pb.TrainingPreview, i int) schemas.TrainingPreview {
		trainingTags := lo.Map(trainingGrpc.TrainingTagList, func(tag *pb.TrainingTag, _ int) schemas.TrainingTag {
			return schemas.TrainingTag{Name: tag.TagName}
		})

		return schemas.TrainingPreview{
			Uuid:        trainingGrpc.GetUuid(),
			Name:        trainingGrpc.GetName(),
			Description: trainingGrpc.GetDescription(),
			IsPrivate:   trainingGrpc.GetIsPrivate(),
			Owner: schemas.User{
				Uuid:     usersMap[trainingGrpc.Owner.Uuid].Uuid,
				Name:     usersMap[trainingGrpc.Owner.Uuid].Name,
				ImageUrl: usersMap[trainingGrpc.Owner.Uuid].ImageUrl,
			},
			CreatedAt:              trainingGrpc.GetCreatedAt(),
			UpdatedAt:              trainingGrpc.GetUpdatedAt(),
			TrainingTags:           trainingTags,
			Mentors:                mentors[i],
			StudentsAmount:         int32(len(trainingGrpc.GetTrainingStudents())),
			FavoriteForUsersAmount: trainingGrpc.GetFavoriteCount(),
			TopicsAmount:           trainingGrpc.TopicsAmount,
		}
	})

	for _, training := range trainingsPreview {
		fmt.Printf("%+v\n", training)
	}

	return &schemas.TrainingList{
		Size:      trainingListRaw.Size,
		Trainings: trainingsPreview,
	}, nil
}

type GetTrainingsAmountByUser struct {
	UserUUID string
}

func (ts *TrainingService) GetTrainingsAmountByUserId(ctx context.Context, params *GetTrainingsAmountByUser) (*schemas.TrainingsAmount, error) {
	trainingsAmountRaw, err := ts.trainingGRPC.GetTrainingsAmountByUserId(ctx, &pb.GetTrainingsAmountByUserIdRequest{
		UserUuid: params.UserUUID,
	})
	if err != nil {
		return &schemas.TrainingsAmount{}, err
	}

	return &schemas.TrainingsAmount{
		Owner:    trainingsAmountRaw.GetOwner(),
		Mentor:   trainingsAmountRaw.GetMentor(),
		Student:  trainingsAmountRaw.GetStudent(),
		Favorite: trainingsAmountRaw.GetFavorite(),
	}, nil
}

func CloneTopicTreeNode(node *pb.TopicTreeNode) *schemas.TopicTreeNode {
	if node == nil {
		return nil
	}

	newNode := &schemas.TopicTreeNode{
		Topic: schemas.TopicPreview{
			Uuid:                   node.Topic.Uuid,
			Name:                   node.Topic.Name,
			TrainingUuid:           node.Topic.TrainingUuid,
			TopicOrder:             node.Topic.TopicOrder,
			TheoryMaterialAmount:   node.Topic.TheoryMaterialsAmount,
			PracticeMaterialAmount: node.Topic.PracticeMaterialsAmount,
			ParentUuid:             node.Topic.ParentTopicUuid,
			CreatedAt:              node.Topic.CreatedAt,
		},
		Children: []*schemas.TopicTreeNode{},
	}

	for _, child := range node.Children {
		newNode.Children = append(newNode.Children, CloneTopicTreeNode(child))
	}

	return newNode
}

func (ts *TrainingService) GetTrainingById(ctx context.Context, trainingID string) (*schemas.Training, error) {
	trainingRaw, err := ts.trainingGRPC.GetTrainingById(ctx, &pb.GetTrainingRequest{
		TrainingUuid: trainingID,
	})
	if err != nil {
		return &schemas.Training{}, err
	}

	studentIds := lo.Map(trainingRaw.TrainingStudents, func(student *pb.User, _ int) string {
		return student.Uuid
	})

	mentorIds := lo.Map(trainingRaw.TrainingMentors, func(mentor *pb.User, _ int) string {
		return mentor.Uuid
	})

	userUuidsRelatedToTrainings := append(append(studentIds, mentorIds...), trainingRaw.Owner.Uuid)
	usersRelatedToTrainings, _, err := ts.generalAPI.UserAPI.GetUsersByIds(ctx).Request(userUuidsRelatedToTrainings).Execute()
	if err != nil {
		return &schemas.Training{}, err
	}

	usersMap := lo.SliceToMap(usersRelatedToTrainings, func(
		user openapiGeneral.MwServerInternalSchemasShortUser,
	) (string, schemas.User) {
		return user.UserId, schemas.User{
			Uuid:     user.UserId,
			Name:     user.Name,
			ImageUrl: user.ImageUrl,
		}
	})

	mentors := lo.Map(trainingRaw.GetTrainingMentors(), func(mentor *pb.User, _ int) schemas.User {
		return schemas.User{
			Uuid:     usersMap[mentor.Uuid].Uuid,
			Name:     usersMap[mentor.Uuid].Name,
			ImageUrl: usersMap[mentor.Uuid].ImageUrl,
		}
	})

	students := lo.Map(trainingRaw.GetTrainingStudents(), func(student *pb.User, _ int) schemas.User {
		return schemas.User{
			Uuid:     usersMap[student.Uuid].Uuid,
			Name:     usersMap[student.Uuid].Name,
			ImageUrl: usersMap[student.Uuid].ImageUrl,
		}
	})

	trainingTags := lo.Map(trainingRaw.TrainingTagList, func(tag *pb.TrainingTag, _ int) schemas.TrainingTag {
		return schemas.TrainingTag{Name: tag.TagName}
	})

	favoriteUsers := lo.Map(trainingRaw.FavoriteForUsersPreview, func(userUuid string, _ int) string {
		return userUuid
	})

	topicsTree := lo.Map(trainingRaw.TopicsTree, func(oldTreeNode *pb.TopicTreeNode, _ int) *schemas.TopicTreeNode {
		return CloneTopicTreeNode(oldTreeNode)
	})

	return &schemas.Training{
		Uuid:                 trainingRaw.Uuid,
		Name:                 trainingRaw.Name,
		Description:          trainingRaw.Description,
		IsPrivate:            trainingRaw.IsPrivate,
		Owner:                usersMap[trainingRaw.Owner.Uuid],
		Mentors:              mentors,
		Students:             students,
		TrainingTags:         trainingTags,
		FavoriteForUserUuids: favoriteUsers,
		TopicsTree:           topicsTree,
		CreatedAt:            trainingRaw.CreatedAt,
		UpdatedAt:            trainingRaw.UpdatedAt,
	}, nil
}
