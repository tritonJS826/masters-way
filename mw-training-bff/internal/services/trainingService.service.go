package services

import (
	"context"
	openapiGeneral "mw-training-bff/apiAutogenerated/general"
	"mw-training-bff/internal/schemas"

	"github.com/samber/lo"

	"mw-training-bff/pkg/grpcAutogenerated/training"
	pb "mw-training-bff/pkg/grpcAutogenerated/training"
)

type TrainingService struct {
	trainingGRPC pb.TrainingServiceClient
	generalAPI   *openapiGeneral.APIClient
}

func NewTrainingService(
	trainingGRPC pb.TrainingServiceClient,
	generalAPI *openapiGeneral.APIClient,
) *TrainingService {
	return &TrainingService{trainingGRPC, generalAPI}
}

type GetTrainingListParams struct {
	Page         int
	Limit        int
	TrainingName string
}

func (ts *TrainingService) GetTrainingList(ctx context.Context, params *GetTrainingListParams) (*schemas.TrainingList, error) {
	trainingListRaw, err := ts.trainingGRPC.GetTrainingList(ctx, &pb.GetTrainingListRequest{
		Page:         int32(params.Page),
		Limit:        int32(params.Limit),
		TrainingName: params.TrainingName,
	})
	if err != nil {
		return &schemas.TrainingList{}, err
	}

	ownerIds := lo.Map(trainingListRaw.TrainingList, func(training *pb.Training, _ int) string {
		return training.GetOwner().Uuid
	})
	owners, _, err := ts.generalAPI.UserAPI.GetUsersByIds(ctx).Request(ownerIds).Execute()
	if err != nil {
		return &schemas.TrainingList{}, err
	}

	trainingsPreview := lo.Map(trainingListRaw.TrainingList, func(trainingGrpc *pb.Training, i int) schemas.TrainingPreview {
		return schemas.TrainingPreview{
			Uuid:        trainingGrpc.GetUuid(),
			Name:        trainingGrpc.GetName(),
			Description: trainingGrpc.GetDescription(),
			IsPrivate:   trainingGrpc.GetIsPrivate(),
			Owner: schemas.User{
				Uuid:     owners[i].UserId,
				Name:     owners[i].Name,
				ImageUrl: owners[i].ImageUrl,
			},
			CreatedAt: trainingGrpc.GetCreatedAt(),
			UpdatedAt: trainingGrpc.GetUpdatedAt(),
			// TODO update next line - get rid of stub
			TrainingTags: make([]schemas.TrainingTag, 0),
			// TODO update next line - get rid of stub
			Mentors: make([]schemas.User, 0),
		}
	})

	return &schemas.TrainingList{
		Size:      trainingListRaw.Size,
		Trainings: trainingsPreview,
	}, nil
}

type CreateTrainingParams struct {
	Name        string
	UserId      string
	Description string
	IsPrivate   bool
}

func (ts *TrainingService) CreateTraining(ctx context.Context, params *CreateTrainingParams) (*schemas.Training, error) {
	trainingRaw, err := ts.trainingGRPC.CreateNewTraining(ctx, &pb.CreateTrainingRequest{
		Name:        params.Name,
		UserId:      params.UserId,
		Description: params.Description,
		IsPrivate:   params.IsPrivate,
	})

	if err != nil {
		return &schemas.Training{}, err
	}

	owner := schemas.User{
		Uuid:     trainingRaw.GetOwner().Uuid,
		Name:     trainingRaw.GetOwner().Name,
		ImageUrl: trainingRaw.GetOwner().ImageUrl,
	}

	return &schemas.Training{
		Uuid:                 trainingRaw.Uuid,
		Name:                 trainingRaw.Name,
		Description:          trainingRaw.Description,
		IsPrivate:            trainingRaw.IsPrivate,
		Owner:                owner,
		Mentors:              make([]schemas.User, 0),
		Students:             make([]schemas.User, 0),
		TrainingTags:         make([]schemas.TrainingTag, 0),
		FavoriteForUserUuids: make([]string, 0),
		Topics:               make([]schemas.Topic, 0),
		CreatedAt:            trainingRaw.CreatedAt,
		UpdatedAt:            trainingRaw.UpdatedAt,
	}, err

}

type UpdateTrainingParams struct {
	TrainingUuid string
	Name         string
	Description  string
	IsPrivate    bool
	OwnerUuid    string
}

func (ts *TrainingService) UpdateTraining(ctx context.Context, params *UpdateTrainingParams) (*schemas.Training, error) {
	trainingRaw, err := ts.trainingGRPC.UpdateTraining(ctx, &pb.UpdateTrainingRequest{
		Uuid:        params.TrainingUuid,
		OwnerUuid:   params.OwnerUuid,
		Name:        params.Name,
		Description: params.Description,
		IsPrivate:   params.IsPrivate,
	})

	if err != nil {
		return &schemas.Training{}, err
	}

	owner := schemas.User{
		Uuid:     trainingRaw.GetOwner().Uuid,
		Name:     trainingRaw.GetOwner().Name,
		ImageUrl: trainingRaw.GetOwner().ImageUrl,
	}

	return &schemas.Training{
		Uuid:                 trainingRaw.Uuid,
		Name:                 trainingRaw.Name,
		Description:          trainingRaw.Description,
		IsPrivate:            trainingRaw.IsPrivate,
		Owner:                owner,
		Mentors:              make([]schemas.User, 0),
		Students:             make([]schemas.User, 0),
		TrainingTags:         make([]schemas.TrainingTag, 0),
		FavoriteForUserUuids: make([]string, 0),
		Topics:               make([]schemas.Topic, 0),
		CreatedAt:            trainingRaw.CreatedAt,
		UpdatedAt:            trainingRaw.UpdatedAt,
	}, err

}

func (ts *TrainingService) DeleteTraining(ctx context.Context, trainingID string) error {
	deleteTrainingRequest := &training.DeleteTrainingRequest{
		Uuid: trainingID,
	}

	_, err := ts.trainingGRPC.DeleteTraining(ctx, deleteTrainingRequest)
	if err != nil {
		return err
	}

	return nil
}

type GetTrainingListByUserParams struct {
	UserUUID     string
	TrainingType string
}

func (ts *TrainingService) GetTrainingListByUser(ctx context.Context, params *GetTrainingListByUserParams) (*schemas.TrainingList, error) {
	trainingListRaw, err := ts.trainingGRPC.GetTrainingListForUser(ctx, &pb.GetTrainingListForUserRequest{
		UserUuid:     params.UserUUID,
		TrainingType: params.TrainingType,
	})
	if err != nil {
		return &schemas.TrainingList{}, err
	}

	trainingsPreview := lo.Map(trainingListRaw.TrainingList, func(trainingGrpc *pb.Training, _ int) schemas.TrainingPreview {
		owner := schemas.User{
			Uuid:     trainingGrpc.GetOwner().Uuid,
			Name:     trainingGrpc.GetOwner().Name,
			ImageUrl: trainingGrpc.GetOwner().ImageUrl,
		}

		return schemas.TrainingPreview{
			Uuid:        trainingGrpc.GetUuid(),
			Name:        trainingGrpc.GetName(),
			Description: trainingGrpc.GetDescription(),
			IsPrivate:   trainingGrpc.GetIsPrivate(),
			Owner:       owner,
			CreatedAt:   trainingGrpc.GetCreatedAt(),
			UpdatedAt:   trainingGrpc.GetUpdatedAt(),
		}
	})

	return &schemas.TrainingList{
		Size:      trainingListRaw.Size,
		Trainings: trainingsPreview,
	}, nil
}

func (ts *TrainingService) GetTrainingById(ctx context.Context, trainingID string) (*schemas.Training, error) {
	trainingRaw, err := ts.trainingGRPC.GetTrainingById(ctx, &pb.GetTrainingRequest{
		TrainingUuid: trainingID,
	})
	if err != nil {
		return &schemas.Training{}, err
	}

	owner := schemas.User{
		Uuid:     trainingRaw.GetOwner().Uuid,
		Name:     trainingRaw.GetOwner().Name,
		ImageUrl: trainingRaw.GetOwner().ImageUrl,
	}

	return &schemas.Training{
		Uuid:                 trainingRaw.Uuid,
		Name:                 trainingRaw.Name,
		Description:          trainingRaw.Description,
		IsPrivate:            trainingRaw.IsPrivate,
		Owner:                owner,
		Mentors:              make([]schemas.User, 0),
		Students:             make([]schemas.User, 0),
		TrainingTags:         make([]schemas.TrainingTag, 0),
		FavoriteForUserUuids: make([]string, 0),
		Topics:               make([]schemas.Topic, 0),
		CreatedAt:            trainingRaw.CreatedAt,
		UpdatedAt:            trainingRaw.UpdatedAt,
	}, nil
}
