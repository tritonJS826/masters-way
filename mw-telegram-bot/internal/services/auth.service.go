package services

import (
	"context"
	"fmt"
	"log"
	"mw-telegram-bot/internal/config"

	"github.com/dgrijalva/jwt-go"
	openapiGeneral "mw-telegram-bot/apiAutogenerated/general"
)

type AuthService struct {
	generalAPI *openapiGeneral.APIClient
	config     *config.Config
}

func NewAuthService(generalAPI *openapiGeneral.APIClient, cfg *config.Config) *AuthService {
	return &AuthService{generalAPI: generalAPI, config: cfg}
}

type Claims struct {
	UserID string `json:"userID"`
	jwt.StandardClaims
}

type TelegramLoginResult struct {
	AuthURL string
	Code    string
}

func (as *AuthService) InitiateTelegramLogin(ctx context.Context, telegramID int64, telegramName string) (*TelegramLoginResult, error) {
	req := openapiGeneral.InternalControllersTelegramLoginRequest{
		TelegramId: int32(telegramID),
	}
	if telegramName != "" {
		req.SetTelegramName(telegramName)
	}

	resp, _, err := as.generalAPI.AuthAPI.TelegramInitiate(ctx).Request(req).Execute()
	if err != nil {
		return nil, fmt.Errorf("failed to initiate telegram login: %w", err)
	}

	return &TelegramLoginResult{
		AuthURL: *resp.AuthUrl,
		Code:    *resp.Code,
	}, nil
}

func (as *AuthService) ValidateTelegramLogin(ctx context.Context, code string, telegramID int64, telegramName string) (*openapiGeneral.InternalControllersTelegramValidateResponse, error) {
	req := openapiGeneral.InternalControllersTelegramValidateRequest{
		Code:       code,
		TelegramId: int32(telegramID),
	}
	if telegramName != "" {
		req.SetTelegramName(telegramName)
	}

	resp, _, err := as.generalAPI.AuthAPI.TelegramValidate(ctx).Request(req).Execute()
	if err != nil {
		return nil, fmt.Errorf("failed to validate telegram login: %w", err)
	}

	return resp, nil
}

type LinkedUser struct {
	UserUuid string
	Email    string
	Name     string
	Token    string
}

func (as *AuthService) GetLinkedUser(ctx context.Context, telegramID int64) (*LinkedUser, error) {
	log.Printf("GetLinkedUser: calling API with telegramID=%d", telegramID)
	resp, _, err := as.generalAPI.AuthAPI.GetLinkedUserByTelegramId(ctx, int32(telegramID)).Execute()
	if err != nil {
		log.Printf("GetLinkedUser: error=%v", err)
		return nil, fmt.Errorf("failed to get linked user: %w", err)
	}

	return &LinkedUser{
		UserUuid: *resp.UserUuid,
		Email:    *resp.Email,
		Name:     *resp.Name,
		Token:    resp.GetToken(),
	}, nil
}

func (as *AuthService) UnlinkTelegram(ctx context.Context, telegramID int64) error {
	_, _, err := as.generalAPI.AuthAPI.UnlinkTelegram(ctx, int32(telegramID)).Execute()
	if err != nil {
		return fmt.Errorf("failed to unlink telegram: %w", err)
	}
	return nil
}

type UserWay struct {
	Uuid        string
	Name        string
	IsCompleted bool
}

func (as *AuthService) GetUserWays(ctx context.Context, ownerUuid string) ([]UserWay, error) {
	resp, _, err := as.generalAPI.WayAPI.GetUserOwnWays(ctx, ownerUuid).Execute()
	if err != nil {
		return nil, fmt.Errorf("failed to get user ways: %w", err)
	}

	log.Printf("GetUserWays: ownerUuid=%s, ways count=%d", ownerUuid, len(resp))

	ways := make([]UserWay, len(resp))
	for i, w := range resp {
		ways[i] = UserWay{
			Uuid:        w.Uuid,
			Name:        w.Name,
			IsCompleted: w.IsCompleted,
		}
	}
	return ways, nil
}

type JobDoneResult struct {
	Uuid          string
	CreatedAt     string
	UpdatedAt     string
	Description   string
	Time          int32
	OwnerUuid     string
	OwnerName     string
	DayReportUuid string
	WayUUID       string
	WayName       string
}

func (as *AuthService) CreateJobDone(ctx context.Context, ownerUuid, description, wayUuid string, timeSpent int32) (*JobDoneResult, error) {
	payload := openapiGeneral.MwGeneralBffInternalSchemasCreateJobDoneForTelegramPayload{
		Description: description,
		Time:        timeSpent,
		OwnerUuid:   ownerUuid,
		WayUuid:     wayUuid,
		JobTagUuids: []string{},
	}
	payload.SetCompanionLanguage("en")

	resp, _, err := as.generalAPI.JobDoneAPI.CreateJobDoneTelegram(ctx).Request(payload).Execute()
	if err != nil {
		return nil, fmt.Errorf("failed to create job done: %w", err)
	}

	return &JobDoneResult{
		Uuid:          resp.Uuid,
		CreatedAt:     resp.CreatedAt,
		UpdatedAt:     resp.UpdatedAt,
		Description:   resp.Description,
		Time:          resp.Time,
		OwnerUuid:     resp.OwnerUuid,
		OwnerName:     resp.OwnerName,
		DayReportUuid: resp.DayReportUuid,
		WayUUID:       resp.WayUuid,
		WayName:       resp.WayName,
	}, nil
}
