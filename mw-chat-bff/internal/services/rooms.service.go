package services

import (
	openapiChat "mw-chat-bff/apiAutogenerated/chat"
	openapiGeneral "mw-chat-bff/apiAutogenerated/general"
	"mw-chat-bff/internal/auth"
	"mw-chat-bff/internal/schemas"
	"net/http"

	"github.com/gin-gonic/gin"
	"github.com/samber/lo"
)

type RoomsService struct {
}

func NewRoomsService() *RoomsService {
	return &RoomsService{}
}

type authTransport struct {
	rt http.RoundTripper
}

func (t *authTransport) RoundTrip(req *http.Request) (*http.Response, error) {
	ctx := req.Context()
	if token, ok := ctx.Value(auth.ContextKeyAuthorization).(string); ok {
		req.Header.Set(auth.HeaderKeyAuthorization, token)
	}
	return t.rt.RoundTrip(req)
}

// TODO: 1. Use DI to get rid of such configs
// TODO: 2. Use Envs instead of hardcode
var generalConfig = openapiGeneral.Configuration{
	Host:   "mw-server:8000",
	Scheme: "http",
	Servers: openapiGeneral.ServerConfigurations{
		{
			URL:         "http://mw-server:8000/api",
			Description: "mw-general",
		},
	},
	HTTPClient: &http.Client{
		Transport: &authTransport{rt: http.DefaultTransport},
	},
}
var GeneralApi = openapiGeneral.NewAPIClient(&generalConfig)

var chatConfig = openapiChat.Configuration{
	Host:   "mw-chat:8001",
	Scheme: "http",
	Servers: openapiChat.ServerConfigurations{
		{
			URL:         "http://mw-chat:8001/chat",
			Description: "mw-chat",
		},
	},
	HTTPClient: &http.Client{
		Transport: &authTransport{rt: http.DefaultTransport},
	},
}
var ChatApi = openapiChat.NewAPIClient(&chatConfig)

func (p *RoomsService) GetChatPreview(ctx *gin.Context) (*schemas.GetChatPreviewResponse, error) {
	chatPreviewRaw, _, err := ChatApi.RoomAPI.GetChatPreview(ctx).Execute()
	if err != nil {
		return &schemas.GetChatPreviewResponse{}, err
	}

	chatPreview := schemas.GetChatPreviewResponse{
		UnreadMessagesAmount: chatPreviewRaw.UnreadMessagesAmount,
	}

	return &chatPreview, nil
}

func (p *RoomsService) GetRooms(ctx *gin.Context, roomType string) (*schemas.GetRoomsResponse, error) {
	roomsRaw, _, err := ChatApi.RoomAPI.GetRooms(ctx, roomType).Execute()
	if err != nil {
		return &schemas.GetRoomsResponse{}, err
	}

	rooms := lo.Map(roomsRaw.Rooms, func(rawRoom openapiChat.SchemasRoomPreviewResponse, i int) schemas.RoomPreviewResponse {

		usersPopulated := lo.Map(rawRoom.Users, func(rawUser openapiChat.SchemasUserResponse, i int) schemas.UserResponse {
			return schemas.UserResponse{
				UserID: rawUser.UserId,
				Role:   rawUser.Role,
			}
		})

		response := schemas.RoomPreviewResponse{
			RoomID:    rawRoom.RoomId,
			Name:      rawRoom.Name.Get(),
			IsBlocked: rawRoom.IsBlocked,
			Users:     usersPopulated,
		}

		return response
	})

	roomsPreview := schemas.GetRoomsResponse{
		Size:  roomsRaw.Size,
		Rooms: rooms,
	}
	return &roomsPreview, nil
}

func (p *RoomsService) GetRoomById(ctx *gin.Context, roomUuid string) (*schemas.RoomPopulatedResponse, error) {
	roomRaw, _, err := ChatApi.RoomAPI.GetRoomById(ctx, roomUuid).Execute()
	if err != nil {
		return &schemas.RoomPopulatedResponse{}, err
	}

	messages := lo.Map(roomRaw.Messages, func(messageRaw openapiChat.SchemasMessageResponse, i int) schemas.MessageResponse {

		messageReaders := lo.Map(messageRaw.MessageReaders, func(messageReaderRaw openapiChat.SchemasMessageReaders, i int) schemas.MessageReaders {
			return schemas.MessageReaders{
				UserID:   messageReaderRaw.UserId,
				ReadDate: messageReaderRaw.ReadDate,
			}
		})

		message := schemas.MessageResponse{
			OwnerID: messageRaw.OwnerId,
			Message: messageRaw.Message,
			Readers: messageReaders,
		}

		return message
	})

	users := lo.Map(roomRaw.Users, func(userRaw openapiChat.SchemasUserResponse, i int) schemas.UserResponse {
		return schemas.UserResponse{
			UserID: userRaw.UserId,
			Role:   userRaw.Role,
		}
	})

	roomPopulated := schemas.RoomPopulatedResponse{
		RoomID:    roomRaw.RoomId,
		Name:      roomRaw.Name.Get(),
		Messages:  messages,
		IsBlocked: roomRaw.IsBlocked,
		Users:     users,
		RoomType:  roomRaw.RoomType,
	}
	return &roomPopulated, nil

}

func (p *RoomsService) CreateRoom(ctx *gin.Context, createRoomPayload *schemas.CreateRoomPayload) (*schemas.RoomPopulatedResponse, error) {
	roomRaw, _, err := ChatApi.RoomAPI.CreateRoom(ctx).Execute()
	if err != nil {
		return &schemas.RoomPopulatedResponse{}, err
	}
	messages := lo.Map(roomRaw.Messages, func(messageRaw openapiChat.SchemasMessageResponse, i int) schemas.MessageResponse {

		messageReaders := lo.Map(messageRaw.MessageReaders, func(messageReaderRaw openapiChat.SchemasMessageReaders, i int) schemas.MessageReaders {
			return schemas.MessageReaders{
				UserID:   messageReaderRaw.UserId,
				ReadDate: messageReaderRaw.ReadDate,
			}
		})

		message := schemas.MessageResponse{
			OwnerID: messageRaw.OwnerId,
			Message: messageRaw.Message,
			Readers: messageReaders,
		}

		return message
	})

	users := lo.Map(roomRaw.Users, func(userRaw openapiChat.SchemasUserResponse, i int) schemas.UserResponse {
		return schemas.UserResponse{
			UserID: userRaw.UserId,
			Role:   userRaw.Role,
		}
	})

	roomPopulatedResponse := &schemas.RoomPopulatedResponse{
		RoomID:    roomRaw.RoomId,
		Name:      roomRaw.Name.Get(),
		Messages:  messages,
		IsBlocked: roomRaw.IsBlocked,
		Users:     users,
		RoomType:  roomRaw.RoomType,
	}

	return roomPopulatedResponse, nil
}

func (p *RoomsService) UpdateRoom(ctx *gin.Context, roomId string) (*schemas.RoomPopulatedResponse, error) {
	roomRaw, _, err := ChatApi.RoomAPI.UpdateRoom(ctx, roomId).Execute()
	if err != nil {
		return &schemas.RoomPopulatedResponse{}, err
	}
	messages := lo.Map(roomRaw.Messages, func(messageRaw openapiChat.SchemasMessageResponse, i int) schemas.MessageResponse {

		messageReaders := lo.Map(messageRaw.MessageReaders, func(messageReaderRaw openapiChat.SchemasMessageReaders, i int) schemas.MessageReaders {
			return schemas.MessageReaders{
				UserID:   messageReaderRaw.UserId,
				ReadDate: messageReaderRaw.ReadDate,
			}
		})

		message := schemas.MessageResponse{
			OwnerID: messageRaw.OwnerId,
			Message: messageRaw.Message,
			Readers: messageReaders,
		}

		return message
	})

	users := lo.Map(roomRaw.Users, func(userRaw openapiChat.SchemasUserResponse, i int) schemas.UserResponse {
		return schemas.UserResponse{
			UserID: userRaw.UserId,
			Role:   userRaw.Role,
		}
	})

	roomPopulatedResponse := schemas.RoomPopulatedResponse{
		RoomID:    roomRaw.RoomId,
		Name:      roomRaw.Name.Get(),
		Messages:  messages,
		IsBlocked: roomRaw.IsBlocked,
		Users:     users,
		RoomType:  roomRaw.RoomType,
	}

	return &roomPopulatedResponse, nil
}

func (p *RoomsService) CreateMessage(ctx *gin.Context, roomId string) (*schemas.MessageResponse, error) {
	messageRaw, _, err := ChatApi.RoomAPI.CreateMessageInRoom(ctx, roomId).Execute()
	if err != nil {
		return &schemas.MessageResponse{}, err
	}

	messageReaders := lo.Map(messageRaw.MessageReaders, func(messageReaderRaw openapiChat.SchemasMessageReaders, i int) schemas.MessageReaders {
		return schemas.MessageReaders{
			UserID:   messageReaderRaw.UserId,
			ReadDate: messageReaderRaw.ReadDate,
		}
	})

	message := schemas.MessageResponse{
		OwnerID: messageRaw.OwnerId,
		Message: messageRaw.Message,
		Readers: messageReaders,
	}

	return &message, nil
}

func (p *RoomsService) AddUserToRoom(ctx *gin.Context, roomId string, userId string) (*schemas.RoomPreviewResponse, error) {
	rawRoom, _, err := ChatApi.RoomAPI.AddUserToRoom(ctx, roomId, userId).Execute()
	if err != nil {
		return &schemas.RoomPreviewResponse{}, err
	}

	usersPopulated := lo.Map(rawRoom.Users, func(rawUser openapiChat.SchemasUserResponse, i int) schemas.UserResponse {
		return schemas.UserResponse{
			UserID: rawUser.UserId,
			Role:   rawUser.Role,
		}
	})

	response := schemas.RoomPreviewResponse{
		RoomID:    rawRoom.RoomId,
		Name:      rawRoom.Name.Get(),
		IsBlocked: rawRoom.IsBlocked,
		Users:     usersPopulated,
	}

	return &response, nil
}

func (p *RoomsService) DeleteUserFromRoom(ctx *gin.Context, roomId string, userId string) error {
	_, err := ChatApi.RoomAPI.DeleteUserFromRoom(ctx, roomId, userId).Execute()
	if err != nil {
		return err
	}

	return nil
}
