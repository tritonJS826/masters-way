// @ts-nocheck
/* eslint-disable */
/**
 * Masters way API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  SchemasCommentPlainResponse,
  SchemasCreateCommentPayload,
  SchemasCreateDayReportPayload,
  SchemasCreateFavoriteUserPayload,
  SchemasCreateFavoriteUserWayPayload,
  SchemasCreateFormerMentorWayPayload,
  SchemasCreateFromUserMentoringRequestPayload,
  SchemasCreateJobDoneJobTagPayload,
  SchemasCreateJobDonePayload,
  SchemasCreateJobTagPayload,
  SchemasCreateMetricPayload,
  SchemasCreatePlanJobTagPayload,
  SchemasCreatePlanPayload,
  SchemasCreateProblemJobTagPayload,
  SchemasCreateProblemPayload,
  SchemasCreateUserMentoringRequestPayload,
  SchemasCreateUserPayload,
  SchemasCreateUserTagPayload,
  SchemasCreateWay,
  SchemasCreateWayCollectionPayload,
  SchemasCreateWayCollectionWay,
  SchemasCreateWayTagPayload,
  SchemasDayReportPlainResponse,
  SchemasJobDonePlainResponse,
  SchemasJobTagResponse,
  SchemasMetricResponse,
  SchemasPlanPlainResponse,
  SchemasProblemPlainResponse,
  SchemasUpdateCommentPayload,
  SchemasUpdateDayReportPayload,
  SchemasUpdateJobDone,
  SchemasUpdateJobTagPayload,
  SchemasUpdateMetricPayload,
  SchemasUpdatePlanPayload,
  SchemasUpdateProblemPayload,
  SchemasUpdateUserPayload,
  SchemasUpdateUserTagPayload,
  SchemasUpdateWayCollectionPayload,
  SchemasUpdateWayPayload,
  SchemasUpdateWayTagPayload,
  SchemasUserPlainResponse,
  SchemasUserPopulatedResponse,
  SchemasUserTagResponse,
  SchemasWayCollectionPlainResponse,
  SchemasWayPlainResponse,
  SchemasWayPopulatedResponse,
  SchemasWayTagResponse,
} from '../models/index';
import {
    SchemasCommentPlainResponseFromJSON,
    SchemasCommentPlainResponseToJSON,
    SchemasCreateCommentPayloadFromJSON,
    SchemasCreateCommentPayloadToJSON,
    SchemasCreateDayReportPayloadFromJSON,
    SchemasCreateDayReportPayloadToJSON,
    SchemasCreateFavoriteUserPayloadFromJSON,
    SchemasCreateFavoriteUserPayloadToJSON,
    SchemasCreateFavoriteUserWayPayloadFromJSON,
    SchemasCreateFavoriteUserWayPayloadToJSON,
    SchemasCreateFormerMentorWayPayloadFromJSON,
    SchemasCreateFormerMentorWayPayloadToJSON,
    SchemasCreateFromUserMentoringRequestPayloadFromJSON,
    SchemasCreateFromUserMentoringRequestPayloadToJSON,
    SchemasCreateJobDoneJobTagPayloadFromJSON,
    SchemasCreateJobDoneJobTagPayloadToJSON,
    SchemasCreateJobDonePayloadFromJSON,
    SchemasCreateJobDonePayloadToJSON,
    SchemasCreateJobTagPayloadFromJSON,
    SchemasCreateJobTagPayloadToJSON,
    SchemasCreateMetricPayloadFromJSON,
    SchemasCreateMetricPayloadToJSON,
    SchemasCreatePlanJobTagPayloadFromJSON,
    SchemasCreatePlanJobTagPayloadToJSON,
    SchemasCreatePlanPayloadFromJSON,
    SchemasCreatePlanPayloadToJSON,
    SchemasCreateProblemJobTagPayloadFromJSON,
    SchemasCreateProblemJobTagPayloadToJSON,
    SchemasCreateProblemPayloadFromJSON,
    SchemasCreateProblemPayloadToJSON,
    SchemasCreateUserMentoringRequestPayloadFromJSON,
    SchemasCreateUserMentoringRequestPayloadToJSON,
    SchemasCreateUserPayloadFromJSON,
    SchemasCreateUserPayloadToJSON,
    SchemasCreateUserTagPayloadFromJSON,
    SchemasCreateUserTagPayloadToJSON,
    SchemasCreateWayFromJSON,
    SchemasCreateWayToJSON,
    SchemasCreateWayCollectionPayloadFromJSON,
    SchemasCreateWayCollectionPayloadToJSON,
    SchemasCreateWayCollectionWayFromJSON,
    SchemasCreateWayCollectionWayToJSON,
    SchemasCreateWayTagPayloadFromJSON,
    SchemasCreateWayTagPayloadToJSON,
    SchemasDayReportPlainResponseFromJSON,
    SchemasDayReportPlainResponseToJSON,
    SchemasJobDonePlainResponseFromJSON,
    SchemasJobDonePlainResponseToJSON,
    SchemasJobTagResponseFromJSON,
    SchemasJobTagResponseToJSON,
    SchemasMetricResponseFromJSON,
    SchemasMetricResponseToJSON,
    SchemasPlanPlainResponseFromJSON,
    SchemasPlanPlainResponseToJSON,
    SchemasProblemPlainResponseFromJSON,
    SchemasProblemPlainResponseToJSON,
    SchemasUpdateCommentPayloadFromJSON,
    SchemasUpdateCommentPayloadToJSON,
    SchemasUpdateDayReportPayloadFromJSON,
    SchemasUpdateDayReportPayloadToJSON,
    SchemasUpdateJobDoneFromJSON,
    SchemasUpdateJobDoneToJSON,
    SchemasUpdateJobTagPayloadFromJSON,
    SchemasUpdateJobTagPayloadToJSON,
    SchemasUpdateMetricPayloadFromJSON,
    SchemasUpdateMetricPayloadToJSON,
    SchemasUpdatePlanPayloadFromJSON,
    SchemasUpdatePlanPayloadToJSON,
    SchemasUpdateProblemPayloadFromJSON,
    SchemasUpdateProblemPayloadToJSON,
    SchemasUpdateUserPayloadFromJSON,
    SchemasUpdateUserPayloadToJSON,
    SchemasUpdateUserTagPayloadFromJSON,
    SchemasUpdateUserTagPayloadToJSON,
    SchemasUpdateWayCollectionPayloadFromJSON,
    SchemasUpdateWayCollectionPayloadToJSON,
    SchemasUpdateWayPayloadFromJSON,
    SchemasUpdateWayPayloadToJSON,
    SchemasUpdateWayTagPayloadFromJSON,
    SchemasUpdateWayTagPayloadToJSON,
    SchemasUserPlainResponseFromJSON,
    SchemasUserPlainResponseToJSON,
    SchemasUserPopulatedResponseFromJSON,
    SchemasUserPopulatedResponseToJSON,
    SchemasUserTagResponseFromJSON,
    SchemasUserTagResponseToJSON,
    SchemasWayCollectionPlainResponseFromJSON,
    SchemasWayCollectionPlainResponseToJSON,
    SchemasWayPlainResponseFromJSON,
    SchemasWayPlainResponseToJSON,
    SchemasWayPopulatedResponseFromJSON,
    SchemasWayPopulatedResponseToJSON,
    SchemasWayTagResponseFromJSON,
    SchemasWayTagResponseToJSON,
} from '../models/index';

export interface CreateCommentRequest {
    request: SchemasCreateCommentPayload;
}

export interface CreateDayReportRequest {
    request: SchemasCreateDayReportPayload;
}

export interface CreateFavoriteUserRequest {
    request: SchemasCreateFavoriteUserPayload;
}

export interface CreateFavoriteUserWayRequest {
    request: SchemasCreateFavoriteUserWayPayload;
}

export interface CreateFormerMentorWayRequest {
    request: SchemasCreateFormerMentorWayPayload;
}

export interface CreateFromUserMentoringRequestRequest {
    request: SchemasCreateFromUserMentoringRequestPayload;
}

export interface CreateJobDoneRequest {
    request: SchemasCreateJobDonePayload;
}

export interface CreateJobDoneJobTagRequest {
    request: SchemasCreateJobDoneJobTagPayload;
}

export interface CreateJobTagRequest {
    request: SchemasCreateJobTagPayload;
}

export interface CreateMetricRequest {
    request: SchemasCreateMetricPayload;
}

export interface CreatePlanRequest {
    request: SchemasCreatePlanPayload;
}

export interface CreatePlanJobTagRequest {
    request: SchemasCreatePlanJobTagPayload;
}

export interface CreateProblemRequest {
    request: SchemasCreateProblemPayload;
}

export interface CreateProblemJobTagRequest {
    request: SchemasCreateProblemJobTagPayload;
}

export interface CreateUserRequest {
    request: SchemasCreateUserPayload;
}

export interface CreateUserMentoringRequestRequest {
    request: SchemasCreateUserMentoringRequestPayload;
}

export interface CreateUserTagRequest {
    request: SchemasCreateUserTagPayload;
}

export interface CreateWayRequest {
    request: SchemasCreateWay;
}

export interface CreateWayCollectionRequest {
    request: SchemasCreateWayCollectionPayload;
}

export interface CreateWayCollectionWayRequest {
    request: SchemasCreateWayCollectionWay;
}

export interface CreateWayTagRequest {
    request: SchemasCreateWayTagPayload;
}

export interface DeleteCommentRequest {
    commentId: string;
}

export interface DeleteFavoriteUserRequest {
    donorUserUuid: string;
    acceptorUserUuid: string;
}

export interface DeleteFavoriteUserWayRequest {
    userUuid: string;
    wayUuid: string;
}

export interface DeleteFromUserMentoringRequestRequest {
    userUuid: string;
    wayUuid: string;
}

export interface DeleteJobDoneRequest {
    jobDoneId: string;
}

export interface DeleteJobDoneJobTagRequest {
    jobDoneId: string;
    jobTagId: string;
}

export interface DeleteJobTagRequest {
    jobTagId: string;
}

export interface DeleteMetricRequest {
    metricId: string;
}

export interface DeletePlanRequest {
    planId: string;
}

export interface DeletePlanJobTagRequest {
    jobTagId: string;
    planId: string;
}

export interface DeleteProblemRequest {
    problemId: string;
}

export interface DeleteProblemJobTagRequest {
    problemId: string;
    jobTagId: string;
}

export interface DeleteToUserMentoringRequestRequest {
    userUuid: string;
    wayUuid: string;
}

export interface DeleteUserRequest {
    userId: string;
}

export interface DeleteUserTagRequest {
    userTagId: string;
}

export interface DeleteWayRequest {
    wayId: string;
}

export interface DeleteWayCollectionRequest {
    wayCollectionId: string;
}

export interface DeleteWayCollectionWayRequest {
    wayCollectionId: string;
    wayId: string;
}

export interface DeleteWayTagRequest {
    wayTagId: string;
}

export interface GetCommentsByDayReportUuidRequest {
    dayReportId: string;
}

export interface GetDayReportsByWayUuidRequest {
    wayId: string;
}

export interface GetJobDonesByDayReportUuidRequest {
    dayReportId: string;
}

export interface GetJobTagsByWayUuidRequest {
    wayId: string;
}

export interface GetMetricsByWayUuidRequest {
    wayId: string;
}

export interface GetPlansByDayReportUuidRequest {
    dayReportId: string;
}

export interface GetProblemsByDayReportUuidRequest {
    dayReportId: string;
}

export interface GetUserByUuidRequest {
    userId: string;
}

export interface GetUserTagsByUserUuidRequest {
    userId: string;
}

export interface GetWayByUuidRequest {
    wayId: string;
}

export interface GetWayCollectionsByUserUuidRequest {
    userId: string;
}

export interface GetWayTagsByWayUuidRequest {
    wayId: string;
}

export interface UpdateCommentRequest {
    commentId: string;
    request: SchemasUpdateCommentPayload;
}

export interface UpdateDayReportRequest {
    dayReportId: string;
    request: SchemasUpdateDayReportPayload;
}

export interface UpdateJobDoneRequest {
    jobDoneId: string;
    request: SchemasUpdateJobDone;
}

export interface UpdateJobTagRequest {
    jobTagId: string;
    request: SchemasUpdateJobTagPayload;
}

export interface UpdateMetricRequest {
    metricId: string;
    request: SchemasUpdateMetricPayload;
}

export interface UpdatePlanRequest {
    planId: string;
    request: SchemasUpdatePlanPayload;
}

export interface UpdateProblemRequest {
    problemId: string;
    request: SchemasUpdateProblemPayload;
}

export interface UpdateUserRequest {
    userId: string;
    request: SchemasUpdateUserPayload;
}

export interface UpdateUserTagRequest {
    userTagId: string;
    request: SchemasUpdateUserTagPayload;
}

export interface UpdateWayRequest {
    wayId: string;
    request: SchemasUpdateWayPayload;
}

export interface UpdateWayCollectionRequest {
    wayCollectionId: string;
    request: SchemasUpdateWayCollectionPayload;
}

export interface UpdateWayTagRequest {
    wayTagId: string;
    request: SchemasUpdateWayTagPayload;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Create a new comment
     */
    async createCommentRaw(requestParameters: CreateCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasCommentPlainResponse>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/comments`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateCommentPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasCommentPlainResponseFromJSON(jsonValue));
    }

    /**
     * Create a new comment
     */
    async createComment(requestParameters: CreateCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasCommentPlainResponse> {
        const response = await this.createCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new dayReport
     */
    async createDayReportRaw(requestParameters: CreateDayReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasDayReportPlainResponse>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createDayReport.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/dayReports`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateDayReportPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasDayReportPlainResponseFromJSON(jsonValue));
    }

    /**
     * Create a new dayReport
     */
    async createDayReport(requestParameters: CreateDayReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasDayReportPlainResponse> {
        const response = await this.createDayReportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new favorite user
     */
    async createFavoriteUserRaw(requestParameters: CreateFavoriteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createFavoriteUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/favoriteUsers`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateFavoriteUserPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new favorite user
     */
    async createFavoriteUser(requestParameters: CreateFavoriteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createFavoriteUserRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new favoriteUserWay
     */
    async createFavoriteUserWayRaw(requestParameters: CreateFavoriteUserWayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createFavoriteUserWay.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/favoriteUserWays`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateFavoriteUserWayPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new favoriteUserWay
     */
    async createFavoriteUserWay(requestParameters: CreateFavoriteUserWayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createFavoriteUserWayRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new formerMentorWay
     */
    async createFormerMentorWayRaw(requestParameters: CreateFormerMentorWayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createFormerMentorWay.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/formerMentorWayWays`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateFormerMentorWayPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new formerMentorWay
     */
    async createFormerMentorWay(requestParameters: CreateFormerMentorWayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createFormerMentorWayRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new fromUserMentoringRequest
     */
    async createFromUserMentoringRequestRaw(requestParameters: CreateFromUserMentoringRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createFromUserMentoringRequest.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/fromUserMentoringRequests`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateFromUserMentoringRequestPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new fromUserMentoringRequest
     */
    async createFromUserMentoringRequest(requestParameters: CreateFromUserMentoringRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createFromUserMentoringRequestRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new jobDone
     */
    async createJobDoneRaw(requestParameters: CreateJobDoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasJobDonePlainResponse>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createJobDone.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/jobDones`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateJobDonePayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasJobDonePlainResponseFromJSON(jsonValue));
    }

    /**
     * Create a new jobDone
     */
    async createJobDone(requestParameters: CreateJobDoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasJobDonePlainResponse> {
        const response = await this.createJobDoneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new jobDoneJobTag
     */
    async createJobDoneJobTagRaw(requestParameters: CreateJobDoneJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createJobDoneJobTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/jobDoneJobTags`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateJobDoneJobTagPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new jobDoneJobTag
     */
    async createJobDoneJobTag(requestParameters: CreateJobDoneJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createJobDoneJobTagRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new jobTag
     */
    async createJobTagRaw(requestParameters: CreateJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasJobTagResponse>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createJobTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/jobTags`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateJobTagPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasJobTagResponseFromJSON(jsonValue));
    }

    /**
     * Create a new jobTag
     */
    async createJobTag(requestParameters: CreateJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasJobTagResponse> {
        const response = await this.createJobTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new metric
     */
    async createMetricRaw(requestParameters: CreateMetricRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasMetricResponse>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createMetric.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/metrics`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateMetricPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasMetricResponseFromJSON(jsonValue));
    }

    /**
     * Create a new metric
     */
    async createMetric(requestParameters: CreateMetricRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasMetricResponse> {
        const response = await this.createMetricRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new plan
     */
    async createPlanRaw(requestParameters: CreatePlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasPlanPlainResponse>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createPlan.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/plans`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreatePlanPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasPlanPlainResponseFromJSON(jsonValue));
    }

    /**
     * Create a new plan
     */
    async createPlan(requestParameters: CreatePlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasPlanPlainResponse> {
        const response = await this.createPlanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new planJobTag
     */
    async createPlanJobTagRaw(requestParameters: CreatePlanJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createPlanJobTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/planJobTags`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreatePlanJobTagPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new planJobTag
     */
    async createPlanJobTag(requestParameters: CreatePlanJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createPlanJobTagRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new problem
     */
    async createProblemRaw(requestParameters: CreateProblemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasProblemPlainResponse>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createProblem.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/problems`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateProblemPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasProblemPlainResponseFromJSON(jsonValue));
    }

    /**
     * Create a new problem
     */
    async createProblem(requestParameters: CreateProblemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasProblemPlainResponse> {
        const response = await this.createProblemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new problemJobTag
     */
    async createProblemJobTagRaw(requestParameters: CreateProblemJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createProblemJobTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/problemJobTags`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateProblemJobTagPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new problemJobTag
     */
    async createProblemJobTag(requestParameters: CreateProblemJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createProblemJobTagRaw(requestParameters, initOverrides);
    }

    /**
     * Email should be unique
     * Create a new user
     */
    async createUserRaw(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasUserPlainResponse>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/users`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateUserPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasUserPlainResponseFromJSON(jsonValue));
    }

    /**
     * Email should be unique
     * Create a new user
     */
    async createUser(requestParameters: CreateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasUserPlainResponse> {
        const response = await this.createUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new userMentoringRequest
     */
    async createUserMentoringRequestRaw(requestParameters: CreateUserMentoringRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createUserMentoringRequest.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/toUserMentoringRequests`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateUserMentoringRequestPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new userMentoringRequest
     */
    async createUserMentoringRequest(requestParameters: CreateUserMentoringRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createUserMentoringRequestRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new userTag
     */
    async createUserTagRaw(requestParameters: CreateUserTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasUserTagResponse>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createUserTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/usersTags`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateUserTagPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasUserTagResponseFromJSON(jsonValue));
    }

    /**
     * Create a new userTag
     */
    async createUserTag(requestParameters: CreateUserTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasUserTagResponse> {
        const response = await this.createUserTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new way
     */
    async createWayRaw(requestParameters: CreateWayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasWayPlainResponse>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createWay.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/ways`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateWayToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasWayPlainResponseFromJSON(jsonValue));
    }

    /**
     * Create a new way
     */
    async createWay(requestParameters: CreateWayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasWayPlainResponse> {
        const response = await this.createWayRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new wayCollection
     */
    async createWayCollectionRaw(requestParameters: CreateWayCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasWayCollectionPlainResponse>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createWayCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/wayCollections`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateWayCollectionPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasWayCollectionPlainResponseFromJSON(jsonValue));
    }

    /**
     * Create a new wayCollection
     */
    async createWayCollection(requestParameters: CreateWayCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasWayCollectionPlainResponse> {
        const response = await this.createWayCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Create a new wayCollectionWay
     */
    async createWayCollectionWayRaw(requestParameters: CreateWayCollectionWayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createWayCollectionWay.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/wayCollectionWays`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateWayCollectionWayToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Create a new wayCollectionWay
     */
    async createWayCollectionWay(requestParameters: CreateWayCollectionWayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.createWayCollectionWayRaw(requestParameters, initOverrides);
    }

    /**
     * Create a new wayTag
     */
    async createWayTagRaw(requestParameters: CreateWayTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasWayTagResponse>> {
        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling createWayTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/wayTags`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasCreateWayTagPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasWayTagResponseFromJSON(jsonValue));
    }

    /**
     * Create a new wayTag
     */
    async createWayTag(requestParameters: CreateWayTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasWayTagResponse> {
        const response = await this.createWayTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Delete comment by UUID
     */
    async deleteCommentRaw(requestParameters: DeleteCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.commentId === null || requestParameters.commentId === undefined) {
            throw new runtime.RequiredError('commentId','Required parameter requestParameters.commentId was null or undefined when calling deleteComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/comments/{commentId}`.replace(`{${"commentId"}}`, encodeURIComponent(String(requestParameters.commentId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete comment by UUID
     */
    async deleteComment(requestParameters: DeleteCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteCommentRaw(requestParameters, initOverrides);
    }

    /**
     * Delete favoriteUser by UUID
     */
    async deleteFavoriteUserRaw(requestParameters: DeleteFavoriteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.donorUserUuid === null || requestParameters.donorUserUuid === undefined) {
            throw new runtime.RequiredError('donorUserUuid','Required parameter requestParameters.donorUserUuid was null or undefined when calling deleteFavoriteUser.');
        }

        if (requestParameters.acceptorUserUuid === null || requestParameters.acceptorUserUuid === undefined) {
            throw new runtime.RequiredError('acceptorUserUuid','Required parameter requestParameters.acceptorUserUuid was null or undefined when calling deleteFavoriteUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/favoriteUsers/{donorUserUuid}/{acceptorUserUuid}`.replace(`{${"donorUserUuid"}}`, encodeURIComponent(String(requestParameters.donorUserUuid))).replace(`{${"acceptorUserUuid"}}`, encodeURIComponent(String(requestParameters.acceptorUserUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete favoriteUser by UUID
     */
    async deleteFavoriteUser(requestParameters: DeleteFavoriteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteFavoriteUserRaw(requestParameters, initOverrides);
    }

    /**
     * Delete favoriteUserWay by UUID
     */
    async deleteFavoriteUserWayRaw(requestParameters: DeleteFavoriteUserWayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.userUuid === null || requestParameters.userUuid === undefined) {
            throw new runtime.RequiredError('userUuid','Required parameter requestParameters.userUuid was null or undefined when calling deleteFavoriteUserWay.');
        }

        if (requestParameters.wayUuid === null || requestParameters.wayUuid === undefined) {
            throw new runtime.RequiredError('wayUuid','Required parameter requestParameters.wayUuid was null or undefined when calling deleteFavoriteUserWay.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/favoriteUserWays/{userUuid}/{wayUuid}`.replace(`{${"userUuid"}}`, encodeURIComponent(String(requestParameters.userUuid))).replace(`{${"wayUuid"}}`, encodeURIComponent(String(requestParameters.wayUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete favoriteUserWay by UUID
     */
    async deleteFavoriteUserWay(requestParameters: DeleteFavoriteUserWayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteFavoriteUserWayRaw(requestParameters, initOverrides);
    }

    /**
     * Delete fromUserMentoringRequest by UUID
     */
    async deleteFromUserMentoringRequestRaw(requestParameters: DeleteFromUserMentoringRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.userUuid === null || requestParameters.userUuid === undefined) {
            throw new runtime.RequiredError('userUuid','Required parameter requestParameters.userUuid was null or undefined when calling deleteFromUserMentoringRequest.');
        }

        if (requestParameters.wayUuid === null || requestParameters.wayUuid === undefined) {
            throw new runtime.RequiredError('wayUuid','Required parameter requestParameters.wayUuid was null or undefined when calling deleteFromUserMentoringRequest.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/fromUserMentoringRequests/{userUuid}/{wayUuid}`.replace(`{${"userUuid"}}`, encodeURIComponent(String(requestParameters.userUuid))).replace(`{${"wayUuid"}}`, encodeURIComponent(String(requestParameters.wayUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete fromUserMentoringRequest by UUID
     */
    async deleteFromUserMentoringRequest(requestParameters: DeleteFromUserMentoringRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteFromUserMentoringRequestRaw(requestParameters, initOverrides);
    }

    /**
     * Delete jobDone by UUID
     */
    async deleteJobDoneRaw(requestParameters: DeleteJobDoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.jobDoneId === null || requestParameters.jobDoneId === undefined) {
            throw new runtime.RequiredError('jobDoneId','Required parameter requestParameters.jobDoneId was null or undefined when calling deleteJobDone.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/jobDones/{jobDoneId}`.replace(`{${"jobDoneId"}}`, encodeURIComponent(String(requestParameters.jobDoneId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete jobDone by UUID
     */
    async deleteJobDone(requestParameters: DeleteJobDoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteJobDoneRaw(requestParameters, initOverrides);
    }

    /**
     * Delete jobDoneJobTag by UUID
     */
    async deleteJobDoneJobTagRaw(requestParameters: DeleteJobDoneJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.jobDoneId === null || requestParameters.jobDoneId === undefined) {
            throw new runtime.RequiredError('jobDoneId','Required parameter requestParameters.jobDoneId was null or undefined when calling deleteJobDoneJobTag.');
        }

        if (requestParameters.jobTagId === null || requestParameters.jobTagId === undefined) {
            throw new runtime.RequiredError('jobTagId','Required parameter requestParameters.jobTagId was null or undefined when calling deleteJobDoneJobTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/jobDoneJobTags/{jobTagId}/{jobDoneId}`.replace(`{${"jobDoneId"}}`, encodeURIComponent(String(requestParameters.jobDoneId))).replace(`{${"jobTagId"}}`, encodeURIComponent(String(requestParameters.jobTagId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete jobDoneJobTag by UUID
     */
    async deleteJobDoneJobTag(requestParameters: DeleteJobDoneJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteJobDoneJobTagRaw(requestParameters, initOverrides);
    }

    /**
     * Delete jobTag by UUID
     */
    async deleteJobTagRaw(requestParameters: DeleteJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.jobTagId === null || requestParameters.jobTagId === undefined) {
            throw new runtime.RequiredError('jobTagId','Required parameter requestParameters.jobTagId was null or undefined when calling deleteJobTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/jobTags/{jobTagId}`.replace(`{${"jobTagId"}}`, encodeURIComponent(String(requestParameters.jobTagId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete jobTag by UUID
     */
    async deleteJobTag(requestParameters: DeleteJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteJobTagRaw(requestParameters, initOverrides);
    }

    /**
     * Delete metric by UUID
     */
    async deleteMetricRaw(requestParameters: DeleteMetricRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.metricId === null || requestParameters.metricId === undefined) {
            throw new runtime.RequiredError('metricId','Required parameter requestParameters.metricId was null or undefined when calling deleteMetric.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/metrics/{metricId}`.replace(`{${"metricId"}}`, encodeURIComponent(String(requestParameters.metricId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete metric by UUID
     */
    async deleteMetric(requestParameters: DeleteMetricRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteMetricRaw(requestParameters, initOverrides);
    }

    /**
     * Delete plan by UUID
     */
    async deletePlanRaw(requestParameters: DeletePlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.planId === null || requestParameters.planId === undefined) {
            throw new runtime.RequiredError('planId','Required parameter requestParameters.planId was null or undefined when calling deletePlan.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/plans/{planId}`.replace(`{${"planId"}}`, encodeURIComponent(String(requestParameters.planId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete plan by UUID
     */
    async deletePlan(requestParameters: DeletePlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePlanRaw(requestParameters, initOverrides);
    }

    /**
     * Delete planJobTag by UUID
     */
    async deletePlanJobTagRaw(requestParameters: DeletePlanJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.jobTagId === null || requestParameters.jobTagId === undefined) {
            throw new runtime.RequiredError('jobTagId','Required parameter requestParameters.jobTagId was null or undefined when calling deletePlanJobTag.');
        }

        if (requestParameters.planId === null || requestParameters.planId === undefined) {
            throw new runtime.RequiredError('planId','Required parameter requestParameters.planId was null or undefined when calling deletePlanJobTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/planJobTags/{jobTagId}/{planId}`.replace(`{${"jobTagId"}}`, encodeURIComponent(String(requestParameters.jobTagId))).replace(`{${"planId"}}`, encodeURIComponent(String(requestParameters.planId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete planJobTag by UUID
     */
    async deletePlanJobTag(requestParameters: DeletePlanJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deletePlanJobTagRaw(requestParameters, initOverrides);
    }

    /**
     * Delete problem by UUID
     */
    async deleteProblemRaw(requestParameters: DeleteProblemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.problemId === null || requestParameters.problemId === undefined) {
            throw new runtime.RequiredError('problemId','Required parameter requestParameters.problemId was null or undefined when calling deleteProblem.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/problems/{problemId}`.replace(`{${"problemId"}}`, encodeURIComponent(String(requestParameters.problemId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete problem by UUID
     */
    async deleteProblem(requestParameters: DeleteProblemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteProblemRaw(requestParameters, initOverrides);
    }

    /**
     * Delete problemJobTag by UUID
     */
    async deleteProblemJobTagRaw(requestParameters: DeleteProblemJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.problemId === null || requestParameters.problemId === undefined) {
            throw new runtime.RequiredError('problemId','Required parameter requestParameters.problemId was null or undefined when calling deleteProblemJobTag.');
        }

        if (requestParameters.jobTagId === null || requestParameters.jobTagId === undefined) {
            throw new runtime.RequiredError('jobTagId','Required parameter requestParameters.jobTagId was null or undefined when calling deleteProblemJobTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/problemJobTags/{jobTagId}/{problemId}`.replace(`{${"problemId"}}`, encodeURIComponent(String(requestParameters.problemId))).replace(`{${"jobTagId"}}`, encodeURIComponent(String(requestParameters.jobTagId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete problemJobTag by UUID
     */
    async deleteProblemJobTag(requestParameters: DeleteProblemJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteProblemJobTagRaw(requestParameters, initOverrides);
    }

    /**
     * Delete toUserMentoringReques by UUID
     */
    async deleteToUserMentoringRequestRaw(requestParameters: DeleteToUserMentoringRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.userUuid === null || requestParameters.userUuid === undefined) {
            throw new runtime.RequiredError('userUuid','Required parameter requestParameters.userUuid was null or undefined when calling deleteToUserMentoringRequest.');
        }

        if (requestParameters.wayUuid === null || requestParameters.wayUuid === undefined) {
            throw new runtime.RequiredError('wayUuid','Required parameter requestParameters.wayUuid was null or undefined when calling deleteToUserMentoringRequest.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/toUserMentoringRequests/{userUuid}/{wayUuid}`.replace(`{${"userUuid"}}`, encodeURIComponent(String(requestParameters.userUuid))).replace(`{${"wayUuid"}}`, encodeURIComponent(String(requestParameters.wayUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete toUserMentoringReques by UUID
     */
    async deleteToUserMentoringRequest(requestParameters: DeleteToUserMentoringRequestRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteToUserMentoringRequestRaw(requestParameters, initOverrides);
    }

    /**
     * Delete user by UUID
     */
    async deleteUserRaw(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling deleteUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{userId}`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete user by UUID
     */
    async deleteUser(requestParameters: DeleteUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteUserRaw(requestParameters, initOverrides);
    }

    /**
     * Delete userTag by UUID
     */
    async deleteUserTagRaw(requestParameters: DeleteUserTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.userTagId === null || requestParameters.userTagId === undefined) {
            throw new runtime.RequiredError('userTagId','Required parameter requestParameters.userTagId was null or undefined when calling deleteUserTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/userTags/{userTagId}`.replace(`{${"userTagId"}}`, encodeURIComponent(String(requestParameters.userTagId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete userTag by UUID
     */
    async deleteUserTag(requestParameters: DeleteUserTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteUserTagRaw(requestParameters, initOverrides);
    }

    /**
     * Delete way by UUID
     */
    async deleteWayRaw(requestParameters: DeleteWayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.wayId === null || requestParameters.wayId === undefined) {
            throw new runtime.RequiredError('wayId','Required parameter requestParameters.wayId was null or undefined when calling deleteWay.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ways/{wayId}`.replace(`{${"wayId"}}`, encodeURIComponent(String(requestParameters.wayId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete way by UUID
     */
    async deleteWay(requestParameters: DeleteWayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteWayRaw(requestParameters, initOverrides);
    }

    /**
     * Delete wayCollection by UUID
     */
    async deleteWayCollectionRaw(requestParameters: DeleteWayCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.wayCollectionId === null || requestParameters.wayCollectionId === undefined) {
            throw new runtime.RequiredError('wayCollectionId','Required parameter requestParameters.wayCollectionId was null or undefined when calling deleteWayCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/wayCollections/{wayCollectionId}`.replace(`{${"wayCollectionId"}}`, encodeURIComponent(String(requestParameters.wayCollectionId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete wayCollection by UUID
     */
    async deleteWayCollection(requestParameters: DeleteWayCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteWayCollectionRaw(requestParameters, initOverrides);
    }

    /**
     * Delete wayCollectionWay by UUID
     */
    async deleteWayCollectionWayRaw(requestParameters: DeleteWayCollectionWayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.wayCollectionId === null || requestParameters.wayCollectionId === undefined) {
            throw new runtime.RequiredError('wayCollectionId','Required parameter requestParameters.wayCollectionId was null or undefined when calling deleteWayCollectionWay.');
        }

        if (requestParameters.wayId === null || requestParameters.wayId === undefined) {
            throw new runtime.RequiredError('wayId','Required parameter requestParameters.wayId was null or undefined when calling deleteWayCollectionWay.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/wayCollectionWays/{wayId}/{wayCollectionId}`.replace(`{${"wayCollectionId"}}`, encodeURIComponent(String(requestParameters.wayCollectionId))).replace(`{${"wayId"}}`, encodeURIComponent(String(requestParameters.wayId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete wayCollectionWay by UUID
     */
    async deleteWayCollectionWay(requestParameters: DeleteWayCollectionWayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteWayCollectionWayRaw(requestParameters, initOverrides);
    }

    /**
     * Delete wayTag by UUID
     */
    async deleteWayTagRaw(requestParameters: DeleteWayTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.wayTagId === null || requestParameters.wayTagId === undefined) {
            throw new runtime.RequiredError('wayTagId','Required parameter requestParameters.wayTagId was null or undefined when calling deleteWayTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/wayTags/{wayTagId}`.replace(`{${"wayTagId"}}`, encodeURIComponent(String(requestParameters.wayTagId))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Delete wayTag by UUID
     */
    async deleteWayTag(requestParameters: DeleteWayTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.deleteWayTagRaw(requestParameters, initOverrides);
    }

    /**
     * Get users with pagination
     * Get all users
     */
    async getAllUsersRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SchemasUserPlainResponse>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SchemasUserPlainResponseFromJSON));
    }

    /**
     * Get users with pagination
     * Get all users
     */
    async getAllUsers(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SchemasUserPlainResponse>> {
        const response = await this.getAllUsersRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get ways with pagination
     * Get all ways
     */
    async getAllWaysRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SchemasWayPlainResponse>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ways`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SchemasWayPlainResponseFromJSON));
    }

    /**
     * Get ways with pagination
     * Get all ways
     */
    async getAllWays(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SchemasWayPlainResponse>> {
        const response = await this.getAllWaysRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get comments by dayReport UUID
     */
    async getCommentsByDayReportUuidRaw(requestParameters: GetCommentsByDayReportUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SchemasCommentPlainResponse>>> {
        if (requestParameters.dayReportId === null || requestParameters.dayReportId === undefined) {
            throw new runtime.RequiredError('dayReportId','Required parameter requestParameters.dayReportId was null or undefined when calling getCommentsByDayReportUuid.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/comments/{dayReportId}`.replace(`{${"dayReportId"}}`, encodeURIComponent(String(requestParameters.dayReportId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SchemasCommentPlainResponseFromJSON));
    }

    /**
     * Get comments by dayReport UUID
     */
    async getCommentsByDayReportUuid(requestParameters: GetCommentsByDayReportUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SchemasCommentPlainResponse>> {
        const response = await this.getCommentsByDayReportUuidRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all dayReports by Way UUID
     */
    async getDayReportsByWayUuidRaw(requestParameters: GetDayReportsByWayUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SchemasDayReportPlainResponse>>> {
        if (requestParameters.wayId === null || requestParameters.wayId === undefined) {
            throw new runtime.RequiredError('wayId','Required parameter requestParameters.wayId was null or undefined when calling getDayReportsByWayUuid.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/dayReports/{wayId}`.replace(`{${"wayId"}}`, encodeURIComponent(String(requestParameters.wayId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SchemasDayReportPlainResponseFromJSON));
    }

    /**
     * Get all dayReports by Way UUID
     */
    async getDayReportsByWayUuid(requestParameters: GetDayReportsByWayUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SchemasDayReportPlainResponse>> {
        const response = await this.getDayReportsByWayUuidRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get jobDones by dayReport UUID
     */
    async getJobDonesByDayReportUuidRaw(requestParameters: GetJobDonesByDayReportUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SchemasJobDonePlainResponse>>> {
        if (requestParameters.dayReportId === null || requestParameters.dayReportId === undefined) {
            throw new runtime.RequiredError('dayReportId','Required parameter requestParameters.dayReportId was null or undefined when calling getJobDonesByDayReportUuid.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/jobDones/{dayReportId}`.replace(`{${"dayReportId"}}`, encodeURIComponent(String(requestParameters.dayReportId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SchemasJobDonePlainResponseFromJSON));
    }

    /**
     * Get jobDones by dayReport UUID
     */
    async getJobDonesByDayReportUuid(requestParameters: GetJobDonesByDayReportUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SchemasJobDonePlainResponse>> {
        const response = await this.getJobDonesByDayReportUuidRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get jobTags by user UUID
     */
    async getJobTagsByWayUuidRaw(requestParameters: GetJobTagsByWayUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SchemasJobTagResponse>>> {
        if (requestParameters.wayId === null || requestParameters.wayId === undefined) {
            throw new runtime.RequiredError('wayId','Required parameter requestParameters.wayId was null or undefined when calling getJobTagsByWayUuid.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/jobTags/{wayId}`.replace(`{${"wayId"}}`, encodeURIComponent(String(requestParameters.wayId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SchemasJobTagResponseFromJSON));
    }

    /**
     * Get jobTags by user UUID
     */
    async getJobTagsByWayUuid(requestParameters: GetJobTagsByWayUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SchemasJobTagResponse>> {
        const response = await this.getJobTagsByWayUuidRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get metrics by way UUID
     */
    async getMetricsByWayUuidRaw(requestParameters: GetMetricsByWayUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SchemasMetricResponse>>> {
        if (requestParameters.wayId === null || requestParameters.wayId === undefined) {
            throw new runtime.RequiredError('wayId','Required parameter requestParameters.wayId was null or undefined when calling getMetricsByWayUuid.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/metrics/{wayId}`.replace(`{${"wayId"}}`, encodeURIComponent(String(requestParameters.wayId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SchemasMetricResponseFromJSON));
    }

    /**
     * Get metrics by way UUID
     */
    async getMetricsByWayUuid(requestParameters: GetMetricsByWayUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SchemasMetricResponse>> {
        const response = await this.getMetricsByWayUuidRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get plans by dayReport UUID
     */
    async getPlansByDayReportUuidRaw(requestParameters: GetPlansByDayReportUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SchemasPlanPlainResponse>>> {
        if (requestParameters.dayReportId === null || requestParameters.dayReportId === undefined) {
            throw new runtime.RequiredError('dayReportId','Required parameter requestParameters.dayReportId was null or undefined when calling getPlansByDayReportUuid.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/plans/{dayReportId}`.replace(`{${"dayReportId"}}`, encodeURIComponent(String(requestParameters.dayReportId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SchemasPlanPlainResponseFromJSON));
    }

    /**
     * Get plans by dayReport UUID
     */
    async getPlansByDayReportUuid(requestParameters: GetPlansByDayReportUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SchemasPlanPlainResponse>> {
        const response = await this.getPlansByDayReportUuidRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get problems by dayReport UUID
     */
    async getProblemsByDayReportUuidRaw(requestParameters: GetProblemsByDayReportUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SchemasProblemPlainResponse>>> {
        if (requestParameters.dayReportId === null || requestParameters.dayReportId === undefined) {
            throw new runtime.RequiredError('dayReportId','Required parameter requestParameters.dayReportId was null or undefined when calling getProblemsByDayReportUuid.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/problems/{dayReportId}`.replace(`{${"dayReportId"}}`, encodeURIComponent(String(requestParameters.dayReportId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SchemasProblemPlainResponseFromJSON));
    }

    /**
     * Get problems by dayReport UUID
     */
    async getProblemsByDayReportUuid(requestParameters: GetProblemsByDayReportUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SchemasProblemPlainResponse>> {
        const response = await this.getProblemsByDayReportUuidRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get user by UUID
     */
    async getUserByUuidRaw(requestParameters: GetUserByUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasUserPopulatedResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getUserByUuid.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/users/{userId}`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasUserPopulatedResponseFromJSON(jsonValue));
    }

    /**
     * Get user by UUID
     */
    async getUserByUuid(requestParameters: GetUserByUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasUserPopulatedResponse> {
        const response = await this.getUserByUuidRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get userTags by user UUID
     */
    async getUserTagsByUserUuidRaw(requestParameters: GetUserTagsByUserUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SchemasUserTagResponse>>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getUserTagsByUserUuid.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/userTags/{userId}`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SchemasUserTagResponseFromJSON));
    }

    /**
     * Get userTags by user UUID
     */
    async getUserTagsByUserUuid(requestParameters: GetUserTagsByUserUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SchemasUserTagResponse>> {
        const response = await this.getUserTagsByUserUuidRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get way by UUID
     */
    async getWayByUuidRaw(requestParameters: GetWayByUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasWayPopulatedResponse>> {
        if (requestParameters.wayId === null || requestParameters.wayId === undefined) {
            throw new runtime.RequiredError('wayId','Required parameter requestParameters.wayId was null or undefined when calling getWayByUuid.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/ways/{wayId}`.replace(`{${"wayId"}}`, encodeURIComponent(String(requestParameters.wayId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasWayPopulatedResponseFromJSON(jsonValue));
    }

    /**
     * Get way by UUID
     */
    async getWayByUuid(requestParameters: GetWayByUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasWayPopulatedResponse> {
        const response = await this.getWayByUuidRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get wayCollections by user UUID
     */
    async getWayCollectionsByUserUuidRaw(requestParameters: GetWayCollectionsByUserUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SchemasWayCollectionPlainResponse>>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling getWayCollectionsByUserUuid.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/wayCollections/{userId}`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SchemasWayCollectionPlainResponseFromJSON));
    }

    /**
     * Get wayCollections by user UUID
     */
    async getWayCollectionsByUserUuid(requestParameters: GetWayCollectionsByUserUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SchemasWayCollectionPlainResponse>> {
        const response = await this.getWayCollectionsByUserUuidRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get wayTags by way UUID
     */
    async getWayTagsByWayUuidRaw(requestParameters: GetWayTagsByWayUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SchemasWayTagResponse>>> {
        if (requestParameters.wayId === null || requestParameters.wayId === undefined) {
            throw new runtime.RequiredError('wayId','Required parameter requestParameters.wayId was null or undefined when calling getWayTagsByWayUuid.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/wayTags/{wayId}`.replace(`{${"wayId"}}`, encodeURIComponent(String(requestParameters.wayId))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SchemasWayTagResponseFromJSON));
    }

    /**
     * Get wayTags by way UUID
     */
    async getWayTagsByWayUuid(requestParameters: GetWayTagsByWayUuidRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SchemasWayTagResponse>> {
        const response = await this.getWayTagsByWayUuidRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update comment by UUID
     */
    async updateCommentRaw(requestParameters: UpdateCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasCommentPlainResponse>> {
        if (requestParameters.commentId === null || requestParameters.commentId === undefined) {
            throw new runtime.RequiredError('commentId','Required parameter requestParameters.commentId was null or undefined when calling updateComment.');
        }

        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling updateComment.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/comments/{commentId}`.replace(`{${"commentId"}}`, encodeURIComponent(String(requestParameters.commentId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasUpdateCommentPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasCommentPlainResponseFromJSON(jsonValue));
    }

    /**
     * Update comment by UUID
     */
    async updateComment(requestParameters: UpdateCommentRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasCommentPlainResponse> {
        const response = await this.updateCommentRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update dayReport by UUID
     */
    async updateDayReportRaw(requestParameters: UpdateDayReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasDayReportPlainResponse>> {
        if (requestParameters.dayReportId === null || requestParameters.dayReportId === undefined) {
            throw new runtime.RequiredError('dayReportId','Required parameter requestParameters.dayReportId was null or undefined when calling updateDayReport.');
        }

        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling updateDayReport.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/dayReports/{dayReportId}`.replace(`{${"dayReportId"}}`, encodeURIComponent(String(requestParameters.dayReportId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasUpdateDayReportPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasDayReportPlainResponseFromJSON(jsonValue));
    }

    /**
     * Update dayReport by UUID
     */
    async updateDayReport(requestParameters: UpdateDayReportRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasDayReportPlainResponse> {
        const response = await this.updateDayReportRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update jobDone by UUID
     */
    async updateJobDoneRaw(requestParameters: UpdateJobDoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasJobDonePlainResponse>> {
        if (requestParameters.jobDoneId === null || requestParameters.jobDoneId === undefined) {
            throw new runtime.RequiredError('jobDoneId','Required parameter requestParameters.jobDoneId was null or undefined when calling updateJobDone.');
        }

        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling updateJobDone.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/jobDones/{jobDoneId}`.replace(`{${"jobDoneId"}}`, encodeURIComponent(String(requestParameters.jobDoneId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasUpdateJobDoneToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasJobDonePlainResponseFromJSON(jsonValue));
    }

    /**
     * Update jobDone by UUID
     */
    async updateJobDone(requestParameters: UpdateJobDoneRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasJobDonePlainResponse> {
        const response = await this.updateJobDoneRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update jobTag by UUID
     */
    async updateJobTagRaw(requestParameters: UpdateJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasJobTagResponse>> {
        if (requestParameters.jobTagId === null || requestParameters.jobTagId === undefined) {
            throw new runtime.RequiredError('jobTagId','Required parameter requestParameters.jobTagId was null or undefined when calling updateJobTag.');
        }

        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling updateJobTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/jobTags/{jobTagId}`.replace(`{${"jobTagId"}}`, encodeURIComponent(String(requestParameters.jobTagId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasUpdateJobTagPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasJobTagResponseFromJSON(jsonValue));
    }

    /**
     * Update jobTag by UUID
     */
    async updateJobTag(requestParameters: UpdateJobTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasJobTagResponse> {
        const response = await this.updateJobTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update metric by UUID
     */
    async updateMetricRaw(requestParameters: UpdateMetricRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasMetricResponse>> {
        if (requestParameters.metricId === null || requestParameters.metricId === undefined) {
            throw new runtime.RequiredError('metricId','Required parameter requestParameters.metricId was null or undefined when calling updateMetric.');
        }

        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling updateMetric.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/metrics/{metricId}`.replace(`{${"metricId"}}`, encodeURIComponent(String(requestParameters.metricId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasUpdateMetricPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasMetricResponseFromJSON(jsonValue));
    }

    /**
     * Update metric by UUID
     */
    async updateMetric(requestParameters: UpdateMetricRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasMetricResponse> {
        const response = await this.updateMetricRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update plan by UUID
     */
    async updatePlanRaw(requestParameters: UpdatePlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasPlanPlainResponse>> {
        if (requestParameters.planId === null || requestParameters.planId === undefined) {
            throw new runtime.RequiredError('planId','Required parameter requestParameters.planId was null or undefined when calling updatePlan.');
        }

        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling updatePlan.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/plans/{planId}`.replace(`{${"planId"}}`, encodeURIComponent(String(requestParameters.planId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasUpdatePlanPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasPlanPlainResponseFromJSON(jsonValue));
    }

    /**
     * Update plan by UUID
     */
    async updatePlan(requestParameters: UpdatePlanRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasPlanPlainResponse> {
        const response = await this.updatePlanRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update problem by UUID
     */
    async updateProblemRaw(requestParameters: UpdateProblemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasProblemPlainResponse>> {
        if (requestParameters.problemId === null || requestParameters.problemId === undefined) {
            throw new runtime.RequiredError('problemId','Required parameter requestParameters.problemId was null or undefined when calling updateProblem.');
        }

        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling updateProblem.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/problems/{problemId}`.replace(`{${"problemId"}}`, encodeURIComponent(String(requestParameters.problemId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasUpdateProblemPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasProblemPlainResponseFromJSON(jsonValue));
    }

    /**
     * Update problem by UUID
     */
    async updateProblem(requestParameters: UpdateProblemRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasProblemPlainResponse> {
        const response = await this.updateProblemRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update user by UUID
     */
    async updateUserRaw(requestParameters: UpdateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasUserPlainResponse>> {
        if (requestParameters.userId === null || requestParameters.userId === undefined) {
            throw new runtime.RequiredError('userId','Required parameter requestParameters.userId was null or undefined when calling updateUser.');
        }

        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling updateUser.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/users/{userId}`.replace(`{${"userId"}}`, encodeURIComponent(String(requestParameters.userId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasUpdateUserPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasUserPlainResponseFromJSON(jsonValue));
    }

    /**
     * Update user by UUID
     */
    async updateUser(requestParameters: UpdateUserRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasUserPlainResponse> {
        const response = await this.updateUserRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update userTag by UUID
     */
    async updateUserTagRaw(requestParameters: UpdateUserTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasUserTagResponse>> {
        if (requestParameters.userTagId === null || requestParameters.userTagId === undefined) {
            throw new runtime.RequiredError('userTagId','Required parameter requestParameters.userTagId was null or undefined when calling updateUserTag.');
        }

        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling updateUserTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/userTags/{userTagId}`.replace(`{${"userTagId"}}`, encodeURIComponent(String(requestParameters.userTagId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasUpdateUserTagPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasUserTagResponseFromJSON(jsonValue));
    }

    /**
     * Update userTag by UUID
     */
    async updateUserTag(requestParameters: UpdateUserTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasUserTagResponse> {
        const response = await this.updateUserTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update way by UUID
     */
    async updateWayRaw(requestParameters: UpdateWayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasWayPlainResponse>> {
        if (requestParameters.wayId === null || requestParameters.wayId === undefined) {
            throw new runtime.RequiredError('wayId','Required parameter requestParameters.wayId was null or undefined when calling updateWay.');
        }

        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling updateWay.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/ways/{wayId}`.replace(`{${"wayId"}}`, encodeURIComponent(String(requestParameters.wayId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasUpdateWayPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasWayPlainResponseFromJSON(jsonValue));
    }

    /**
     * Update way by UUID
     */
    async updateWay(requestParameters: UpdateWayRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasWayPlainResponse> {
        const response = await this.updateWayRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update wayCollection by UUID
     */
    async updateWayCollectionRaw(requestParameters: UpdateWayCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasWayCollectionPlainResponse>> {
        if (requestParameters.wayCollectionId === null || requestParameters.wayCollectionId === undefined) {
            throw new runtime.RequiredError('wayCollectionId','Required parameter requestParameters.wayCollectionId was null or undefined when calling updateWayCollection.');
        }

        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling updateWayCollection.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/wayCollections/{wayCollectionId}`.replace(`{${"wayCollectionId"}}`, encodeURIComponent(String(requestParameters.wayCollectionId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasUpdateWayCollectionPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasWayCollectionPlainResponseFromJSON(jsonValue));
    }

    /**
     * Update wayCollection by UUID
     */
    async updateWayCollection(requestParameters: UpdateWayCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasWayCollectionPlainResponse> {
        const response = await this.updateWayCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Update wayTag by UUID
     */
    async updateWayTagRaw(requestParameters: UpdateWayTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SchemasWayTagResponse>> {
        if (requestParameters.wayTagId === null || requestParameters.wayTagId === undefined) {
            throw new runtime.RequiredError('wayTagId','Required parameter requestParameters.wayTagId was null or undefined when calling updateWayTag.');
        }

        if (requestParameters.request === null || requestParameters.request === undefined) {
            throw new runtime.RequiredError('request','Required parameter requestParameters.request was null or undefined when calling updateWayTag.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/wayTags/{wayTagId}`.replace(`{${"wayTagId"}}`, encodeURIComponent(String(requestParameters.wayTagId))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: SchemasUpdateWayTagPayloadToJSON(requestParameters.request),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SchemasWayTagResponseFromJSON(jsonValue));
    }

    /**
     * Update wayTag by UUID
     */
    async updateWayTag(requestParameters: UpdateWayTagRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SchemasWayTagResponse> {
        const response = await this.updateWayTagRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
