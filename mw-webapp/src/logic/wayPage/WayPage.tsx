import {useState} from "react";
import {useNavigate} from "react-router-dom";
import {SchemasWayPlainResponse} from "src/apiAutogenerated";
import {Button, ButtonType} from "src/component/button/Button";
import {Confirm} from "src/component/confirm/Confirm";
import {Dropdown} from "src/component/dropdown/Dropdown";
import {DropdownMenuItem, DropdownMenuItemType} from "src/component/dropdown/dropdownMenuItem/DropdownMenuItem";
import {HorizontalContainer} from "src/component/horizontalContainer/HorizontalContainer";
import {HorizontalGridContainer} from "src/component/horizontalGridContainer/HorizontalGridContainer";
import {Icon, IconSize} from "src/component/icon/Icon";
import {Link} from "src/component/link/Link";
import {Loader} from "src/component/loader/Loader";
import {Modal} from "src/component/modal/Modal";
import {displayNotification} from "src/component/notification/displayNotification";
import {ErrorComponent} from "src/component/privateRecourse/PrivateRecourse";
import {HeadingLevel, Title} from "src/component/title/Title";
import {PositionTooltip} from "src/component/tooltip/PositionTooltip";
import {Tooltip} from "src/component/tooltip/Tooltip";
import {VerticalContainer} from "src/component/verticalContainer/VerticalContainer";
import {DayReportDAL} from "src/dataAccessLogic/DayReportDAL";
import {FavoriteUserWayDAL} from "src/dataAccessLogic/FavoriteUserWayDAL";
import {UserDAL} from "src/dataAccessLogic/UserDAL";
import {BaseWayData, WayDAL} from "src/dataAccessLogic/WayDAL";
import {useGlobalContext} from "src/GlobalContext";
import {useLoad} from "src/hooks/useLoad";
import {usePersistanceState} from "src/hooks/usePersistanceState";
import {GoalBlock} from "src/logic/wayPage/goalBlock/GoalBlock";
import {GoalMetricsBlock} from "src/logic/wayPage/goalMetricsBlock/GoalMetricsBlock";
import {JobTags} from "src/logic/wayPage/jobTags/JobTags";
import {MentorRequestsSection} from "src/logic/wayPage/MentorRequestsSection";
import {MentorsSection} from "src/logic/wayPage/MentorsSection";
import {downloadWayPdf} from "src/logic/wayPage/renderWayToPdf/downloadWayPdf";
import {DayReportsTable} from "src/logic/wayPage/reportsTable/dayReportsTable/DayReportsTable";
import {WayStatistic} from "src/logic/wayPage/wayStatistics/WayStatistic";
import {DayReport} from "src/model/businessModel/DayReport";
import {Metric} from "src/model/businessModel/Metric";
import {Way} from "src/model/businessModel/Way";
import {JobTag, WayPreview} from "src/model/businessModelPreview/WayPreview";
import {pages} from "src/router/pages";
import {LanguageService} from "src/service/LangauageService";
import {DateUtils} from "src/utils/DateUtils";
import {WayPageSettings} from "src/utils/LocalStorageWorker";
import {PartialWithUuid} from "src/utils/PartialWithUuid";
import {Symbols} from "src/utils/Symbols";
import styles from "src/logic/wayPage/WayPage.module.scss";

const DEFAULT_WAY_PAGE_SETTINGS: WayPageSettings = {

  /**
   * Default goalMetrics block is opened
   * @default true
   */
  isGoalMetricsVisible: true,

  /**
   * Default statistics block is opened
   * @default true
   */
  isStatisticsVisible: true,
};

/**
 * Update Way params
 */
interface UpdateWayParams {

  /**
   * Way to update
   */
  wayToUpdate: PartialWithUuid<Way>;

  /**
   * Callback to update way
   */
  setWay: (way: PartialWithUuid<Way>) => void;
}

/**
 * Update Way
 */
const updateWay = async (params: UpdateWayParams) => {
  params.setWay(params.wayToUpdate);
  await WayDAL.updateWay(params.wayToUpdate);
};

/**
 * Add way uuid to UserPreview favoriteWays and add user uuid to Way favoriteForUserUuids
 */
export const updateFavoriteUserWay = async (userUuid: string, wayUuid: string) => {
  await FavoriteUserWayDAL.deleteFavoriteUserWay(userUuid, wayUuid);
};

/**
 * PageProps
 */
interface WayPageProps {

  /**
   * Page's uuid
   */
  uuid: string;
}

/**
 * Way page
 */
export const WayPage = (props: WayPageProps) => {
  const navigate = useNavigate();
  const [wayPageSettings,, updateWayPageSettings] = usePersistanceState({
    key: "wayPage",
    defaultValue: DEFAULT_WAY_PAGE_SETTINGS,
  });
  const {user, setUser, language} = useGlobalContext();
  const [way, setWay] = useState<Way>();

  /**
   * Update way state
   */
  const setWayPartial = (previousWay: Partial<Way>) => {
    setWay((prevWay?: Way) => {
      if (!prevWay) {
        throw new Error("Previous way is undefined");
      }

      return {...prevWay, ...previousWay};
    });
  };

  /**
   * Callback that is called to fetch data
   */
  const loadData = () => WayDAL.getWay(props.uuid);

  /**
   * Callback that is called on fetch or validation error
   */
  const onError = (error: Error) => {
    throw error;
  };

  /**
   * Callback that is called on fetch and validation success
   */
  const onSuccess = (data: Way) => {
    setWay(data);
  };

  useLoad(
    {
      loadData,
      onSuccess,
      onError,
      dependency: [props.uuid],
    },
  );

  if (!way) {
    return (
      <Loader />
    );
  }

  const isWayInFavorites = user && !!user.favoriteWays.find((favoriteWay) => favoriteWay.uuid === way.uuid);

  const isOwner = !!user && user.uuid === way.owner.uuid;
  const isMentor = !!user && way.mentors.has(user.uuid);
  const isUserOwnerOrMentor = isOwner || isMentor;

  const isUserHasSentMentorRequest = !!user && way.mentorRequests.some((request) => request.uuid === user.uuid);
  const isEligibleToSendRequest = !!user && !isOwner && !isMentor && !isUserHasSentMentorRequest;

  const favoriteForUsersAmount = way.favoriteForUserUuids.length;

  if (!isUserOwnerOrMentor && way.isPrivate) {
    return (
      <ErrorComponent
        text={LanguageService.way.privateInfo.title[language]}
        description={LanguageService.way.privateInfo.description[language]}
      />
    );
  }

  /**
   * Delete way
   */
  const deleteWay = async () => {
    isOwner && await WayDAL.deleteWay(way.uuid);
    user && navigate(pages.user.getPath({uuid: user.uuid}));
  };

  /**
   * Update day reports
   */
  const setDayReports = (dayReports: DayReport[] | ((prevDayReports: DayReport[]) => DayReport[])): void => {
    // TODO if statement exist because of pretend to set state functions
    if (typeof dayReports === "function") {
      setWay((prevWay) => {
        if (!prevWay) {
          return prevWay;
        }
        const updatedWay = new Way({
          ...prevWay,
          dayReports: dayReports(prevWay.dayReports),
        });

        return updatedWay;
      });
    } else {
      const updatedWay = new Way({...way, dayReports});
      setWay(updatedWay);
    }
  };

  const renderDeleteWayDropdownItem = (
    <Confirm
      trigger={
        <DropdownMenuItem
          value={LanguageService.way.wayActions.deleteTheWay[language]}
          onClick={() => {}}
        />
      }
      content={<p>
        {`Are you sure you want to delete the way "${way.name}"?`}
      </p>}
      onOk={deleteWay}
      okText="Delete"
    />);

  /**
   * Add or remove way from custom collection depends on custom collections.
   */
  const toggleWayInWayCollectionByUuid = async (collectionUuid: string) => {
    if (!user) {
      throw new Error("User is not exist");
    }

    const updatedCustomWayCollections = user?.wayCollections
      .map((userCollection) => {
        const isCollectionToUpdate = userCollection.uuid === collectionUuid;
        if (isCollectionToUpdate) {
          const isWayExistInCollection = userCollection.ways.some(collectionWay => collectionWay.uuid === way.uuid);

          const updatedWayUuids = isWayExistInCollection
            ? userCollection.ways.filter(wayPreview => wayPreview.uuid !== way.uuid)
            //TODO: delete "as"
            : userCollection.ways.concat(way as unknown as WayPreview);

          return {...userCollection, wayUuids: updatedWayUuids};
        } else {
          return userCollection;
        }
      });

    setUser({...user, wayCollections: updatedCustomWayCollections});
    await UserDAL.updateUser({uuid: user.uuid, wayCollections: updatedCustomWayCollections});
    displayNotification({
      text: "Collection updated",
      type: "info",
    });
  };

  const renderAddToCustomCollectionDropdownItems: DropdownMenuItemType[] = (user?.wayCollections ?? [])
    .map((userCollection) => {
      const isWayInUserCollection = userCollection.ways.some((wayPreview: WayPreview) => wayPreview.uuid === props.uuid);

      return {
        id: userCollection.uuid,
        value: (
          <DropdownMenuItem
            key={userCollection.uuid}
            value={`${isWayInUserCollection ? "Remove from" : "Add to"} ${userCollection.name}`}
            onClick={() => toggleWayInWayCollectionByUuid(userCollection.uuid)}
          />
        ),
      };
    });

  /**
   * Copy the way to owner
   */
  const repeatTheWay = async () => {
    if (!user) {
      throw new Error("User is not defined");
    }

    const baseWayData: BaseWayData = {
      name: way.name,
      copiedFromWayUuid: way.uuid,
      estimationTime: way.estimationTime,
      goalDescription: way.goalDescription,
      jobTags: way.jobTags,
      metrics: way.metrics.map(
        (metric) => {
          return {...metric, isDone: false, doneDate: null};
        }),
      wayTags: way.wayTags,
    };
    const newWay: SchemasWayPlainResponse = await WayDAL.createWay(user, baseWayData);

    await navigate(pages.way.getPath({uuid: newWay.uuid}));
    displayNotification({text: `Way ${way.name} copied`, type: "info"});
  };

  /**
   * Update goal
   */
  const updateGoalMetrics = async (metricsToUpdate: Metric[]) => {
    const isWayCompleted = metricsToUpdate.every((metric) => metric.isDone);

    await updateWay({
      wayToUpdate: {
        uuid: way.uuid,
        metrics: metricsToUpdate,
        status: isWayCompleted ? "Completed" : "",
      },
      setWay: setWayPartial,
    });
  };

  const isEmptyWay = way.dayReports.length === 0;
  const currentDate = DateUtils.getShortISODateValue(new Date());
  const lastReportDate = !isEmptyWay && DateUtils.getShortISODateValue(way.dayReports[0].createdAt);
  const isReportForTodayAlreadyCreated = lastReportDate === currentDate;
  const isReportForTodayIsNotCreated = isEmptyWay || !isReportForTodayAlreadyCreated;
  const isPossibleCreateDayReport = isUserOwnerOrMentor && isReportForTodayIsNotCreated;

  /**
   * Create day report
   */
  const createDayReport = async (wayUuid: string): Promise<DayReport> => {
    const newDayReport = await DayReportDAL.createDayReport(wayUuid);
    setDayReports((prevDayReportsList) => [newDayReport, ...prevDayReportsList]);

    return newDayReport;
  };

  return (
    <VerticalContainer className={styles.container}>
      <HorizontalGridContainer className={styles.wayDashboard}>
        <VerticalContainer className={styles.wayInfo}>
          <HorizontalContainer className={styles.wayTitleBlock}>
            <Title
              level={HeadingLevel.h2}
              text={way.name}
              onChangeFinish={(name) => updateWay({
                wayToUpdate: {
                  uuid: way.uuid,
                  name,
                },
                setWay: setWayPartial,
              })}
              isEditable={isUserOwnerOrMentor}
              className={styles.wayName}
            />

            <HorizontalContainer className={styles.wayActionButtons}>
              <Tooltip
                content={isWayInFavorites
                  ? LanguageService.way.wayInfo.deleteFromFavoritesTooltip[language]
                  : LanguageService.way.wayInfo.addToFavoritesTooltip[language]}
                position={PositionTooltip.LEFT}
              >
                <Button
                  className={styles.wayActionsIcon}
                  value={`${isWayInFavorites
                    ? Symbols.STAR
                    : Symbols.OUTLINED_STAR
                  }${Symbols.NO_BREAK_SPACE}${favoriteForUsersAmount}`}
                  onClick={() => {
                    if (!user) {
                      return;
                    }

                    if (isWayInFavorites) {
                      async() => await FavoriteUserWayDAL.deleteFavoriteUserWay(user.uuid, way.uuid);
                    } else {
                      async() => await FavoriteUserWayDAL.createFavoriteUserWay(user.uuid, way.uuid);
                    }

                    displayNotification({
                      text: isWayInFavorites
                        ? LanguageService.way.notifications.wayRemovedFromFavorites[language]
                        : LanguageService.way.notifications.wayAddedToFavorites[language],
                      type: "info",
                    });
                  }}
                  buttonType={ButtonType.TERTIARY}
                />
              </Tooltip>
              <Dropdown
                className={styles.wayActionMenu}
                trigger={(
                  <Tooltip
                    content={LanguageService.way.wayInfo.wayActionsTooltip[language]}
                    position={PositionTooltip.LEFT}
                  >
                    <Button
                      className={styles.wayActionsIcon}
                      buttonType={ButtonType.TERTIARY}
                      onClick={() => updateWayPageSettings({isGoalMetricsVisible: !wayPageSettings.isGoalMetricsVisible})}
                      value={<>
                        <Icon
                          size={IconSize.MEDIUM}
                          name={"MoreVertical"}
                        />
                      </>}
                    />
                  </Tooltip>
                )}
                dropdownMenuItems={[
                  {
                    id: "Make the way private/public",
                    isVisible: isOwner,
                    value: way.isPrivate
                      ? LanguageService.way.peopleBlock.makePublicButton[language]
                      : LanguageService.way.peopleBlock.makePrivateButton[language],

                    /**
                     * Toggle way privacy
                     */
                    onClick: () => updateWay({
                      wayToUpdate: {
                        uuid: way.uuid,
                        isPrivate: !way.isPrivate,
                      },
                      setWay: setWayPartial,
                    }),
                  },
                  {
                    id: "Repeat the way",
                    value: LanguageService.way.wayActions.repeatTheWay[language],

                    /**
                     * Copy url to clipboard
                     */
                    onClick: repeatTheWay,
                    isVisible: !!user,
                  },
                  {
                    id: "Copy url to clipboard",
                    value: LanguageService.way.wayActions.copyUrlToClipboard[language],

                    /**
                     * Copy url to clipboard
                     */
                    onClick: async () => {
                      await navigator.clipboard.writeText(location.href);
                      displayNotification({
                        text: LanguageService.way.notifications.urlCopied[language],
                        type: "info",
                      });
                    },
                  },
                  {
                    id: "Download as pdf",
                    value: LanguageService.way.wayActions.downloadAsPdf[language],

                    /**
                     * Download way as pdf
                     */
                    onClick: () => downloadWayPdf(way),
                  },
                  ...renderAddToCustomCollectionDropdownItems,
                  {
                    id: "Go to original way",
                    value: LanguageService.way.wayActions.goToOriginal[language],
                    isVisible: !!way.copiedFromWayUuid,

                    /**
                     * Go to original way (from which current way was copied)
                     */
                    onClick: () => {
                      if (!way.copiedFromWayUuid) {
                        throw new Error("This way is original, not copied");
                      }
                      navigate(pages.way.getPath({uuid: way.copiedFromWayUuid}));
                    },
                  },
                  {
                    id: "Delete the way",
                    value: renderDeleteWayDropdownItem,
                    isVisible: isOwner,
                  },
                ]}
              />
            </HorizontalContainer>
          </HorizontalContainer>

          <HorizontalContainer className={styles.wayTagsContainer}>
            {LanguageService.way.wayInfo.noTags[language]}
            <Tooltip content="Edit way tags. Coming soon :)">
              <Button
                value={
                  <Icon
                    size={IconSize.SMALL}
                    name="PlusIcon"
                  />
                }
                onClick={() => {}}
                className={styles.flatButton}
              />
            </Tooltip>
          </HorizontalContainer>

          <GoalBlock
            goalDescription={way.goalDescription}
            wayUuid={way.uuid}
            updateWay={(updated) => updateWay({
              wayToUpdate: {...updated},
              setWay: setWayPartial,
            })}
            isEditable={isUserOwnerOrMentor}
          />
        </VerticalContainer>

        <VerticalContainer className={styles.metricsBlock}>
          <HorizontalContainer className={styles.horizontalContainer}>
            <Title
              level={HeadingLevel.h3}
              text={LanguageService.way.metricsBlock.metrics[language]}
            />
            <Tooltip content={wayPageSettings.isGoalMetricsVisible
              ? LanguageService.way.metricsBlock.clickToHideMetrics[language]
              : LanguageService.way.metricsBlock.clickToShowMetrics[language]
            }
            >
              <button
                className={styles.iconContainer}
                onClick={() => updateWayPageSettings({isGoalMetricsVisible: !wayPageSettings.isGoalMetricsVisible})}
              >
                <Icon
                  size={IconSize.MEDIUM}
                  name={wayPageSettings.isGoalMetricsVisible ? "EyeOpenedIcon" : "EyeSlashedIcon"}
                />
              </button>
            </Tooltip>
          </HorizontalContainer>
          <GoalMetricsBlock
            isVisible={wayPageSettings.isGoalMetricsVisible}
            goalMetrics={way.metrics}
            updateGoalMetrics={updateGoalMetrics}
            isEditable={isUserOwnerOrMentor}
          />
        </VerticalContainer>
        <VerticalContainer className={styles.peopleBlock}>
          <HorizontalContainer className={styles.privacyBlock}>
            <Tooltip content={way.isPrivate
              ? LanguageService.way.peopleBlock.wayPrivacy.privateTooltip[language]
              : LanguageService.way.peopleBlock.wayPrivacy.publicTooltip[language]
            }
            >
              <Title
                level={HeadingLevel.h3}
                text={LanguageService.way.peopleBlock.wayPrivacy.title[language]}
              />
              {Symbols.NO_BREAK_SPACE}
              {way.isPrivate
                ? LanguageService.way.peopleBlock.wayPrivacy.private[language]
                : LanguageService.way.peopleBlock.wayPrivacy.public[language]
              }
            </Tooltip>
          </HorizontalContainer>

          <HorizontalContainer>
            <Title
              level={HeadingLevel.h3}
              text={LanguageService.way.peopleBlock.waysOwner[language]}
            />
            <Link
              path={pages.user.getPath({uuid: way.owner.uuid})}
              className={styles.mentors}
            >
              {way.owner.name}
            </Link>
          </HorizontalContainer>
          {!!way.mentors.size &&
            <MentorsSection
              way={way}
              setWay={setWayPartial}
              isOwner={isOwner}
            />}
          {isOwner && !!way.mentorRequests.length && (
            <MentorRequestsSection
              way={way}
              setWay={setWay}
            />
          )}
          {isEligibleToSendRequest && (
            <Button
              className={styles.applyAsMentorButton}
              value={LanguageService.way.peopleBlock.applyAsMentor[language]}
              onClick={() => updateWay({
                wayToUpdate: {
                  uuid: way.uuid,
                  // MentorRequests: way.mentorRequests.concat(user),
                },
                setWay: setWayPartial,
              })}
            />
          )}
        </VerticalContainer>

      </HorizontalGridContainer>

      <HorizontalContainer>
        <VerticalContainer className={styles.statistics}>
          <HorizontalContainer className={styles.horizontalContainer}>
            <Title
              level={HeadingLevel.h3}
              text={LanguageService.way.statisticsBlock.statistics[language]}
            />
            <Tooltip content={wayPageSettings.isStatisticsVisible
              ? LanguageService.way.statisticsBlock.clickToHideStatistics[language]
              : LanguageService.way.statisticsBlock.clickToShowStatistics[language]
            }
            >
              <button
                className={styles.iconContainer}
                onClick={() => updateWayPageSettings({isStatisticsVisible: !wayPageSettings.isStatisticsVisible})}
              >
                <Icon
                  size={IconSize.MEDIUM}
                  name={wayPageSettings.isStatisticsVisible ? "EyeOpenedIcon" : "EyeSlashedIcon"}
                />
              </button>
            </Tooltip>
          </HorizontalContainer>
          <WayStatistic
            dayReports={way.dayReports}
            wayCreatedAt={way.createdAt}
            isVisible={wayPageSettings.isStatisticsVisible}
          />
        </VerticalContainer>

      </HorizontalContainer>

      {isUserOwnerOrMentor &&
        <HorizontalContainer className={styles.dayReportActions}>
          <HorizontalContainer>
            {isPossibleCreateDayReport &&
              <Button
                value={LanguageService.way.filterBlock.createNewDayReport[language]}
                onClick={() => {
                  createDayReport(way.uuid);
                }}
                buttonType={ButtonType.PRIMARY}
              />
            }
            <Modal
              trigger={
                <Button
                  value={LanguageService.way.filterBlock.adjustJobTags[language]}
                  buttonType={ButtonType.SECONDARY}
                  onClick={() => { }}
                />
              }
              content={
                <div className={styles.jobDoneTagsWrapper}>
                  <Title
                    level={HeadingLevel.h3}
                    text={LanguageService.way.filterBlock.jobDoneTagsModalTitle[language]}
                  />
                  <JobTags
                    jobTags={way.jobTags}
                    isEditable={isUserOwnerOrMentor}
                    updateTags={(tagsToUpdate: JobTag[]) => updateWay({
                      wayToUpdate: {
                        uuid: way.uuid,
                        jobTags: tagsToUpdate,
                      },
                      setWay: setWayPartial,
                    })}
                  />
                </div>
              }
            />
          </HorizontalContainer>
        </HorizontalContainer>
      }

      <DayReportsTable
        way={way}
        setDayReports={setDayReports}
        createDayReport={createDayReport}
      />

    </VerticalContainer>
  );
};
