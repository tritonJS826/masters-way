package controllers

import (
	openapiGeneral "mw-general-bff/apiAutogenerated/general"
	"mw-general-bff/internal/auth"
	"mw-general-bff/internal/facades"
	"mw-general-bff/internal/schemas"
	"mw-general-bff/internal/services"
	"mw-general-bff/pkg/utils"
	"net/http"
	"strconv"

	"github.com/gin-gonic/gin"
	"github.com/samber/lo"
)

// Without next lines swagger does not see openapi models
var _ = &openapiGeneral.MwServerInternalSchemasWayPlainResponse{}
var _ = &schemas.CreateWayPayload{}

type WayController struct {
	wayFacade *facades.WayFacade
}

func NewWayController(wayFacade *facades.WayFacade) *WayController {
	return &WayController{wayFacade}
}

// Create way from training handler
// @Summary Create a new way based on training
// @Description Create a new way based on training
// @Tags way
// @ID create-way-from-training
// @Accept  json
// @Produce  json
// @Param request body schemas.CreateWayFromTrainingPayload true "query params"
// @Success 200 {object} schemas.CreateWayFromTrainingResponse
// @Router /ways/createFromTraining [post]
func (wc *WayController) CreateWayFromTraining(ctx *gin.Context) {
	var payload *schemas.CreateWayFromTrainingPayload

	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	userIDRaw, _ := ctx.Get(auth.ContextKeyUserID)
	userID := userIDRaw.(string)

	args := &facades.CreateWayFromTrainingParams{
		TrainingId: payload.TrainingId,
		OwnerId:    userID,
	}
	wayRaw, err := wc.wayFacade.CreateWayFromTraining(ctx, args)
	utils.HandleErrorGin(ctx, err)

	way := schemas.CreateWayFromTrainingResponse{
		WayUuid: wayRaw.Uuid,
	}

	ctx.JSON(http.StatusOK, way)
}

// Create way handler
// @Summary Create a new way
// @Description
// @Tags way
// @ID create-way
// @Accept  json
// @Produce  json
// @Param request body schemas.CreateWayPayload true "query params"
// @Success 200 {object} schemas.WayPlainResponse
// @Router /ways [post]
func (wc *WayController) CreateWay(ctx *gin.Context) {
	var payload *schemas.CreateWayPayload

	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	wayRaw, err := wc.wayFacade.CreateWay(ctx, payload)
	utils.HandleErrorGin(ctx, err)

	way := ConvertWay(*wayRaw, 0)

	ctx.JSON(http.StatusOK, way)
}

// Update way handler
// @Summary Update way by UUID
// @Description
// @Tags way
// @ID update-way
// @Accept  json
// @Produce  json
// @Param request body schemas.UpdateWayPayload true "query params"
// @Param wayId path string true "way ID"
// @Success 200 {object} schemas.WayPlainResponse
// @Router /ways/{wayId} [patch]
func (wc *WayController) UpdateWay(ctx *gin.Context) {
	var payload *schemas.UpdateWayPayload
	wayId := ctx.Param("wayId")

	if err := ctx.ShouldBindJSON(&payload); err != nil {
		ctx.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	args := &services.UpdateWayParams{
		WayID:           wayId,
		Name:            payload.Name,
		GoalDescription: payload.GoalDescription,
		EstimationTime:  payload.EstimationTime,
		IsPrivate:       payload.IsPrivate,
		IsCompleted:     payload.IsCompleted,
	}

	wayRaw, err := wc.wayFacade.UpdateWay(ctx, args)
	utils.HandleErrorGin(ctx, err)

	way := ConvertWay(*wayRaw, 0)

	ctx.JSON(http.StatusOK, way)
}

// Get a single handler
// @Summary Get way by UUID
// @Description
// @Tags way
// @ID get-way-by-uuid
// @Accept  json
// @Produce  json
// @Param wayId path string true "way ID"
// @Success 200 {object} schemas.WayPopulatedResponse
// @Router /ways/{wayId} [get]
func (wc *WayController) GetWayById(ctx *gin.Context) {
	wayUUID := ctx.Param("wayId")

	response, err := wc.wayFacade.GetWayById(ctx, wayUUID)
	utils.HandleErrorGin(ctx, err)

	ctx.JSON(http.StatusOK, response)
}

// Retrieve all records handlers
// @Summary Get all ways
// @Description Get ways with pagination
// @Tags way
// @ID get-all-ways
// @Accept  json
// @Produce  json
// @Param page query integer false "Page number for pagination"
// @Param limit query integer false "Number of items per page"
// @Param minDayReportsAmount query integer false "Min day reports amount"
// @Param wayName query string false "Way name"
// @Param status query string false "Ways type: all | completed | inProgress | abandoned"
// @Success 200 {object} schemas.GetAllWaysResponse
// @Router /ways [get]
func (wc *WayController) GetAllWays(ctx *gin.Context) {
	page := ctx.DefaultQuery("page", "1")
	limit := ctx.DefaultQuery("limit", "10")
	minDayReportsAmount := ctx.DefaultQuery("minDayReportsAmount", "0")
	wayName := ctx.DefaultQuery("wayName", "")
	status := ctx.DefaultQuery("status", "all")

	reqPage, _ := strconv.Atoi(page)
	reqLimit, _ := strconv.Atoi(limit)
	reqMinDayReportsAmount, _ := strconv.Atoi(minDayReportsAmount)

	allWaysRaw, err := wc.wayFacade.GetAllWays(ctx, &services.GetAllWaysParams{
		Status:                 status,
		WayName:                wayName,
		Page:                   reqPage,
		ReqMinDayReportsAmount: reqMinDayReportsAmount,
		Limit:                  reqLimit,
	})
	utils.HandleErrorGin(ctx, err)

	allWays := schemas.GetAllWaysResponse{
		Size: allWaysRaw.Size,
		Ways: lo.Map(allWaysRaw.Ways, ConvertWay),
	}

	ctx.JSON(http.StatusOK, allWays)
}

// Deleting way handlers
// @Summary Delete way by UUID
// @Description
// @Tags way
// @ID delete-way
// @Accept  json
// @Produce  json
// @Param wayId path string true "way ID"
// @Success 204
// @Router /ways/{wayId} [delete]
func (wc *WayController) DeleteWayById(ctx *gin.Context) {
	wayID := ctx.Param("wayId")

	err := wc.wayFacade.DeleteWayById(ctx, wayID)
	utils.HandleErrorGin(ctx, err)

	ctx.Status(http.StatusNoContent)
}

// Get way statistics
// @Summary Get way statistics by UUID
// @Description
// @Tags way
// @ID get-way-statistics-by-uuid
// @Accept  json
// @Produce  json
// @Param wayId path string true "way ID"
// @Success 200 {object} schemas.WayStatisticsTriplePeriod
// @Router /ways/{wayId}/statistics [get]
func (wc *WayController) GetWayStatisticsById(ctx *gin.Context) {
	wayUUID := ctx.Param("wayId")

	responseRaw, err := wc.wayFacade.GetWayStatisticsById(ctx, wayUUID)
	utils.HandleErrorGin(ctx, err)

	response := schemas.WayStatisticsTriplePeriod{
		TotalTime: schemas.WayStatistics{
			TimeSpentByDayChart: lo.Map(responseRaw.TotalTime.TimeSpentByDayChart, func(point openapiGeneral.MwServerInternalSchemasTimeSpentByDayPoint, _ int) schemas.TimeSpentByDayPoint {
				return schemas.TimeSpentByDayPoint{
					Value: int(point.Value),
					Date:  point.Date,
				}
			}),
			OverallInformation: schemas.OverallInformation{
				TotalTime:                 int(responseRaw.TotalTime.OverallInformation.TotalTime),
				TotalReports:              int(responseRaw.TotalTime.OverallInformation.TotalReports),
				FinishedJobs:              int(responseRaw.TotalTime.OverallInformation.FinishedJobs),
				AverageTimePerCalendarDay: int(responseRaw.TotalTime.OverallInformation.AverageTimePerCalendarDay),
				AverageTimePerWorkingDay:  int(responseRaw.TotalTime.OverallInformation.AverageTimePerWorkingDay),
				AverageJobTime:            int(responseRaw.TotalTime.OverallInformation.AverageJobTime),
			},
			LabelStatistics: schemas.LabelStatistics{
				Labels: lo.Map(responseRaw.TotalTime.LabelStatistics.Labels, func(labelInfo openapiGeneral.MwServerInternalSchemasLabelInfo, _ int) schemas.LabelInfo {
					return schemas.LabelInfo{
						Label: schemas.Label{
							ID:          labelInfo.Label.Uuid,
							Name:        labelInfo.Label.Name,
							Color:       labelInfo.Label.Color,
							Description: labelInfo.Label.Description,
						},
						JobsAmount:           int(labelInfo.JobsAmount),
						JobsAmountPercentage: int(labelInfo.JobsAmountPercentage),
						Time:                 int(labelInfo.Time),
						TimePercentage:       int(labelInfo.TimePercentage),
					}
				}),
			},
		},
		LastMonth: schemas.WayStatistics{
			TimeSpentByDayChart: lo.Map(responseRaw.LastMonth.TimeSpentByDayChart, func(point openapiGeneral.MwServerInternalSchemasTimeSpentByDayPoint, _ int) schemas.TimeSpentByDayPoint {
				return schemas.TimeSpentByDayPoint{
					Value: int(point.Value),
					Date:  point.Date,
				}
			}),
			OverallInformation: schemas.OverallInformation{
				TotalTime:                 int(responseRaw.LastMonth.OverallInformation.TotalTime),
				TotalReports:              int(responseRaw.LastMonth.OverallInformation.TotalReports),
				FinishedJobs:              int(responseRaw.LastMonth.OverallInformation.FinishedJobs),
				AverageTimePerCalendarDay: int(responseRaw.LastMonth.OverallInformation.AverageTimePerCalendarDay),
				AverageTimePerWorkingDay:  int(responseRaw.LastMonth.OverallInformation.AverageTimePerWorkingDay),
				AverageJobTime:            int(responseRaw.LastMonth.OverallInformation.AverageJobTime),
			},
			LabelStatistics: schemas.LabelStatistics{
				Labels: lo.Map(responseRaw.LastMonth.LabelStatistics.Labels, func(labelInfo openapiGeneral.MwServerInternalSchemasLabelInfo, _ int) schemas.LabelInfo {
					return schemas.LabelInfo{
						Label: schemas.Label{
							ID:          labelInfo.Label.Uuid,
							Name:        labelInfo.Label.Name,
							Color:       labelInfo.Label.Color,
							Description: labelInfo.Label.Description,
						},
						JobsAmount:           int(labelInfo.JobsAmount),
						JobsAmountPercentage: int(labelInfo.JobsAmountPercentage),
						Time:                 int(labelInfo.Time),
						TimePercentage:       int(labelInfo.TimePercentage),
					}
				}),
			},
		},
		LastWeek: schemas.WayStatistics{
			TimeSpentByDayChart: lo.Map(responseRaw.LastWeek.TimeSpentByDayChart, func(point openapiGeneral.MwServerInternalSchemasTimeSpentByDayPoint, _ int) schemas.TimeSpentByDayPoint {
				return schemas.TimeSpentByDayPoint{
					Value: int(point.Value),
					Date:  point.Date,
				}
			}),
			OverallInformation: schemas.OverallInformation{
				TotalTime:                 int(responseRaw.LastWeek.OverallInformation.TotalTime),
				TotalReports:              int(responseRaw.LastWeek.OverallInformation.TotalReports),
				FinishedJobs:              int(responseRaw.LastWeek.OverallInformation.FinishedJobs),
				AverageTimePerCalendarDay: int(responseRaw.LastWeek.OverallInformation.AverageTimePerCalendarDay),
				AverageTimePerWorkingDay:  int(responseRaw.LastWeek.OverallInformation.AverageTimePerWorkingDay),
				AverageJobTime:            int(responseRaw.LastWeek.OverallInformation.AverageJobTime),
			},
			LabelStatistics: schemas.LabelStatistics{
				Labels: lo.Map(responseRaw.LastWeek.LabelStatistics.Labels, func(labelInfo openapiGeneral.MwServerInternalSchemasLabelInfo, _ int) schemas.LabelInfo {
					return schemas.LabelInfo{
						Label: schemas.Label{
							ID:          labelInfo.Label.Uuid,
							Name:        labelInfo.Label.Name,
							Color:       labelInfo.Label.Color,
							Description: labelInfo.Label.Description,
						},
						JobsAmount:           int(labelInfo.JobsAmount),
						JobsAmountPercentage: int(labelInfo.JobsAmountPercentage),
						Time:                 int(labelInfo.Time),
						TimePercentage:       int(labelInfo.TimePercentage),
					}
				}),
			},
		},
	}

	ctx.JSON(http.StatusOK, response)
}
