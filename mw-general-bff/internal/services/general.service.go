package services

import (
	"context"
	"fmt"
	"mw-general-bff/internal/schemas"
	"mw-general-bff/pkg/utils"

	//db "mwserver/internal/db/sqlc"
	"time"

	openapiGeneral "mw-general-bff/apiAutogenerated/general"

	"github.com/google/uuid"
)

type GeneralService struct {
	generalAPI *openapiGeneral.APIClient
}

func NewGeneralService(generalAPI *openapiGeneral.APIClient) *GeneralService {
	return &GeneralService{generalAPI}
}

func (gs *GeneralService) CreateComment(ctx context.Context, payload *schemas.CreateCommentPayload) (*schemas.CommentPopulatedResponse, error) {
	commentRaw, response, err := gs.generalAPI.CommentAPI.CreateComment(ctx).Request(openapiGeneral.SchemasCreateCommentPayload{
		DayReportUuid: payload.DayReportUuid,
		Description:   payload.Description,
		OwnerUuid:     payload.OwnerUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	comment := &schemas.CommentPopulatedResponse{
		Uuid:          commentRaw.Uuid,
		Description:   commentRaw.Description,
		OwnerUuid:     commentRaw.OwnerUuid,
		OwnerName:     commentRaw.OwnerName,
		CreatedAt:     commentRaw.CreatedAt,
		UpdatedAt:     commentRaw.UpdatedAt,
		DayReportUuid: commentRaw.DayReportUuid,
		WayUUID:       commentRaw.WayUuid,
		WayName:       commentRaw.WayName,
	}

	return comment, nil
}

type UpdateCommentParams struct {
	CommentID   string
	Description *string
}

func (gs *GeneralService) UpdateComment(ctx context.Context, params *UpdateCommentParams) (*schemas.CommentPopulatedResponse, error) {
	updateReq := openapiGeneral.SchemasUpdateCommentPayload{
		Description: params.Description,
	}

	updatedCommentRaw, response, err := gs.generalAPI.CommentAPI.UpdateComment(ctx, params.CommentID).Request(updateReq).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	updatedComment := &schemas.CommentPopulatedResponse{
		Uuid:          updatedCommentRaw.Uuid,
		Description:   updatedCommentRaw.Description,
		OwnerUuid:     updatedCommentRaw.OwnerUuid,
		OwnerName:     updatedCommentRaw.OwnerName,
		CreatedAt:     updatedCommentRaw.CreatedAt,
		UpdatedAt:     updatedCommentRaw.UpdatedAt,
		DayReportUuid: updatedCommentRaw.DayReportUuid,
		WayUUID:       updatedCommentRaw.WayUuid,
		WayName:       updatedCommentRaw.WayName,
	}

	return updatedComment, nil
}

func (gs *GeneralService) DeleteCommentById(ctx context.Context, commentID string) error {
	response, err := gs.generalAPI.CommentAPI.DeleteComment(ctx, commentID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

type AddWayToCompositeWayParams struct {
	ChildWayID  string
	ParentWayID string
}

func (gs *GeneralService) AddWayToCompositeWay(ctx context.Context, params *AddWayToCompositeWayParams) (*schemas.CompositeWayRelation, error) {
	relationRaw, response, err := gs.generalAPI.CompositeWayAPI.CreateCompositeWay(ctx).Request(openapiGeneral.SchemasAddWayToCompositeWayPayload{
		ChildWayUuid:  params.ChildWayID,
		ParentWayUuid: params.ParentWayID,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	relation := &schemas.CompositeWayRelation{
		ChildWayUuid:  relationRaw.ChildWayUuid,
		ParentWayUuid: relationRaw.ParentWayUuid,
	}

	return relation, nil
}

func (gs *GeneralService) DeleteCompositeWayRelation(ctx context.Context, parentWayID, childWayID string) error {
	response, err := gs.generalAPI.CompositeWayAPI.DeleteCompositeWayRelation(ctx, parentWayID, childWayID).Execute()
	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

//type DayReportService struct {
//	dayReportRepository IDayReportRepository
//}
//
//func NewDayReportService(dayReportRepository IDayReportRepository) *DayReportService {
//	return &DayReportService{dayReportRepository}
//}

type GetDayReportsByWayIdParams struct {
	ParentWayID    uuid.UUID
	ChildrenWayIDs []uuid.UUID
	ReqLimit       int
	Offset         int
}

func (gs *GeneralService) GetDayReportsByWayID(ctx context.Context, params *GetDayReportsByWayIdParams) (*schemas.ListDayReportsResponse, error) {
}

type GetLastDayReportDateResponse struct {
	TotalStartDate time.Time
	EndDate        time.Time
}

func (ds *GeneralService) GetLastDayReportDate(ctx context.Context, wayUUIDs []uuid.UUID) (*GetLastDayReportDateResponse, error) {
}

func (gs *GeneralService) CreateDayReport(ctx context.Context, wayID string) (*schemas.CompositeDayReportPopulatedResponse, error) {
	dayReportRaw, response, err := gs.generalAPI.DayReportAPI.CreateDayReport(ctx).Request(openapiGeneral.SchemasCreateDayReportPayload{
		WayId: wayID,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	dayReport := &schemas.CompositeDayReportPopulatedResponse{
		UUID:                    dayReportRaw.Uuid,
		CreatedAt:               dayReportRaw.CreatedAt,
		UpdatedAt:               dayReportRaw.UpdatedAt,
		CompositionParticipants: dayReportRaw.CompositionParticipants,
		JobsDone:                dayReportRaw.JobsDone,
		Plans:                   dayReportRaw.Plans,
		Problems:                dayReportRaw.Problems,
		Comments:                dayReportRaw.Comments,
	}

	return dayReport, nil
}

func (gs *GeneralService) CreateFavoriteUser(ctx context.Context, payload *schemas.CreateFavoriteUserPayload) error {

	response, err := gs.generalAPI.FavoriteUserAPI.CreateFavoriteUser(ctx).
		Request(openapiGeneral.SchemasCreateFavoriteUserPayload{
			DonorUserUuid:    payload.DonorUserUuid,
			AcceptorUserUuid: payload.AcceptorUserUuid,
		}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) DeleteFavoriteUserById(ctx context.Context, donorUserUuid, acceptorUserUuid string) error {
	response, err := gs.generalAPI.FavoriteUserAPI.DeleteFavoriteUser(ctx, donorUserUuid, acceptorUserUuid).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) CreateFavoriteUserWay(ctx context.Context, userUUID, wayUUID uuid.UUID) error {
	response, err := gs.generalAPI.FavoriteUserWayAPI.CreateFavoriteUserWay(ctx).Request(openapiGeneral.SchemasCreateFavoriteUserWayPayload{
		UserUuid: userUUID,
		WayUuid:  wayUUID,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (fuws *GeneralService) DeleteFavoriteUserWayById(ctx context.Context, userID, wayID string) error {
	response, err := fuws.generalAPI.FavoriteUserWayAPI.DeleteFavoriteUserWay(ctx, userID, wayID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

//func NewFromUserMentoringRequestService(fromUserMentoringRequestRepository IFromUserMentoringRequestRepository) *FromUserMentoringRequestService {
//	return &FromUserMentoringRequestService{fromUserMentoringRequestRepository}
//}

func (gs *GeneralService) CreateFromUserMentoringRequest(ctx context.Context, userID, wayID string) (*schemas.FromUserMentoringRequestResponse, error) {
	fromUserMentoringRaw, response, err := gs.generalAPI.FromUserMentoringRequestAPI.CreateFromUserMentoringRequest(ctx).Request(openapiGeneral.SchemasCreateFromUserMentoringRequestPayload{
		UserUuid: userID,
		WayUuid:  wayID,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	result := &schemas.FromUserMentoringRequestResponse{
		UserID: fromUserMentoringRaw.UserId,
		WayID:  fromUserMentoringRaw.WayId,
	}

	return result, nil
}

func (gs *GeneralService) DeleteFromUserMentoringRequestById(ctx context.Context, userID, wayID string) error {
	response, err := gs.generalAPI.FromUserMentoringRequestAPI.DeleteFromUserMentoringRequest(ctx, userID, wayID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) CreateMetricsPrompt(ctx context.Context, payload *schemas.GenerateMetricsPayload) (*schemas.GenerateMetricsResponse, error) {
	metricsRow, response, err := gs.generalAPI.GeminiAPI.GenerateMetrics(ctx).Request(openapiGeneral.SchemasGenerateMetricsPayload{
		GoalDescription: payload.GoalDescription,
		Metrics:         payload.Metrics,
		WayName:         payload.WayName,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	metrics := &schemas.GenerateMetricsResponse{
		Metrics: &metricsRow.Metrics,
	}

	return metrics, nil
}

func (gs *GeneralService) GetMetricsByGoal(ctx context.Context, payload *schemas.GenerateMetricsPayload) ([]string, error) {

}

func (gs *GeneralService) AIChat(ctx context.Context, payload *schemas.AIChatPayload) (*schemas.AIChatResponse, error) {
	aiChatRow, response, err := gs.generalAPI.GeminiAPI.AiChat(ctx).Request(openapiGeneral.SchemasAIChatPayload{
		Message: payload.Message,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}
	aiChat := &schemas.AIChatResponse{
		Message: aiChatRow.Message,
	}

	return aiChat, nil
}

func (gs *GeneralService) GeneratePlansByMetric(ctx context.Context, payload *schemas.AIGeneratePlansByMetricPayload) (*schemas.AIGeneratePlansByMetricResponse, error) {
	plansRaw, response, err := gs.generalAPI.GeminiAPI.AiPlansByMetrics(ctx).Request(openapiGeneral.SchemasAIGeneratePlansByMetricPayload{
		Goal:   payload.Goal,
		Metric: payload.Metric,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	plans := &schemas.AIGeneratePlansByMetricResponse{
		Plans: plansRaw.Plans,
	}

	return plans, nil

}

func (gs *GeneralService) CommentIssue(ctx context.Context, payload *schemas.AICommentIssuePayload) (*schemas.AICommentIssueResponse, error) {
	commentRaw, response, err := gs.generalAPI.GeminiAPI.AiCommentIssue(ctx).Request(openapiGeneral.SchemasAICommentIssuePayload{
		Goal:    payload.Goal,
		Message: payload.Message,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	comment := &schemas.AICommentIssueResponse{
		Comment: commentRaw.Goal,
	}

	return comment, nil

}

func (gs *GeneralService) DecomposeIssue(ctx context.Context, payload *schemas.AIDecomposeIssuePayload) (*schemas.AIDecomposeIssueResponse, error) {
	plansRaw, response, err := gs.generalAPI.GeminiAPI.AiDecomposeIssue(ctx).Request(openapiGeneral.SchemasAIDecomposeIssuePayload{
		Goal:    payload.Goal,
		Message: payload.Message,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	decompose := &schemas.AIDecomposeIssueResponse{
		Plans: plansRaw.Plans,
	}

	return decompose, nil
}

func (gs *GeneralService) EstimateIssue(ctx context.Context, payload *schemas.AIEstimateIssuePayload) (*schemas.AIEstimateIssueResponse, error) {
	estimateRaw, response, err := gs.generalAPI.GeminiAPI.AiEstimateIssue(ctx).Request(openapiGeneral.SchemasAIEstimateIssuePayload{
		Goal:  payload.Goal,
		Issue: payload.Issue,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	estimate := &schemas.AIEstimateIssueResponse{
		Estimation: estimateRaw.Estimation,
	}

	return estimate, nil
}

type JobDone struct {
	ID          string
	CreatedAt   string
	UpdatedAt   string
	Description string
	Time        int32
	OwnerUuid   string
	OwnerName   string
	DayReportID string
	WayUUID     string
	WayName     string
	TagIDs      []string
}

func (gs *GeneralService) CreateJobDone(ctx context.Context, payload *schemas.CreateJobDonePayload) (*JobDone, error) {
	jobDoneRaw, response, err := gs.generalAPI.JobDoneAPI.CreateJobDone(ctx).Request(openapiGeneral.SchemasCreateJobDonePayload{
		DayReportUuid: payload.DayReportUuid,
		Description:   payload.Description,
		JobTagUuids:   payload.JobTagUuids,
		OwnerUuid:     payload.OwnerUuid,
		Time:          payload.Time,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	tags := make([]string, 5)
	for _, tag := range jobDoneRaw.Tags {
		tags = append(tags, tag.Uuid)
	}

	jobDone := &JobDone{
		ID:          jobDoneRaw.Uuid,
		CreatedAt:   jobDoneRaw.CreatedAt,
		UpdatedAt:   jobDoneRaw.UpdatedAt,
		Description: jobDoneRaw.Description,
		Time:        jobDoneRaw.Time,
		OwnerUuid:   jobDoneRaw.OwnerUuid,
		OwnerName:   jobDoneRaw.OwnerName,
		DayReportID: jobDoneRaw.DayReportUuid,
		WayUUID:     jobDoneRaw.WayUuid,
		WayName:     jobDoneRaw.WayName,
		TagIDs:      tags,
	}

	return jobDone, nil
}

type UpdateJobDoneParams struct {
	JobDoneID   string
	Description *string
	Time        *int32
}

func (gs *GeneralService) UpdateJobDone(ctx context.Context, params *UpdateJobDoneParams) (*JobDone, error) {
	jobDoneRaw, response, err := gs.generalAPI.JobDoneAPI.UpdateJobDone(ctx, params.JobDoneID).Request(openapiGeneral.SchemasUpdateJobDone{
		Description: params.Description,
		Time:        params.Time,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	tags := make([]string, 5)
	for _, tag := range jobDoneRaw.Tags {
		tags = append(tags, tag.Uuid)
	}

	jobDone := &JobDone{
		ID:          jobDoneRaw.Uuid,
		CreatedAt:   jobDoneRaw.CreatedAt,
		UpdatedAt:   jobDoneRaw.UpdatedAt,
		Description: jobDoneRaw.Description,
		Time:        jobDoneRaw.Time,
		OwnerUuid:   jobDoneRaw.OwnerUuid,
		OwnerName:   jobDoneRaw.OwnerName,
		DayReportID: jobDoneRaw.DayReportUuid,
		WayUUID:     jobDoneRaw.WayUuid,
		WayName:     jobDoneRaw.WayName,
		TagIDs:      tags,
	}

	return jobDone, nil
}

func (gs *GeneralService) DeleteJobDoneByID(ctx context.Context, jobDoneID string) error {
	response, err := gs.generalAPI.JobDoneAPI.DeleteJobDone(ctx, jobDoneID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) CreateJobDoneJobTag(ctx context.Context, payload *schemas.CreateJobDoneJobTagPayload) error {
	response, err := gs.generalAPI.JobDoneJobTagAPI.CreateJobDoneJobTag(ctx).Request(openapiGeneral.SchemasCreateJobDoneJobTagPayload{
		JobDoneUuid: payload.JobDoneUuid,
		JobTagUuid:  payload.JobTagUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) DeleteJobDoneJobTagById(ctx context.Context, jobDoneID, jobTagID string) error {
	response, err := gs.generalAPI.JobDoneJobTagAPI.DeleteJobDoneJobTag(ctx, jobDoneID, jobTagID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) CreateJobTag(ctx context.Context, payload *schemas.CreateJobTagPayload) (*schemas.JobTagResponse, error) {
	jobTagRaw, response, err := gs.generalAPI.JobTagAPI.CreateJobTag(ctx).Request(openapiGeneral.SchemasCreateJobTagPayload{
		Color:       payload.Color,
		Description: payload.Description,
		Name:        payload.Name,
		WayUuid:     payload.WayUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	jobTag := &schemas.JobTagResponse{
		Uuid:        jobTagRaw.Uuid,
		Name:        jobTagRaw.Name,
		Description: jobTagRaw.Description,
		Color:       jobTagRaw.Color,
	}

	return jobTag, nil

}

func (gs *GeneralService) GetLabelsByIDs(ctx context.Context, jobTagIDs []string) ([]schemas.JobTagResponse, error) {
}

type UpdateJobTagParams struct {
	JobTagID    string
	Name        string
	Description string
	Color       string
}

func (gs *GeneralService) UpdateJobTag(ctx context.Context, params *UpdateJobTagParams) (*schemas.JobTagResponse, error) {
	jobTagRaw, response, err := gs.generalAPI.JobTagAPI.UpdateJobTag(ctx, params.JobTagID).Request(openapiGeneral.SchemasUpdateJobTagPayload{
		Name:        &params.Name,
		Description: &params.Description,
		Color:       &params.Color,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	jobTag := &schemas.JobTagResponse{
		Uuid:        jobTagRaw.Uuid,
		Name:        jobTagRaw.Name,
		Description: jobTagRaw.Description,
		Color:       jobTagRaw.Color,
	}

	return jobTag, nil
}

func (gs *GeneralService) DeleteJobTagById(ctx context.Context, jobTagID string) error {
	response, err := gs.generalAPI.JobTagAPI.DeleteJobTag(ctx, jobTagID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

//func NewMentorUserWayService(mentorUserWayRepository IMentorUserWayRepository) *MentorUserWayService {
//}

func (gs *GeneralService) AddMentorUserWay(ctx context.Context, userID, wayID string) error {
	response, err := gs.generalAPI.MentorUserWayAPI.CreateMentorUserWay(ctx).Request(openapiGeneral.SchemasCreateMentorUserWayPayload{
		UserUuid: userID,
		WayUuid:  wayID,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) DeleteMentorUserWay(ctx context.Context, userID, wayID string) error {
	response, err := gs.generalAPI.MentorUserWayAPI.DeleteMentorUserWay(ctx).Request(openapiGeneral.SchemasDeleteMentorUserWayPayload{
		UserUuid: userID,
		WayUuid:  wayID,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

type MetricResult struct {
	MetricResponse *schemas.MetricResponse
	WayID          string
}

func (gs *GeneralService) CreateMetric(ctx context.Context, payload *schemas.CreateMetricPayload) (*MetricResult, error) {
	metricRaw, response, err := gs.generalAPI.MetricAPI.CreateMetric(ctx).Request(openapiGeneral.SchemasCreateMetricPayload{
		Description:    payload.Description,
		DoneDate:       payload.DoneDate,
		EstimationTime: payload.MetricEstimation,
		IsDone:         payload.IsDone,
		WayUuid:        payload.WayUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	metric := &MetricResult{
		WayID: payload.WayUuid,
		MetricResponse: &schemas.MetricResponse{
			Uuid:             metricRaw.Uuid,
			Description:      metricRaw.Description,
			IsDone:           metricRaw.IsDone,
			DoneDate:         metricRaw.DoneDate.Get(),
			MetricEstimation: metricRaw.EstimationTime,
		},
	}

	return metric, nil
}

type UpdateMetricParams struct {
	MetricID         string
	Description      *string
	IsDone           *bool
	MetricEstimation *int32
}

func (gs *GeneralService) UpdateMetric(ctx context.Context, params *UpdateMetricParams) (*MetricResult, error) {
	metricRaw, response, err := gs.generalAPI.MetricAPI.UpdateMetric(ctx, params.MetricID).Request(openapiGeneral.SchemasUpdateMetricPayload{
		Description:    params.Description,
		EstimationTime: params.MetricEstimation,
		IsDone:         params.IsDone,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	metric := &MetricResult{
		MetricResponse: &schemas.MetricResponse{
			Uuid:             metricRaw.Uuid,
			Description:      metricRaw.Description,
			IsDone:           metricRaw.IsDone,
			DoneDate:         metricRaw.DoneDate.Get(),
			MetricEstimation: metricRaw.EstimationTime,
		},
	}

	return metric, nil
}

func (gs *GeneralService) DeleteMetricById(ctx context.Context, metricID string) (string, error) {
	response, err := gs.generalAPI.MetricAPI.DeleteMetric(ctx, metricID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return "", fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return "", fmt.Errorf(message)
	}

	return "The metric has been deleted", nil
}

type Plan struct {
	ID          string
	CreatedAt   string
	UpdatedAt   string
	Description string
	Time        int32
	OwnerUuid   string
	OwnerName   string
	IsDone      bool
	DayReportID string
	WayUUID     string
	WayName     string
	TagIDs      []string
}

func (gs *GeneralService) CreatePlan(ctx context.Context, payload *schemas.CreatePlanPayload) (*Plan, error) {
	planRaw, response, err := gs.generalAPI.PlanAPI.CreatePlan(ctx).Request(openapiGeneral.SchemasCreatePlanPayload{
		DayReportUuid: payload.DayReportUuid,
		Description:   payload.Description,
		IsDone:        payload.IsDone,
		OwnerUuid:     payload.OwnerUuid,
		Time:          payload.Time,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	tags := make([]string, 5)
	for _, tag := range planRaw.Tags {
		tags = append(tags, tag.Uuid)
	}

	plan := &Plan{
		ID:          planRaw.Uuid,
		CreatedAt:   planRaw.CreatedAt,
		UpdatedAt:   planRaw.UpdatedAt,
		Description: planRaw.Description,
		Time:        planRaw.Time,
		OwnerUuid:   planRaw.OwnerUuid,
		OwnerName:   planRaw.OwnerName,
		IsDone:      planRaw.IsDone,
		DayReportID: planRaw.DayReportUuid,
		WayUUID:     planRaw.WayUuid,
		WayName:     planRaw.WayName,
		TagIDs:      tags,
	}

	return plan, nil
}

type UpdatePlanParams struct {
	PlanID      string
	Description *string
	Time        *int32
	IsDone      *bool
}

func (gs *GeneralService) UpdatePlan(ctx context.Context, params *UpdatePlanParams) (*Plan, error) {
	planRaw, response, err := gs.generalAPI.PlanAPI.UpdatePlan(ctx, params.PlanID).Request(openapiGeneral.SchemasUpdatePlanPayload{
		Description: params.Description,
		IsDone:      params.IsDone,
		Time:        params.Time,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	tags := make([]string, 5)
	for _, tag := range planRaw.Tags {
		tags = append(tags, tag.Uuid)
	}

	plan := &Plan{
		ID:          planRaw.Uuid,
		CreatedAt:   planRaw.CreatedAt,
		UpdatedAt:   planRaw.UpdatedAt,
		Description: planRaw.Description,
		Time:        planRaw.Time,
		OwnerUuid:   planRaw.OwnerUuid,
		OwnerName:   planRaw.OwnerName,
		IsDone:      planRaw.IsDone,
		DayReportID: planRaw.DayReportUuid,
		WayUUID:     planRaw.WayUuid,
		WayName:     planRaw.WayName,
		TagIDs:      tags,
	}

	return plan, nil
}

func (gs *GeneralService) DeletePlanById(ctx context.Context, planID string) error {
	response, err := gs.generalAPI.PlanAPI.DeletePlan(ctx, planID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) CreatePlanJobTag(ctx context.Context, payload *schemas.CreatePlanJobTagPayload) error {
	response, err := gs.generalAPI.PlanJobTagAPI.CreatePlanJobTag(ctx).Request(openapiGeneral.SchemasCreatePlanJobTagPayload{
		JobTagUuid: payload.JobTagUuid,
		PlanUuid:   payload.PlanUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil

}

func (gs *GeneralService) DeletePlanJobTagById(ctx context.Context, planID, jobTagID string) error {
	response, err := gs.generalAPI.PlanJobTagAPI.DeletePlanJobTag(ctx, jobTagID, planID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) CreateProblem(ctx context.Context, payload *schemas.CreateProblemPayload) (*schemas.ProblemPopulatedResponse, error) {
	problemRaw, response, err := gs.generalAPI.ProblemAPI.CreateProblem(ctx).Request(openapiGeneral.SchemasCreateProblemPayload{
		DayReportUuid: payload.DayReportUuid,
		Description:   payload.Description,
		IsDone:        payload.IsDone,
		OwnerUuid:     payload.OwnerUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	problem := &schemas.ProblemPopulatedResponse{
		Uuid:          problemRaw.Uuid,
		CreatedAt:     problemRaw.CreatedAt,
		UpdatedAt:     problemRaw.UpdatedAt,
		Description:   problemRaw.Description,
		IsDone:        problemRaw.IsDone,
		OwnerUuid:     problemRaw.OwnerUuid,
		OwnerName:     problemRaw.OwnerName,
		DayReportUuid: problemRaw.DayReportUuid,
		WayUUID:       problemRaw.WayUuid,
		WayName:       problemRaw.WayName,
	}

	return problem, nil
}

type UpdateProblemParams struct {
	ProblemID   string
	Description *string
	IsDone      *bool
}

func (gs *GeneralService) UpdateProblem(ctx context.Context, params *UpdateProblemParams) (*schemas.ProblemPopulatedResponse, error) {
	problemRaw, response, err := gs.generalAPI.ProblemAPI.UpdateProblem(ctx, params.ProblemID).Request(openapiGeneral.SchemasUpdateProblemPayload{
		Description: params.Description,
		IsDone:      params.IsDone,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	problem := &schemas.ProblemPopulatedResponse{
		Uuid:          problemRaw.Uuid,
		CreatedAt:     problemRaw.CreatedAt,
		UpdatedAt:     problemRaw.UpdatedAt,
		Description:   problemRaw.Description,
		IsDone:        problemRaw.IsDone,
		OwnerUuid:     problemRaw.OwnerUuid,
		OwnerName:     problemRaw.OwnerName,
		DayReportUuid: problemRaw.DayReportUuid,
		WayUUID:       problemRaw.WayUuid,
		WayName:       problemRaw.WayName,
	}

	return problem, nil

}

func (gs *GeneralService) DeleteProblemById(ctx context.Context, problemID string) error {
	response, err := gs.generalAPI.ProblemAPI.DeleteProblem(ctx, problemID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

type ProjectResponse struct {
	ID        string
	Name      string
	OwnerID   string
	IsPrivate bool
	WayIDs    []string
	UserIDs   []string
}

func (gs *GeneralService) CreateProject(ctx context.Context, payload *schemas.CreateProjectPayload) (*ProjectResponse, error) {
}

type UpdateProjectParams struct {
	ID        string
	Name      *string
	IsPrivate *bool
}

func (gs *GeneralService) UpdateProject(ctx context.Context, params *UpdateProjectParams) (*ProjectResponse, error) {
}

func (gs *GeneralService) GetProjectByID(ctx context.Context, projectID string) (*ProjectResponse, error) {
}

func (gs *GeneralService) DeleteProjectByID(ctx context.Context, projectID string) error {
}

func (gs *GeneralService) CreateToUserMentoringRequest(ctx context.Context, payload *schemas.CreateToUserMentoringRequestPayload) (*schemas.ToUserMentoringRequestResponse, error) {
	userMentorRaw, response, err := gs.generalAPI.ToUserMentoringRequestAPI.CreateUserMentoringRequest(ctx).Request(openapiGeneral.SchemasCreateToUserMentoringRequestPayload{
		UserUuid: payload.UserUuid,
		WayUuid:  payload.WayUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}
	userMentor := &schemas.ToUserMentoringRequestResponse{
		UserID: userMentorRaw.UserId,
		WayID:  userMentorRaw.WayId,
	}

	return userMentor, nil
}

func (gs *GeneralService) DeleteToUserMentoringRequestById(ctx context.Context, userID, wayID string) error {
	response, err := gs.generalAPI.ToUserMentoringRequestAPI.DeleteToUserMentoringRequest(ctx, userID, wayID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

type UpdateUserParams struct {
	UserID      string
	Name        *string
	Description *string
	ImageUrl    *string
	IsMentor    *bool
}

func (gs *GeneralService) UpdateUser(ctx context.Context, params *UpdateUserParams) (*schemas.UserPlainResponse, error) {
	userRaw, response, err := gs.generalAPI.UserAPI.UpdateUser(ctx, params.UserID).Request(openapiGeneral.SchemasUpdateUserPayload{
		Description: params.Description,
		ImageUrl:    params.ImageUrl,
		IsMentor:    params.IsMentor,
		Name:        params.Name,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	user := &schemas.UserPlainResponse{
		Uuid:        userRaw.Uuid,
		Name:        userRaw.Name,
		Email:       userRaw.Email,
		Description: userRaw.Description,
		CreatedAt:   userRaw.CreatedAt,
		ImageUrl:    userRaw.ImageUrl,
		IsMentor:    userRaw.IsMentor,
	}

	return user, nil
}

type GetAllUsersParams struct {
	MentorStatus string
	UserName     string
	UserEmail    string
	Offset       int
	ReqLimit     int
}

func (gs *GeneralService) GetAllUsers(ctx context.Context, params *GetAllUsersParams) (*schemas.GetAllUsersResponse, error) {
	usersRaw, response, err := gs.generalAPI.UserAPI.GetAllUsers(ctx).
		MentorStatus(params.MentorStatus).
		Name(params.UserName).
		Email(params.UserEmail).
		Page(int32(params.Offset)).
		Limit(int32(params.ReqLimit)).
		Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	users := make([]schemas.UserPlainResponseWithInfo, len(usersRaw.Users))
	for i, user := range usersRaw.Users {
		users[i] = schemas.UserPlainResponseWithInfo{
			Uuid:             user.Uuid,
			Name:             user.Name,
			Email:            user.Email,
			Description:      user.Description,
			CreatedAt:        user.CreatedAt,
			ImageUrl:         user.ImageUrl,
			IsMentor:         user.IsMentor,
			FavoriteForUsers: user.FavoriteForUsers,
			FavoriteWays:     user.FavoriteWays,
			MentoringWays:    user.MentoringWays,
			OwnWays:          user.OwnWays,
		}
	}

	return &schemas.GetAllUsersResponse{
		Size:  int64(len(users)),
		Users: users,
	}, nil
}

//func (gs *GeneralService) GetUsersByIDs(ctx context.Context, userIDs []string) ([]schemas.GetUsersByIDsResponse, error) {
//	usersPgUUIDs := lo.Map(userIDs, func(userID string, i int) pgtype.UUID)
//}

type CreateUserParams struct {
	Name        string
	Email       string
	Description string
	CreatedAt   time.Time
	ImageUrl    string
	IsMentor    bool
}

func (us *GeneralService) FindOrCreateUserByEmail(ctx context.Context, params *CreateUserParams) (*schemas.UserPopulatedResponse, error) {
}

func (us *GeneralService) CreateUser(ctx context.Context, params *CreateUserParams) (*schemas.UserPlainResponse, error) {
}

type dbWay struct {
	Uuid                pgtype.UUID
	Name                string
	OwnerUuid           pgtype.UUID
	GoalDescription     string
	UpdatedAt           time.Time
	CreatedAt           time.Time
	EstimationTime      int32
	CopiedFromWayUuid   pgtype.UUID
	ProjectUuid         pgtype.UUID
	IsCompleted         bool
	IsPrivate           bool
	WayMetricsTotal     int64
	WayMetricsDone      int64
	WayFavoriteForUsers int64
	WayDayReportsAmount int64
	ChildrenUuids       []string
}

func (us *GeneralService) GetPopulatedUserById(ctx context.Context, userUuid uuid.UUID) (*schemas.UserPopulatedResponse, error) {
}

func (us *GeneralService) convertDbWaysToPlainWays(ctx context.Context, dbWays []dbWay) []schemas.WayPlainResponse {
}

func (us *GeneralService) dbCollectionWaysToDbWays(rawWay []db.GetWaysByCollectionIdRow) []dbWay {}

func (us *GeneralService) dbMentoringWaysToDbWays(rawWay []db.GetMentoringWaysByMentorIdRow) []dbWay {
}

func (us *GeneralService) dbFavoriteWaysToDbWays(rawWay []db.GetFavoriteWaysByUserIdRow) []dbWay {}

func (us *GeneralService) GetPlainUserWithInfoByIDs(ctx context.Context, projectID string) ([]schemas.UserPlainResponseWithInfo, error) {
}

func (us *GeneralService) CreateUserProject(ctx context.Context, userID, projectID string) error {
}

func (us *GeneralService) DeleteUserProject(ctx context.Context, userID, projectID string) error {
}

func (uc *GeneralService) AddUserTagByName(ctx context.Context, payload *schemas.CreateUserTagPayload) (*schemas.UserTagResponse, error) {
}

func (us *GeneralService) DeleteUserTagByFromUserByTag(ctx context.Context, userID, userTagID string) error {
}

func (ws *GeneralService) GetPopulatedWayById(ctx context.Context, params GetPopulatedWayByIdParams) (*schemas.WayPopulatedResponse, error) {
}

func (gs *GeneralService) UpdateWayIsCompletedStatus(ctx context.Context, wayID string) error {
	//response, err := gs.generalAPI.WayAPI.
}

func (ws *GeneralService) GetPlainWayById(ctx context.Context, wayUUID uuid.UUID) (*schemas.WayPlainResponse, error) {
}

func (ws *GeneralService) CreateWay(ctx context.Context, payload *schemas.CreateWayPayload) (*schemas.WayPlainResponse, error) {
}

type UpdateWayParams struct {
	WayID           string
	Name            string
	GoalDescription string
	EstimationTime  int32
	IsPrivate       *bool
	IsCompleted     bool
}

func (ws *GeneralService) UpdateWay(ctx context.Context, params *UpdateWayParams) (*schemas.WayPlainResponse, error) {
}

type GetAllWaysParams struct {
	Status                 string
	WayName                string
	Offset                 int
	ReqMinDayReportsAmount int
	ReqLimit               int
}

func (ws *GeneralService) GetAllWays(ctx context.Context, params *GetAllWaysParams) (*schemas.GetAllWaysResponse, error) {
}

func (ws *GeneralService) DeleteWayById(ctx *gin.Context, wayID string) error {
	return ws.wayRepository.DeleteWay(ctx, pgtype.UUID{Bytes: uuid.MustParse(wayID), Valid: true})
}

func (ws *GeneralService) GetChildrenWayIDs(ctx context.Context, wayID uuid.UUID, maxDepth int) ([]uuid.UUID, error) {
}

func (ws *GeneralService) GetNestedWayIDs(ctx context.Context, parentWayUUID pgtype.UUID, currentDepth int, maxDepth int) ([]pgtype.UUID, error) {
}

func (ws *GeneralService) CreateWayCollection(ctx context.Context, payload *schemas.CreateWayCollectionPayload) (*schemas.WayCollectionPopulatedResponse, error) {
}

func (cc *GeneralService) UpdateWayCollection(ctx context.Context, wayCollectionID, wayCollectionName string) (*schemas.WayCollectionPlainResponse, error) {
}

func (ws *GeneralService) DeleteWayCollectionById(ctx context.Context, wayCollectionID string) error {
}

func (ws *GeneralService) CreateWayCollectionWay(ctx context.Context, payload *schemas.CreateWayCollectionWay) (*schemas.WayCollectionWayResponse, error) {
}

func (ws *GeneralService) DeleteWayCollectionWayById(ctx context.Context, wayID, wayCollectionID string) error {
}

type GetWayStatisticsTriplePeriodParams struct {
	WayUUIDs       []uuid.UUID
	TotalStartDate time.Time
	EndDate        time.Time
}

func (ws *GeneralService) GetWayStatisticsTriplePeriod(ctx context.Context, params *GetWayStatisticsTriplePeriodParams) (*schemas.WayStatisticsTriplePeriod, error) {
}

type GetWayStatisticsParams struct {
	WayPgUUIDs           []pgtype.UUID
	StartDatePgTimestamp pgtype.Timestamp
	EndDatePgTimestamp   pgtype.Timestamp
}

func (ws *GeneralService) GetWayStatistics(ctx context.Context, params *GetWayStatisticsParams) (*schemas.WayStatistics, error) {
}

func (ws *GeneralService) GetTimeSpentByDayChart(ctx context.Context, params *GetWayStatisticsParams) ([]schemas.TimeSpentByDayPoint, error) {
}

func (ws *GeneralService) GetOverallInformation(ctx context.Context, params *GetWayStatisticsParams) (*schemas.OverallInformation, error) {
}

func (ws *GeneralService) GetLabelStatistics(ctx context.Context, params *GetWayStatisticsParams) (*schemas.LabelStatistics, error) {
}

func (gs *GeneralService) AddWayTagToWay(ctx context.Context, name string, wayID string) (*schemas.WayTagResponse, error) {
	wayTagRaw, response, err := gs.generalAPI.WayTagAPI.CreateWayTag(ctx).Request(openapiGeneral.SchemasCreateWayTagPayload{
		WayUuid: wayID,
		Name:    name,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}
	wayTag := &schemas.WayTagResponse{
		Uuid: wayTagRaw.Uuid,
		Name: wayTagRaw.Name,
	}
	return wayTag, nil
}

func (gs *GeneralService) DeleteWayTagFromWayByTagID(ctx context.Context, wayTagID string, wayID string) error {
	response, err := gs.generalAPI.WayTagAPI.DeleteWayTag(ctx, wayTagID, wayID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}
