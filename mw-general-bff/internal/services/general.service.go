package services

import (
	"context"
	"fmt"

	"github.com/gin-gonic/gin"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/samber/lo"

	//"github.com/samber/lo"
	"mw-general-bff/internal/schemas"
	"mw-general-bff/pkg/utils"

	//db "mwserver/internal/db/sqlc"
	"time"

	openapiGeneral "mw-general-bff/apiAutogenerated/general"

	"github.com/google/uuid"
)

type GeneralService struct {
	generalAPI *openapiGeneral.APIClient
}

func NewGeneralService(generalAPI *openapiGeneral.APIClient) *GeneralService {
	return &GeneralService{generalAPI}
}

func (gs *GeneralService) CreateComment(ctx context.Context, payload *schemas.CreateCommentPayload) (*schemas.CommentPopulatedResponse, error) {
	commentRaw, response, err := gs.generalAPI.CommentAPI.CreateComment(ctx).Request(openapiGeneral.SchemasCreateCommentPayload{
		DayReportUuid: payload.DayReportUuid,
		Description:   payload.Description,
		OwnerUuid:     payload.OwnerUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	comment := &schemas.CommentPopulatedResponse{
		Uuid:          commentRaw.Uuid,
		Description:   commentRaw.Description,
		OwnerUuid:     commentRaw.OwnerUuid,
		OwnerName:     commentRaw.OwnerName,
		CreatedAt:     commentRaw.CreatedAt,
		UpdatedAt:     commentRaw.UpdatedAt,
		DayReportUuid: commentRaw.DayReportUuid,
		WayUUID:       commentRaw.WayUuid,
		WayName:       commentRaw.WayName,
	}

	return comment, nil
}

type UpdateCommentParams struct {
	CommentID   string
	Description *string
}

func (gs *GeneralService) UpdateComment(ctx context.Context, params *UpdateCommentParams) (*schemas.CommentPopulatedResponse, error) {
	updateReq := openapiGeneral.SchemasUpdateCommentPayload{
		Description: params.Description,
	}

	updatedCommentRaw, response, err := gs.generalAPI.CommentAPI.UpdateComment(ctx, params.CommentID).Request(updateReq).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	updatedComment := &schemas.CommentPopulatedResponse{
		Uuid:          updatedCommentRaw.Uuid,
		Description:   updatedCommentRaw.Description,
		OwnerUuid:     updatedCommentRaw.OwnerUuid,
		OwnerName:     updatedCommentRaw.OwnerName,
		CreatedAt:     updatedCommentRaw.CreatedAt,
		UpdatedAt:     updatedCommentRaw.UpdatedAt,
		DayReportUuid: updatedCommentRaw.DayReportUuid,
		WayUUID:       updatedCommentRaw.WayUuid,
		WayName:       updatedCommentRaw.WayName,
	}

	return updatedComment, nil
}

func (gs *GeneralService) DeleteCommentById(ctx context.Context, commentID string) error {
	response, err := gs.generalAPI.CommentAPI.DeleteComment(ctx, commentID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

type AddWayToCompositeWayParams struct {
	ChildWayID  string
	ParentWayID string
}

func (gs *GeneralService) AddWayToCompositeWay(ctx context.Context, params *schemas.AddWayToCompositeWayPayload) (*schemas.CompositeWayRelation, error) {
	relationRaw, response, err := gs.generalAPI.CompositeWayAPI.CreateCompositeWay(ctx).Request(openapiGeneral.SchemasAddWayToCompositeWayPayload{
		ChildWayUuid:  params.ChildWayUuid,
		ParentWayUuid: params.ParentWayUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	relation := &schemas.CompositeWayRelation{
		ChildWayUuid:  relationRaw.ChildWayUuid,
		ParentWayUuid: relationRaw.ParentWayUuid,
	}

	return relation, nil
}

func (gs *GeneralService) DeleteCompositeWayRelation(ctx context.Context, parentWayID, childWayID string) error {
	response, err := gs.generalAPI.CompositeWayAPI.DeleteCompositeWayRelation(ctx, parentWayID, childWayID).Execute()
	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

//type DayReportService struct {
//	dayReportRepository IDayReportRepository
//}
//
//func NewDayReportService(dayReportRepository IDayReportRepository) *DayReportService {
//	return &DayReportService{dayReportRepository}
//}

type GetDayReportsByWayIdParams struct {
	ParentWayID    uuid.UUID
	ChildrenWayIDs []uuid.UUID
	ReqLimit       int
	Offset         int
}

func (gs *GeneralService) GetDayReportsByWayID(ctx context.Context, params *GetDayReportsByWayIdParams) (*schemas.ListDayReportsResponse, error) {
	reportsRaw, response, err := gs.generalAPI.DayReportAPI.GetDayReports(ctx, params.ParentWayID.String()).Page(int32(params.Offset)).Limit(int32(params.ReqLimit)).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	dayReports := lo.Map(reportsRaw.DayReports, func(report openapiGeneral.SchemasCompositeDayReportPopulatedResponse, _ int) schemas.CompositeDayReportPopulatedResponse {
		compositionParticipants := lo.Map(report.CompositionParticipants, func(p openapiGeneral.SchemasDayReportsCompositionParticipants, _ int) schemas.DayReportsCompositionParticipants {
			return schemas.DayReportsCompositionParticipants{
				DayReportID: p.DayReportId,
				WayID:       p.WayId,
				WayName:     p.WayName,
			}
		})

		jobsDone := lo.Map(report.JobsDone, func(job openapiGeneral.SchemasJobDonePopulatedResponse, _ int) schemas.JobDonePopulatedResponse {
			tags := lo.Map(job.Tags, func(tag openapiGeneral.SchemasJobTagResponse, _ int) schemas.JobTagResponse {
				return schemas.JobTagResponse{
					Uuid:        tag.Uuid,
					Name:        tag.Name,
					Description: tag.Description,
					Color:       tag.Color,
				}
			})

			return schemas.JobDonePopulatedResponse{
				Uuid:          job.Uuid,
				CreatedAt:     job.CreatedAt,
				UpdatedAt:     job.UpdatedAt,
				Description:   job.Description,
				Time:          job.Time,
				OwnerUuid:     job.OwnerUuid,
				OwnerName:     job.OwnerName,
				DayReportUuid: job.DayReportUuid,
				WayUUID:       job.WayUuid,
				WayName:       job.WayName,
				Tags:          tags,
			}
		})

		plans := lo.Map(report.Plans, func(plan openapiGeneral.SchemasPlanPopulatedResponse, _ int) schemas.PlanPopulatedResponse {
			tags := lo.Map(plan.Tags, func(tag openapiGeneral.SchemasJobTagResponse, _ int) schemas.JobTagResponse {
				return schemas.JobTagResponse{
					Uuid:        tag.Uuid,
					Name:        tag.Name,
					Description: tag.Description,
					Color:       tag.Color,
				}
			})

			return schemas.PlanPopulatedResponse{
				Uuid:          plan.Uuid,
				CreatedAt:     plan.CreatedAt,
				UpdatedAt:     plan.UpdatedAt,
				Description:   plan.Description,
				Time:          plan.Time,
				OwnerUuid:     plan.OwnerUuid,
				OwnerName:     plan.OwnerName,
				IsDone:        plan.IsDone,
				DayReportUuid: plan.DayReportUuid,
				WayUUID:       plan.WayUuid,
				WayName:       plan.WayName,
				Tags:          tags,
			}
		})

		problems := lo.Map(report.Problems, func(problem openapiGeneral.SchemasProblemPopulatedResponse, _ int) schemas.ProblemPopulatedResponse {
			return schemas.ProblemPopulatedResponse{
				Uuid:          problem.Uuid,
				CreatedAt:     problem.CreatedAt,
				UpdatedAt:     problem.UpdatedAt,
				Description:   problem.Description,
				IsDone:        problem.IsDone,
				OwnerUuid:     problem.OwnerUuid,
				OwnerName:     problem.OwnerName,
				DayReportUuid: problem.DayReportUuid,
				WayUUID:       problem.WayUuid,
				WayName:       problem.WayName,
			}
		})

		comments := lo.Map(report.Comments, func(comment openapiGeneral.SchemasCommentPopulatedResponse, _ int) schemas.CommentPopulatedResponse {
			return schemas.CommentPopulatedResponse{
				Uuid:          comment.Uuid,
				Description:   comment.Description,
				OwnerUuid:     comment.OwnerUuid,
				OwnerName:     comment.OwnerName,
				CreatedAt:     comment.CreatedAt,
				UpdatedAt:     comment.UpdatedAt,
				DayReportUuid: comment.DayReportUuid,
				WayUUID:       comment.WayUuid,
				WayName:       comment.WayName,
			}
		})

		return schemas.CompositeDayReportPopulatedResponse{
			UUID:                    report.Uuid,
			CreatedAt:               report.CreatedAt,
			UpdatedAt:               report.UpdatedAt,
			CompositionParticipants: compositionParticipants,
			JobsDone:                jobsDone,
			Plans:                   plans,
			Problems:                problems,
			Comments:                comments,
		}
	})

	reports := &schemas.ListDayReportsResponse{
		DayReports: dayReports,
		Size:       int(reportsRaw.Size),
	}

	return reports, nil
}

type GetLastDayReportDateResponse struct {
	TotalStartDate time.Time
	EndDate        time.Time
}

func (gs *GeneralService) GetLastDayReportDate(ctx context.Context, wayUUIDs []uuid.UUID) (*GetLastDayReportDateResponse, error) {
	return nil, nil
}

func (gs *GeneralService) CreateDayReport(ctx context.Context, wayID string) (*schemas.CompositeDayReportPopulatedResponse, error) {
	dayReportRaw, response, err := gs.generalAPI.DayReportAPI.CreateDayReport(ctx).Request(openapiGeneral.SchemasCreateDayReportPayload{
		WayId: wayID,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	compositionParticipants := lo.Map(dayReportRaw.CompositionParticipants, func(p openapiGeneral.SchemasDayReportsCompositionParticipants, _ int) schemas.DayReportsCompositionParticipants {
		return schemas.DayReportsCompositionParticipants{
			DayReportID: p.DayReportId,
			WayID:       p.WayId,
			WayName:     p.WayName,
		}
	})

	jobsDone := lo.Map(dayReportRaw.JobsDone, func(job openapiGeneral.SchemasJobDonePopulatedResponse, _ int) schemas.JobDonePopulatedResponse {
		tags := lo.Map(job.Tags, func(tag openapiGeneral.SchemasJobTagResponse, _ int) schemas.JobTagResponse {
			return schemas.JobTagResponse{
				Uuid:        tag.Uuid,
				Name:        tag.Name,
				Description: tag.Description,
				Color:       tag.Color,
			}
		})

		return schemas.JobDonePopulatedResponse{
			Uuid:          job.Uuid,
			CreatedAt:     job.CreatedAt,
			UpdatedAt:     job.UpdatedAt,
			Description:   job.Description,
			Time:          job.Time,
			OwnerUuid:     job.OwnerUuid,
			OwnerName:     job.OwnerName,
			DayReportUuid: job.DayReportUuid,
			WayUUID:       job.WayUuid,
			WayName:       job.WayName,
			Tags:          tags,
		}
	})

	plans := lo.Map(dayReportRaw.Plans, func(plan openapiGeneral.SchemasPlanPopulatedResponse, _ int) schemas.PlanPopulatedResponse {
		tags := lo.Map(plan.Tags, func(tag openapiGeneral.SchemasJobTagResponse, _ int) schemas.JobTagResponse {
			return schemas.JobTagResponse{
				Uuid:        tag.Uuid,
				Name:        tag.Name,
				Description: tag.Description,
				Color:       tag.Color,
			}
		})

		return schemas.PlanPopulatedResponse{
			Uuid:          plan.Uuid,
			CreatedAt:     plan.CreatedAt,
			UpdatedAt:     plan.UpdatedAt,
			Description:   plan.Description,
			Time:          plan.Time,
			OwnerUuid:     plan.OwnerUuid,
			OwnerName:     plan.OwnerName,
			IsDone:        plan.IsDone,
			DayReportUuid: plan.DayReportUuid,
			WayUUID:       plan.WayUuid,
			WayName:       plan.WayName,
			Tags:          tags,
		}
	})

	problems := lo.Map(dayReportRaw.Problems, func(problem openapiGeneral.SchemasProblemPopulatedResponse, _ int) schemas.ProblemPopulatedResponse {
		return schemas.ProblemPopulatedResponse{
			Uuid:          problem.Uuid,
			CreatedAt:     problem.CreatedAt,
			UpdatedAt:     problem.UpdatedAt,
			Description:   problem.Description,
			IsDone:        problem.IsDone,
			OwnerUuid:     problem.OwnerUuid,
			OwnerName:     problem.OwnerName,
			DayReportUuid: problem.DayReportUuid,
			WayUUID:       problem.WayUuid,
			WayName:       problem.WayName,
		}
	})

	comments := lo.Map(dayReportRaw.Comments, func(comment openapiGeneral.SchemasCommentPopulatedResponse, _ int) schemas.CommentPopulatedResponse {
		return schemas.CommentPopulatedResponse{
			Uuid:          comment.Uuid,
			Description:   comment.Description,
			OwnerUuid:     comment.OwnerUuid,
			OwnerName:     comment.OwnerName,
			CreatedAt:     comment.CreatedAt,
			UpdatedAt:     comment.UpdatedAt,
			DayReportUuid: comment.DayReportUuid,
			WayUUID:       comment.WayUuid,
			WayName:       comment.WayName,
		}
	})

	dayReports := &schemas.CompositeDayReportPopulatedResponse{
		UUID:                    dayReportRaw.Uuid,
		CreatedAt:               dayReportRaw.CreatedAt,
		UpdatedAt:               dayReportRaw.UpdatedAt,
		CompositionParticipants: compositionParticipants,
		JobsDone:                jobsDone,
		Plans:                   plans,
		Problems:                problems,
		Comments:                comments,
	}

	return dayReports, nil
}

func (gs *GeneralService) CreateFavoriteUser(ctx context.Context, payload *schemas.CreateFavoriteUserPayload) error {

	response, err := gs.generalAPI.FavoriteUserAPI.CreateFavoriteUser(ctx).
		Request(openapiGeneral.SchemasCreateFavoriteUserPayload{
			DonorUserUuid:    payload.DonorUserUuid.String(),
			AcceptorUserUuid: payload.AcceptorUserUuid.String(),
		}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) DeleteFavoriteUserById(ctx context.Context, donorUserUuid, acceptorUserUuid string) error {
	response, err := gs.generalAPI.FavoriteUserAPI.DeleteFavoriteUser(ctx, donorUserUuid, acceptorUserUuid).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) CreateFavoriteUserWay(ctx context.Context, userUUID, wayUUID uuid.UUID) error {
	response, err := gs.generalAPI.FavoriteUserWayAPI.CreateFavoriteUserWay(ctx).Request(openapiGeneral.SchemasCreateFavoriteUserWayPayload{
		UserUuid: userUUID.String(),
		WayUuid:  wayUUID.String(),
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (fuws *GeneralService) DeleteFavoriteUserWayById(ctx context.Context, userID, wayID string) error {
	response, err := fuws.generalAPI.FavoriteUserWayAPI.DeleteFavoriteUserWay(ctx, userID, wayID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

//func NewFromUserMentoringRequestService(fromUserMentoringRequestRepository IFromUserMentoringRequestRepository) *FromUserMentoringRequestService {
//	return &FromUserMentoringRequestService{fromUserMentoringRequestRepository}
//}

func (gs *GeneralService) CreateFromUserMentoringRequest(ctx context.Context, userID, wayID string) (*schemas.FromUserMentoringRequestResponse, error) {
	fromUserMentoringRaw, response, err := gs.generalAPI.FromUserMentoringRequestAPI.CreateFromUserMentoringRequest(ctx).Request(openapiGeneral.SchemasCreateFromUserMentoringRequestPayload{
		UserUuid: userID,
		WayUuid:  wayID,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	result := &schemas.FromUserMentoringRequestResponse{
		UserID: fromUserMentoringRaw.UserId,
		WayID:  fromUserMentoringRaw.WayId,
	}

	return result, nil
}

func (gs *GeneralService) DeleteFromUserMentoringRequestById(ctx context.Context, userID, wayID string) error {
	response, err := gs.generalAPI.FromUserMentoringRequestAPI.DeleteFromUserMentoringRequest(ctx, userID, wayID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) CreateMetricsPrompt(ctx context.Context, payload *schemas.GenerateMetricsPayload) (*schemas.GenerateMetricsResponse, error) {
	metricsRow, response, err := gs.generalAPI.GeminiAPI.GenerateMetrics(ctx).Request(openapiGeneral.SchemasGenerateMetricsPayload{
		GoalDescription: payload.GoalDescription,
		Metrics:         payload.Metrics,
		WayName:         payload.WayName,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	metrics := &schemas.GenerateMetricsResponse{
		Metrics: &metricsRow.Metrics,
	}

	return metrics, nil
}

func (gs *GeneralService) GetMetricsByGoal(ctx context.Context, payload *schemas.GenerateMetricsPayload) ([]string, error) {
	return nil, nil
}

func (gs *GeneralService) AIChat(ctx context.Context, payload *schemas.AIChatPayload) (*schemas.AIChatResponse, error) {
	aiChatRow, response, err := gs.generalAPI.GeminiAPI.AiChat(ctx).Request(openapiGeneral.SchemasAIChatPayload{
		Message: payload.Message,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}
	aiChat := &schemas.AIChatResponse{
		Message: aiChatRow.Message,
	}

	return aiChat, nil
}

func (gs *GeneralService) GeneratePlansByMetric(ctx context.Context, payload *schemas.AIGeneratePlansByMetricPayload) (*schemas.AIGeneratePlansByMetricResponse, error) {
	plansRaw, response, err := gs.generalAPI.GeminiAPI.AiPlansByMetrics(ctx).Request(openapiGeneral.SchemasAIGeneratePlansByMetricPayload{
		Goal:   payload.Goal,
		Metric: payload.Metric,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	plans := &schemas.AIGeneratePlansByMetricResponse{
		Plans: plansRaw.Plans,
	}

	return plans, nil

}

func (gs *GeneralService) CommentIssue(ctx context.Context, payload *schemas.AICommentIssuePayload) (*schemas.AICommentIssueResponse, error) {
	commentRaw, response, err := gs.generalAPI.GeminiAPI.AiCommentIssue(ctx).Request(openapiGeneral.SchemasAICommentIssuePayload{
		Goal:    payload.Goal,
		Message: payload.Message,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	comment := &schemas.AICommentIssueResponse{
		Comment: commentRaw.Goal,
	}

	return comment, nil

}

func (gs *GeneralService) DecomposeIssue(ctx context.Context, payload *schemas.AIDecomposeIssuePayload) (*schemas.AIDecomposeIssueResponse, error) {
	plansRaw, response, err := gs.generalAPI.GeminiAPI.AiDecomposeIssue(ctx).Request(openapiGeneral.SchemasAIDecomposeIssuePayload{
		Goal:    payload.Goal,
		Message: payload.Message,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	decompose := &schemas.AIDecomposeIssueResponse{
		Plans: plansRaw.Plans,
	}

	return decompose, nil
}

func (gs *GeneralService) EstimateIssue(ctx context.Context, payload *schemas.AIEstimateIssuePayload) (*schemas.AIEstimateIssueResponse, error) {
	estimateRaw, response, err := gs.generalAPI.GeminiAPI.AiEstimateIssue(ctx).Request(openapiGeneral.SchemasAIEstimateIssuePayload{
		Goal:  payload.Goal,
		Issue: payload.Issue,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	estimate := &schemas.AIEstimateIssueResponse{
		Estimation: estimateRaw.Estimation,
	}

	return estimate, nil
}

type JobDone struct {
	ID          string
	CreatedAt   string
	UpdatedAt   string
	Description string
	Time        int32
	OwnerUuid   string
	OwnerName   string
	DayReportID string
	WayUUID     string
	WayName     string
	TagIDs      []string
}

func (gs *GeneralService) CreateJobDone(ctx context.Context, payload *schemas.CreateJobDonePayload) (*JobDone, error) {
	jobDoneRaw, response, err := gs.generalAPI.JobDoneAPI.CreateJobDone(ctx).Request(openapiGeneral.SchemasCreateJobDonePayload{
		DayReportUuid: payload.DayReportUuid,
		Description:   payload.Description,
		JobTagUuids:   payload.JobTagUuids,
		OwnerUuid:     payload.OwnerUuid,
		Time:          payload.Time,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	tags := make([]string, 5)
	for _, tag := range jobDoneRaw.Tags {
		tags = append(tags, tag.Uuid)
	}

	jobDone := &JobDone{
		ID:          jobDoneRaw.Uuid,
		CreatedAt:   jobDoneRaw.CreatedAt,
		UpdatedAt:   jobDoneRaw.UpdatedAt,
		Description: jobDoneRaw.Description,
		Time:        jobDoneRaw.Time,
		OwnerUuid:   jobDoneRaw.OwnerUuid,
		OwnerName:   jobDoneRaw.OwnerName,
		DayReportID: jobDoneRaw.DayReportUuid,
		WayUUID:     jobDoneRaw.WayUuid,
		WayName:     jobDoneRaw.WayName,
		TagIDs:      tags,
	}

	return jobDone, nil
}

type UpdateJobDoneParams struct {
	JobDoneID   string
	Description *string
	Time        *int32
}

func (gs *GeneralService) UpdateJobDone(ctx context.Context, params *UpdateJobDoneParams) (*JobDone, error) {
	jobDoneRaw, response, err := gs.generalAPI.JobDoneAPI.UpdateJobDone(ctx, params.JobDoneID).Request(openapiGeneral.SchemasUpdateJobDone{
		Description: params.Description,
		Time:        params.Time,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	tags := make([]string, 5)
	for _, tag := range jobDoneRaw.Tags {
		tags = append(tags, tag.Uuid)
	}

	jobDone := &JobDone{
		ID:          jobDoneRaw.Uuid,
		CreatedAt:   jobDoneRaw.CreatedAt,
		UpdatedAt:   jobDoneRaw.UpdatedAt,
		Description: jobDoneRaw.Description,
		Time:        jobDoneRaw.Time,
		OwnerUuid:   jobDoneRaw.OwnerUuid,
		OwnerName:   jobDoneRaw.OwnerName,
		DayReportID: jobDoneRaw.DayReportUuid,
		WayUUID:     jobDoneRaw.WayUuid,
		WayName:     jobDoneRaw.WayName,
		TagIDs:      tags,
	}

	return jobDone, nil
}

func (gs *GeneralService) DeleteJobDoneByID(ctx context.Context, jobDoneID string) error {
	response, err := gs.generalAPI.JobDoneAPI.DeleteJobDone(ctx, jobDoneID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) CreateJobDoneJobTag(ctx context.Context, payload *schemas.CreateJobDoneJobTagPayload) error {
	response, err := gs.generalAPI.JobDoneJobTagAPI.CreateJobDoneJobTag(ctx).Request(openapiGeneral.SchemasCreateJobDoneJobTagPayload{
		JobDoneUuid: payload.JobDoneUuid,
		JobTagUuid:  payload.JobTagUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) DeleteJobDoneJobTagById(ctx context.Context, jobDoneID, jobTagID string) error {
	response, err := gs.generalAPI.JobDoneJobTagAPI.DeleteJobDoneJobTag(ctx, jobDoneID, jobTagID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) CreateJobTag(ctx context.Context, payload *schemas.CreateJobTagPayload) (*schemas.JobTagResponse, error) {
	jobTagRaw, response, err := gs.generalAPI.JobTagAPI.CreateJobTag(ctx).Request(openapiGeneral.SchemasCreateJobTagPayload{
		Color:       payload.Color,
		Description: payload.Description,
		Name:        payload.Name,
		WayUuid:     payload.WayUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	jobTag := &schemas.JobTagResponse{
		Uuid:        jobTagRaw.Uuid,
		Name:        jobTagRaw.Name,
		Description: jobTagRaw.Description,
		Color:       jobTagRaw.Color,
	}

	return jobTag, nil

}

// TODO
func (gs *GeneralService) GetLabelsByIDs(ctx context.Context, jobTagIDs []string) ([]schemas.JobTagResponse, error) {
	return nil, nil
}

type UpdateJobTagParams struct {
	JobTagID    string
	Name        string
	Description string
	Color       string
}

func (gs *GeneralService) UpdateJobTag(ctx context.Context, params *UpdateJobTagParams) (*schemas.JobTagResponse, error) {
	jobTagRaw, response, err := gs.generalAPI.JobTagAPI.UpdateJobTag(ctx, params.JobTagID).Request(openapiGeneral.SchemasUpdateJobTagPayload{
		Name:        &params.Name,
		Description: &params.Description,
		Color:       &params.Color,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	jobTag := &schemas.JobTagResponse{
		Uuid:        jobTagRaw.Uuid,
		Name:        jobTagRaw.Name,
		Description: jobTagRaw.Description,
		Color:       jobTagRaw.Color,
	}

	return jobTag, nil
}

func (gs *GeneralService) DeleteJobTagById(ctx context.Context, jobTagID string) error {
	response, err := gs.generalAPI.JobTagAPI.DeleteJobTag(ctx, jobTagID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

//func NewMentorUserWayService(mentorUserWayRepository IMentorUserWayRepository) *MentorUserWayService {
//}

func (gs *GeneralService) AddMentorUserWay(ctx context.Context, userID, wayID string) error {
	response, err := gs.generalAPI.MentorUserWayAPI.CreateMentorUserWay(ctx).Request(openapiGeneral.SchemasCreateMentorUserWayPayload{
		UserUuid: userID,
		WayUuid:  wayID,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) DeleteMentorUserWay(ctx context.Context, userID, wayID string) error {
	response, err := gs.generalAPI.MentorUserWayAPI.DeleteMentorUserWay(ctx).Request(openapiGeneral.SchemasDeleteMentorUserWayPayload{
		UserUuid: userID,
		WayUuid:  wayID,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

type MetricResult struct {
	MetricResponse *schemas.MetricResponse
	WayID          string
}

func (gs *GeneralService) CreateMetric(ctx context.Context, payload *schemas.CreateMetricPayload) (*MetricResult, error) {
	metricRaw, response, err := gs.generalAPI.MetricAPI.CreateMetric(ctx).Request(openapiGeneral.SchemasCreateMetricPayload{
		Description:    payload.Description,
		DoneDate:       payload.DoneDate,
		EstimationTime: payload.MetricEstimation,
		IsDone:         payload.IsDone,
		WayUuid:        payload.WayUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	metric := &MetricResult{
		WayID: payload.WayUuid,
		MetricResponse: &schemas.MetricResponse{
			Uuid:             metricRaw.Uuid,
			Description:      metricRaw.Description,
			IsDone:           metricRaw.IsDone,
			DoneDate:         metricRaw.DoneDate.Get(),
			MetricEstimation: metricRaw.EstimationTime,
		},
	}

	return metric, nil
}

type UpdateMetricParams struct {
	MetricID         string
	Description      *string
	IsDone           *bool
	MetricEstimation *int32
}

func (gs *GeneralService) UpdateMetric(ctx context.Context, params *UpdateMetricParams) (*MetricResult, error) {
	metricRaw, response, err := gs.generalAPI.MetricAPI.UpdateMetric(ctx, params.MetricID).Request(openapiGeneral.SchemasUpdateMetricPayload{
		Description:    params.Description,
		EstimationTime: params.MetricEstimation,
		IsDone:         params.IsDone,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	metric := &MetricResult{
		MetricResponse: &schemas.MetricResponse{
			Uuid:             metricRaw.Uuid,
			Description:      metricRaw.Description,
			IsDone:           metricRaw.IsDone,
			DoneDate:         metricRaw.DoneDate.Get(),
			MetricEstimation: metricRaw.EstimationTime,
		},
	}

	return metric, nil
}

func (gs *GeneralService) DeleteMetricById(ctx context.Context, metricID string) (string, error) {
	response, err := gs.generalAPI.MetricAPI.DeleteMetric(ctx, metricID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return "", fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return "", fmt.Errorf(message)
	}

	return "The metric has been deleted", nil
}

type Plan struct {
	ID          string
	CreatedAt   string
	UpdatedAt   string
	Description string
	Time        int32
	OwnerUuid   string
	OwnerName   string
	IsDone      bool
	DayReportID string
	WayUUID     string
	WayName     string
	TagIDs      []string
}

func (gs *GeneralService) CreatePlan(ctx context.Context, payload *schemas.CreatePlanPayload) (*Plan, error) {
	planRaw, response, err := gs.generalAPI.PlanAPI.CreatePlan(ctx).Request(openapiGeneral.SchemasCreatePlanPayload{
		DayReportUuid: payload.DayReportUuid,
		Description:   payload.Description,
		IsDone:        payload.IsDone,
		OwnerUuid:     payload.OwnerUuid,
		Time:          payload.Time,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	tags := make([]string, 5)
	for _, tag := range planRaw.Tags {
		tags = append(tags, tag.Uuid)
	}

	plan := &Plan{
		ID:          planRaw.Uuid,
		CreatedAt:   planRaw.CreatedAt,
		UpdatedAt:   planRaw.UpdatedAt,
		Description: planRaw.Description,
		Time:        planRaw.Time,
		OwnerUuid:   planRaw.OwnerUuid,
		OwnerName:   planRaw.OwnerName,
		IsDone:      planRaw.IsDone,
		DayReportID: planRaw.DayReportUuid,
		WayUUID:     planRaw.WayUuid,
		WayName:     planRaw.WayName,
		TagIDs:      tags,
	}

	return plan, nil
}

type UpdatePlanParams struct {
	PlanID      string
	Description *string
	Time        *int32
	IsDone      *bool
}

func (gs *GeneralService) UpdatePlan(ctx context.Context, params *UpdatePlanParams) (*Plan, error) {
	planRaw, response, err := gs.generalAPI.PlanAPI.UpdatePlan(ctx, params.PlanID).Request(openapiGeneral.SchemasUpdatePlanPayload{
		Description: params.Description,
		IsDone:      params.IsDone,
		Time:        params.Time,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	tags := make([]string, 5)
	for _, tag := range planRaw.Tags {
		tags = append(tags, tag.Uuid)
	}

	plan := &Plan{
		ID:          planRaw.Uuid,
		CreatedAt:   planRaw.CreatedAt,
		UpdatedAt:   planRaw.UpdatedAt,
		Description: planRaw.Description,
		Time:        planRaw.Time,
		OwnerUuid:   planRaw.OwnerUuid,
		OwnerName:   planRaw.OwnerName,
		IsDone:      planRaw.IsDone,
		DayReportID: planRaw.DayReportUuid,
		WayUUID:     planRaw.WayUuid,
		WayName:     planRaw.WayName,
		TagIDs:      tags,
	}

	return plan, nil
}

func (gs *GeneralService) DeletePlanById(ctx context.Context, planID string) error {
	response, err := gs.generalAPI.PlanAPI.DeletePlan(ctx, planID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) CreatePlanJobTag(ctx context.Context, payload *schemas.CreatePlanJobTagPayload) error {
	response, err := gs.generalAPI.PlanJobTagAPI.CreatePlanJobTag(ctx).Request(openapiGeneral.SchemasCreatePlanJobTagPayload{
		JobTagUuid: payload.JobTagUuid,
		PlanUuid:   payload.PlanUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil

}

func (gs *GeneralService) DeletePlanJobTagById(ctx context.Context, planID, jobTagID string) error {
	response, err := gs.generalAPI.PlanJobTagAPI.DeletePlanJobTag(ctx, jobTagID, planID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) CreateProblem(ctx context.Context, payload *schemas.CreateProblemPayload) (*schemas.ProblemPopulatedResponse, error) {
	problemRaw, response, err := gs.generalAPI.ProblemAPI.CreateProblem(ctx).Request(openapiGeneral.SchemasCreateProblemPayload{
		DayReportUuid: payload.DayReportUuid,
		Description:   payload.Description,
		IsDone:        payload.IsDone,
		OwnerUuid:     payload.OwnerUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	problem := &schemas.ProblemPopulatedResponse{
		Uuid:          problemRaw.Uuid,
		CreatedAt:     problemRaw.CreatedAt,
		UpdatedAt:     problemRaw.UpdatedAt,
		Description:   problemRaw.Description,
		IsDone:        problemRaw.IsDone,
		OwnerUuid:     problemRaw.OwnerUuid,
		OwnerName:     problemRaw.OwnerName,
		DayReportUuid: problemRaw.DayReportUuid,
		WayUUID:       problemRaw.WayUuid,
		WayName:       problemRaw.WayName,
	}

	return problem, nil
}

type UpdateProblemParams struct {
	ProblemID   string
	Description *string
	IsDone      *bool
}

func (gs *GeneralService) UpdateProblem(ctx context.Context, params *UpdateProblemParams) (*schemas.ProblemPopulatedResponse, error) {
	problemRaw, response, err := gs.generalAPI.ProblemAPI.UpdateProblem(ctx, params.ProblemID).Request(openapiGeneral.SchemasUpdateProblemPayload{
		Description: params.Description,
		IsDone:      params.IsDone,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	problem := &schemas.ProblemPopulatedResponse{
		Uuid:          problemRaw.Uuid,
		CreatedAt:     problemRaw.CreatedAt,
		UpdatedAt:     problemRaw.UpdatedAt,
		Description:   problemRaw.Description,
		IsDone:        problemRaw.IsDone,
		OwnerUuid:     problemRaw.OwnerUuid,
		OwnerName:     problemRaw.OwnerName,
		DayReportUuid: problemRaw.DayReportUuid,
		WayUUID:       problemRaw.WayUuid,
		WayName:       problemRaw.WayName,
	}

	return problem, nil

}

func (gs *GeneralService) DeleteProblemById(ctx context.Context, problemID string) error {
	response, err := gs.generalAPI.ProblemAPI.DeleteProblem(ctx, problemID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

type ProjectResponse struct {
	ID        string
	Name      string
	OwnerID   string
	IsPrivate bool
	WayIDs    []string
	UserIDs   []string
}

func (gs *GeneralService) CreateProject(ctx context.Context, payload *schemas.CreateProjectPayload) (*ProjectResponse, error) {
	projectRaw, response, err := gs.generalAPI.ProjectAPI.CreateProject(ctx).Request(openapiGeneral.SchemasCreateProjectPayload{
		Name:    payload.Name,
		OwnerId: payload.OwnerID,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	wayIDs := make([]string, len(projectRaw.Ways))
	for i, way := range projectRaw.Ways {
		wayIDs[i] = way.Uuid
	}

	userIDs := make([]string, len(projectRaw.Users))
	for i, user := range projectRaw.Users {
		userIDs[i] = user.Uuid
	}
	project := &ProjectResponse{
		ID:        projectRaw.Id,
		Name:      projectRaw.Name,
		OwnerID:   projectRaw.OwnerId,
		IsPrivate: projectRaw.IsPrivate,
		WayIDs:    wayIDs,
		UserIDs:   userIDs,
	}
	return project, nil
}

type UpdateProjectParams struct {
	ID        string
	Name      *string
	IsPrivate *bool
}

func (gs *GeneralService) UpdateProject(ctx context.Context, params *UpdateProjectParams) (*ProjectResponse, error) {
	projectRaw, response, err := gs.generalAPI.ProjectAPI.UpdateProject(ctx, params.ID).Request(openapiGeneral.SchemasUpdateProjectPayload{
		IsPrivate: params.IsPrivate,
		Name:      params.Name,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	wayIDs := make([]string, len(projectRaw.Ways))
	for i, way := range projectRaw.Ways {
		wayIDs[i] = way.Uuid
	}

	userIDs := make([]string, len(projectRaw.Users))
	for i, user := range projectRaw.Users {
		userIDs[i] = user.Uuid
	}
	project := &ProjectResponse{
		ID:        projectRaw.Id,
		Name:      projectRaw.Name,
		OwnerID:   projectRaw.OwnerId,
		IsPrivate: projectRaw.IsPrivate,
		WayIDs:    wayIDs,
		UserIDs:   userIDs,
	}
	return project, nil
}

func (gs *GeneralService) GetProjectByID(ctx context.Context, projectID string) (*ProjectResponse, error) {
	projectRaw, response, err := gs.generalAPI.ProjectAPI.GetProject(ctx, projectID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	wayIDs := make([]string, len(projectRaw.Ways))
	for i, way := range projectRaw.Ways {
		wayIDs[i] = way.Uuid
	}

	userIDs := make([]string, len(projectRaw.Users))
	for i, user := range projectRaw.Users {
		userIDs[i] = user.Uuid
	}
	project := &ProjectResponse{
		ID:        projectRaw.Id,
		Name:      projectRaw.Name,
		OwnerID:   projectRaw.OwnerId,
		IsPrivate: projectRaw.IsPrivate,
		WayIDs:    wayIDs,
		UserIDs:   userIDs,
	}
	return project, nil
}

func (gs *GeneralService) DeleteProjectByID(ctx context.Context, projectID string) error {
	response, err := gs.generalAPI.ProjectAPI.DeleteProject(ctx, projectID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}
	return nil
}

func (gs *GeneralService) CreateToUserMentoringRequest(ctx context.Context, payload *schemas.CreateToUserMentoringRequestPayload) (*schemas.ToUserMentoringRequestResponse, error) {
	userMentorRaw, response, err := gs.generalAPI.ToUserMentoringRequestAPI.CreateUserMentoringRequest(ctx).Request(openapiGeneral.SchemasCreateToUserMentoringRequestPayload{
		UserUuid: payload.UserUuid,
		WayUuid:  payload.WayUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}
	userMentor := &schemas.ToUserMentoringRequestResponse{
		UserID: userMentorRaw.UserId,
		WayID:  userMentorRaw.WayId,
	}

	return userMentor, nil
}

func (gs *GeneralService) DeleteToUserMentoringRequestById(ctx context.Context, userID, wayID string) error {
	response, err := gs.generalAPI.ToUserMentoringRequestAPI.DeleteToUserMentoringRequest(ctx, userID, wayID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

type UpdateUserParams struct {
	UserID      string
	Name        *string
	Description *string
	ImageUrl    *string
	IsMentor    *bool
}

func (gs *GeneralService) UpdateUser(ctx context.Context, params *UpdateUserParams) (*schemas.UserPlainResponse, error) {
	userRaw, response, err := gs.generalAPI.UserAPI.UpdateUser(ctx, params.UserID).Request(openapiGeneral.SchemasUpdateUserPayload{
		Description: params.Description,
		ImageUrl:    params.ImageUrl,
		IsMentor:    params.IsMentor,
		Name:        params.Name,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	user := &schemas.UserPlainResponse{
		Uuid:        userRaw.Uuid,
		Name:        userRaw.Name,
		Email:       userRaw.Email,
		Description: userRaw.Description,
		CreatedAt:   userRaw.CreatedAt,
		ImageUrl:    userRaw.ImageUrl,
		IsMentor:    userRaw.IsMentor,
	}

	return user, nil
}

type GetAllUsersParams struct {
	MentorStatus string
	UserName     string
	UserEmail    string
	Offset       int
	ReqLimit     int
}

func (gs *GeneralService) GetAllUsers(ctx context.Context, params *GetAllUsersParams) (*schemas.GetAllUsersResponse, error) {
	usersRaw, response, err := gs.generalAPI.UserAPI.GetAllUsers(ctx).
		MentorStatus(params.MentorStatus).
		Name(params.UserName).
		Email(params.UserEmail).
		Page(int32(params.Offset)).
		Limit(int32(params.ReqLimit)).
		Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	users := make([]schemas.UserPlainResponseWithInfo, len(usersRaw.Users))
	for i, user := range usersRaw.Users {
		users[i] = schemas.UserPlainResponseWithInfo{
			Uuid:             user.Uuid,
			Name:             user.Name,
			Email:            user.Email,
			Description:      user.Description,
			CreatedAt:        user.CreatedAt,
			ImageUrl:         user.ImageUrl,
			IsMentor:         user.IsMentor,
			FavoriteForUsers: user.FavoriteForUsers,
			FavoriteWays:     user.FavoriteWays,
			MentoringWays:    user.MentoringWays,
			OwnWays:          user.OwnWays,
		}
	}

	return &schemas.GetAllUsersResponse{
		Size:  int64(len(users)),
		Users: users,
	}, nil
}

func (gs *GeneralService) GetUsersByIDs(ctx context.Context, userIDs []string) ([]schemas.GetUsersByIDsResponse, error) {
	userRaw, response, err := gs.generalAPI.UserAPI.GetUsersByIds(ctx).Request(userIDs).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	users := make([]schemas.GetUsersByIDsResponse, len(userRaw))
	for _, dsResponse := range userRaw {
		users = append(users, schemas.GetUsersByIDsResponse{
			UserID:   dsResponse.UserId,
			Name:     dsResponse.Name,
			ImageURL: dsResponse.ImageUrl,
		})
	}

	return users, nil
}

type CreateUserParams struct {
	Name        string
	Email       string
	Description string
	CreatedAt   time.Time
	ImageUrl    string
	IsMentor    bool
}

func (gs *GeneralService) FindOrCreateUserByEmail(ctx context.Context, params *CreateUserParams) (*schemas.UserPopulatedResponse, error) {

	return nil, nil
}

func (gs *GeneralService) CreateUser(ctx context.Context, params *CreateUserParams) (*schemas.UserPlainResponse, error) {
	return nil, nil
}

type dbWay struct {
	Uuid                uuid.UUID
	Name                string
	OwnerUuid           uuid.UUID
	GoalDescription     string
	UpdatedAt           time.Time
	CreatedAt           time.Time
	EstimationTime      int32
	CopiedFromWayUuid   uuid.UUID
	ProjectUuid         uuid.UUID
	IsCompleted         bool
	IsPrivate           bool
	WayMetricsTotal     int64
	WayMetricsDone      int64
	WayFavoriteForUsers int64
	WayDayReportsAmount int64
	ChildrenUuids       []string
}

func (gs *GeneralService) GetPopulatedUserById(ctx context.Context, userUuid uuid.UUID) (*schemas.UserPopulatedResponse, error) {
	userRaw, response, err := gs.generalAPI.UserAPI.GetUserByUuid(ctx, userUuid.String()).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	wayCollections := lo.Map(userRaw.CustomWayCollections, func(collection openapiGeneral.SchemasWayCollectionPopulatedResponse, _ int) schemas.WayCollectionPopulatedResponse {
		return schemas.WayCollectionPopulatedResponse{
			Uuid:      collection.Uuid,
			Name:      collection.Name,
			Ways:      lo.Map(collection.Ways, mapWayPlainResponse),
			CreatedAt: collection.CreatedAt,
			UpdatedAt: collection.UpdatedAt,
			OwnerUuid: collection.OwnerUuid,
			Type:      collection.Type,
		}
	})

	defaultCollections := schemas.DefaultWayCollections{
		Own:       mapWayCollection(userRaw.DefaultWayCollections.Own),
		Favorite:  mapWayCollection(userRaw.DefaultWayCollections.Favorite),
		Mentoring: mapWayCollection(userRaw.DefaultWayCollections.Mentoring),
	}

	favoriteUsers := lo.Map(userRaw.FavoriteUsers, mapUserPlainResponse)
	tags := lo.Map(userRaw.Tags, mapUserTagResponse)
	wayRequests := lo.Map(userRaw.WayRequests, mapWayPlainResponse)
	projects := lo.Map(userRaw.Projects, mapProjectPlainResponse)

	user := &schemas.UserPopulatedResponse{
		Uuid:               userRaw.Uuid,
		Name:               userRaw.Name,
		Email:              userRaw.Email,
		Description:        userRaw.Description,
		CreatedAt:          userRaw.CreatedAt,
		ImageUrl:           userRaw.ImageUrl,
		IsMentor:           userRaw.IsMentor,
		WayCollections:     wayCollections,
		DefaultCollections: defaultCollections,
		FavoriteForUsers:   userRaw.FavoriteForUsers,
		FavoriteUsers:      favoriteUsers,
		Tags:               tags,
		WayRequests:        wayRequests,
		Projects:           projects,
	}

	return user, nil
}

func mapWayCollection(collection openapiGeneral.SchemasWayCollectionPopulatedResponse) schemas.WayCollectionPopulatedResponse {
	return schemas.WayCollectionPopulatedResponse{
		Uuid:      collection.Uuid,
		Name:      collection.Name,
		Ways:      lo.Map(collection.Ways, mapWayPlainResponse),
		CreatedAt: collection.CreatedAt,
		UpdatedAt: collection.UpdatedAt,
		OwnerUuid: collection.OwnerUuid,
		Type:      collection.Type,
	}
}

func mapWayPlainResponse(way openapiGeneral.SchemasWayPlainResponse, _ int) schemas.WayPlainResponse {
	return schemas.WayPlainResponse{
		Uuid:              way.Uuid,
		Name:              way.Name,
		GoalDescription:   way.GoalDescription,
		UpdatedAt:         way.UpdatedAt,
		CreatedAt:         way.CreatedAt,
		EstimationTime:    way.EstimationTime,
		IsCompleted:       way.IsCompleted,
		Owner:             mapUserPlainResponse(way.Owner, 1),
		CopiedFromWayUuid: way.CopiedFromWayUuid.Get(),
		ProjectUuid:       way.ProjectUuid.Get(),
		IsPrivate:         way.IsPrivate,
		FavoriteForUsers:  way.FavoriteForUsers,
		DayReportsAmount:  way.DayReportsAmount,
		Mentors:           lo.Map(way.Mentors, mapUserPlainResponse),
		WayTags:           lo.Map(way.WayTags, mapWayTagResponse),
		MetricsDone:       way.MetricsDone,
		MetricsTotal:      way.MetricsTotal,
		ChildrenUuids:     way.ChildrenUuids,
	}
}

func mapUserPlainResponse(user openapiGeneral.SchemasUserPlainResponse, _ int) schemas.UserPlainResponse {
	return schemas.UserPlainResponse{
		Uuid:        user.Uuid,
		Name:        user.Name,
		Email:       user.Email,
		Description: user.Description,
		CreatedAt:   user.CreatedAt,
		ImageUrl:    user.ImageUrl,
		IsMentor:    user.IsMentor,
	}
}

func mapUserTagResponse(tag openapiGeneral.SchemasUserTagResponse, _ int) schemas.UserTagResponse {
	return schemas.UserTagResponse{
		Uuid: tag.Uuid,
		Name: tag.Name,
	}
}

func mapWayTagResponse(tag openapiGeneral.SchemasWayTagResponse, _ int) schemas.WayTagResponse {
	return schemas.WayTagResponse{
		Uuid: tag.Uuid,
		Name: tag.Name,
	}
}

func mapProjectPlainResponse(project openapiGeneral.SchemasProjectPlainResponse, _ int) schemas.ProjectPlainResponse {
	return schemas.ProjectPlainResponse{
		ID:        project.Id,
		Name:      project.Name,
		UserIDs:   project.UserIds,
		IsPrivate: project.IsPrivate,
	}
}

//
//func (us *GeneralService) convertDbWaysToPlainWays(ctx context.Context, dbWays []dbWay) []schemas.WayPlainResponse {
//	return nil
//}
//
////
//func (us *GeneralService) dbCollectionWaysToDbWays(rawWay []db.GetWaysByCollectionIdRow) []dbWay {
//	return nil
//}
//
//func (us *GeneralService) dbMentoringWaysToDbWays(rawWay []db.GetMentoringWaysByMentorIdRow) []dbWay {
//	return nil
//}
//
//func (us *GeneralService) dbFavoriteWaysToDbWays(rawWay []db.GetFavoriteWaysByUserIdRow) []dbWay {
//	return nil
//}

func (gs *GeneralService) GetPlainUserWithInfoByIDs(ctx context.Context, projectID string) ([]schemas.UserPlainResponseWithInfo, error) {
	usersRaw, response, err := gs.generalAPI.ProjectAPI.GetProject(ctx, projectID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	users := make([]schemas.UserPlainResponseWithInfo, len(usersRaw.Users))

	for i, user := range usersRaw.Users {
		tags := make([]schemas.UserTagResponse, len(user.Tags))
		for j, tag := range user.Tags {
			tags[j] = schemas.UserTagResponse{
				Uuid: tag.Uuid,
				Name: tag.Name,
			}
		}

		users[i] = schemas.UserPlainResponseWithInfo{
			Uuid:             user.Uuid,
			Name:             user.Name,
			Email:            user.Email,
			Description:      user.Description,
			CreatedAt:        user.CreatedAt,
			ImageUrl:         user.ImageUrl,
			IsMentor:         user.IsMentor,
			FavoriteForUsers: user.FavoriteForUsers,
			FavoriteWays:     user.FavoriteWays,
			MentoringWays:    user.MentoringWays,
			OwnWays:          user.OwnWays,
			Tags:             tags,
		}
	}

	return users, nil
}

func (gs *GeneralService) CreateUserProject(ctx context.Context, userID, projectID string) error {
	response, err := gs.generalAPI.UserProjectAPI.CreateUserProject(ctx).Request(openapiGeneral.SchemasCreateUserProjectPayload{
		ProjectId: projectID,
		UserId:    userID,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) DeleteUserProject(ctx context.Context, userID, projectID string) error {
	response, err := gs.generalAPI.UserProjectAPI.DeleteUserProject(ctx, projectID, userID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}
	return nil
}

func (gs *GeneralService) AddUserTagByName(ctx context.Context, payload *schemas.CreateUserTagPayload) (*schemas.UserTagResponse, error) {
	userTagRaw, response, err := gs.generalAPI.UserTagAPI.CreateUserTag(ctx).Request(openapiGeneral.SchemasCreateUserTagPayload{
		Name:      payload.Name,
		OwnerUuid: payload.OwnerUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	userTag := &schemas.UserTagResponse{
		Uuid: userTagRaw.Uuid,
		Name: userTagRaw.Name,
	}
	return userTag, nil
}

func (gs *GeneralService) DeleteUserTagByFromUserByTag(ctx context.Context, userID, userTagID string) error {
	response, err := gs.generalAPI.UserTagAPI.DeleteUserTag(ctx, userTagID, userID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}
	return nil
}

type GetPopulatedWayByIdParams struct {
	WayUuid              uuid.UUID
	CurrentChildrenDepth int32
}

//func (ws *GeneralService) GetPopulatedWayById(ctx context.Context, params GetPopulatedWayByIdParams) (*schemas.WayPopulatedResponse, error) {
//}

func (gs *GeneralService) UpdateWayIsCompletedStatus(ctx context.Context, wayID string) error {
	IsCompleted := true
	_, response, err := gs.generalAPI.WayAPI.UpdateWay(ctx, wayID).Request(openapiGeneral.SchemasUpdateWayPayload{
		IsCompleted: &IsCompleted,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) GetPlainWayById(ctx context.Context, wayUUID uuid.UUID) (*schemas.WayPlainResponse, error) {
	wayRaw, response, err := gs.generalAPI.WayAPI.GetWayByUuid(ctx, wayUUID.String()).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	owner := mapOwner(wayRaw.Owner)
	mentors := mapMentors(wayRaw.Mentors)
	wayTags := mapWayTags(wayRaw.WayTags)

	var metricsDone int32 = 0
	var metricsTotal int32 = 0

	for _, metric := range wayRaw.Metrics {
		if metric.IsDone {
			metricsDone++
		}
		metricsTotal += metric.EstimationTime
	}

	childrenUuids := make([]string, len(wayRaw.Children))
	for i, child := range wayRaw.Children {
		childrenUuids[i] = child.Uuid
	}

	way := &schemas.WayPlainResponse{
		Uuid:              wayRaw.Uuid,
		Name:              wayRaw.Name,
		GoalDescription:   wayRaw.GoalDescription,
		UpdatedAt:         wayRaw.UpdatedAt,
		CreatedAt:         wayRaw.CreatedAt,
		EstimationTime:    wayRaw.EstimationTime,
		IsCompleted:       wayRaw.IsCompleted,
		Owner:             owner,
		CopiedFromWayUuid: wayRaw.CopiedFromWayUuid.Get(),
		ProjectUuid:       wayRaw.ProjectUuid.Get(),
		IsPrivate:         wayRaw.IsPrivate,
		FavoriteForUsers:  wayRaw.FavoriteForUsersAmount,
		Mentors:           mentors,
		WayTags:           wayTags,
		MetricsDone:       metricsDone,
		MetricsTotal:      metricsTotal,
		ChildrenUuids:     childrenUuids,
	}

	return way, nil
}

func (gs *GeneralService) CreateWay(ctx context.Context, payload *schemas.CreateWayPayload) (*schemas.WayPlainResponse, error) {
	var CopiedFromWayID, ProjectID openapiGeneral.NullableString

	CopiedFromWayID.Set(payload.CopiedFromWayID)
	ProjectID.Set(payload.ProjectID)

	wayRaw, response, err := gs.generalAPI.WayAPI.CreateWay(ctx).Request(openapiGeneral.SchemasCreateWayPayload{
		CopiedFromWayId: CopiedFromWayID,
		EstimationTime:  payload.EstimationTime,
		GoalDescription: payload.GoalDescription,
		IsCompleted:     payload.IsCompleted,
		IsPrivate:       payload.IsPrivate,
		Name:            payload.Name,
		OwnerId:         payload.OwnerID,
		ProjectId:       ProjectID,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	owner := mapOwner(wayRaw.Owner)
	mentors := mapMentors(wayRaw.Mentors)
	wayTags := mapWayTags(wayRaw.WayTags)

	way := &schemas.WayPlainResponse{
		Uuid:              wayRaw.Uuid,
		Name:              wayRaw.Name,
		GoalDescription:   wayRaw.GoalDescription,
		UpdatedAt:         wayRaw.UpdatedAt,
		CreatedAt:         wayRaw.CreatedAt,
		EstimationTime:    wayRaw.EstimationTime,
		IsCompleted:       wayRaw.IsCompleted,
		Owner:             owner,
		CopiedFromWayUuid: wayRaw.CopiedFromWayUuid.Get(),
		ProjectUuid:       wayRaw.ProjectUuid.Get(),
		IsPrivate:         wayRaw.IsPrivate,
		FavoriteForUsers:  wayRaw.FavoriteForUsers,
		DayReportsAmount:  wayRaw.DayReportsAmount,
		Mentors:           mentors,
		WayTags:           wayTags,
		MetricsDone:       wayRaw.MetricsDone,
		MetricsTotal:      wayRaw.MetricsTotal,
		ChildrenUuids:     wayRaw.ChildrenUuids,
	}

	return way, nil
}

func mapOwner(ownerRaw openapiGeneral.SchemasUserPlainResponse) schemas.UserPlainResponse {
	return schemas.UserPlainResponse{
		Uuid:        ownerRaw.Uuid,
		Name:        ownerRaw.Name,
		Email:       ownerRaw.Email,
		Description: ownerRaw.Description,
		CreatedAt:   ownerRaw.CreatedAt,
		ImageUrl:    ownerRaw.ImageUrl,
		IsMentor:    ownerRaw.IsMentor,
	}
}

func mapMentors(mentorsRaw []openapiGeneral.SchemasUserPlainResponse) []schemas.UserPlainResponse {
	mentors := make([]schemas.UserPlainResponse, len(mentorsRaw))
	for i, mentor := range mentorsRaw {
		mentors[i] = schemas.UserPlainResponse{
			Uuid:        mentor.Uuid,
			Name:        mentor.Name,
			Email:       mentor.Email,
			Description: mentor.Description,
			CreatedAt:   mentor.CreatedAt,
			ImageUrl:    mentor.ImageUrl,
			IsMentor:    mentor.IsMentor,
		}
	}
	return mentors
}

func mapWayTags(tagsRaw []openapiGeneral.SchemasWayTagResponse) []schemas.WayTagResponse {
	wayTags := make([]schemas.WayTagResponse, len(tagsRaw))
	for i, tag := range tagsRaw {
		wayTags[i] = schemas.WayTagResponse{
			Uuid: tag.Uuid,
			Name: tag.Name,
		}
	}
	return wayTags
}

type UpdateWayParams struct {
	WayID           string
	Name            string
	GoalDescription string
	EstimationTime  int32
	IsPrivate       bool
	IsCompleted     bool
}

func (gs *GeneralService) UpdateWay(ctx context.Context, params *UpdateWayParams) (*schemas.WayPlainResponse, error) {
	wayRaw, response, err := gs.generalAPI.WayAPI.UpdateWay(ctx, params.WayID).Request(openapiGeneral.SchemasUpdateWayPayload{
		EstimationTime:  &params.EstimationTime,
		GoalDescription: &params.GoalDescription,
		IsCompleted:     &params.IsCompleted,
		IsPrivate:       &params.IsPrivate,
		Name:            &params.Name,
	}).Execute()
	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}
	owner := mapOwner(wayRaw.Owner)
	mentors := mapMentors(wayRaw.Mentors)
	wayTags := mapWayTags(wayRaw.WayTags)

	way := &schemas.WayPlainResponse{
		Uuid:              wayRaw.Uuid,
		Name:              wayRaw.Name,
		GoalDescription:   wayRaw.GoalDescription,
		UpdatedAt:         wayRaw.UpdatedAt,
		CreatedAt:         wayRaw.CreatedAt,
		EstimationTime:    wayRaw.EstimationTime,
		IsCompleted:       wayRaw.IsCompleted,
		Owner:             owner,
		CopiedFromWayUuid: wayRaw.CopiedFromWayUuid.Get(),
		ProjectUuid:       wayRaw.ProjectUuid.Get(),
		IsPrivate:         wayRaw.IsPrivate,
		FavoriteForUsers:  wayRaw.FavoriteForUsers,
		DayReportsAmount:  wayRaw.DayReportsAmount,
		Mentors:           mentors,
		WayTags:           wayTags,
		MetricsDone:       wayRaw.MetricsDone,
		MetricsTotal:      wayRaw.MetricsTotal,
		ChildrenUuids:     wayRaw.ChildrenUuids,
	}

	return way, nil
}

type GetAllWaysParams struct {
	Status                 string
	WayName                string
	Offset                 int
	ReqMinDayReportsAmount int
	ReqLimit               int
}

func (gs *GeneralService) GetAllWays(ctx context.Context, params *GetAllWaysParams) (*schemas.GetAllWaysResponse, error) {
	waysRaw, response, err := gs.generalAPI.WayAPI.GetAllWays(ctx).
		WayName(params.WayName).
		MinDayReportsAmount(int32(params.ReqMinDayReportsAmount)).
		Status(params.Status).
		Page(int32(params.Offset)).
		Limit(int32(params.ReqLimit)).
		Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}
	ways := make([]schemas.WayPlainResponse, len(waysRaw.Ways))
	for i, way := range waysRaw.Ways {
		ways[i] = mapWayPlainRes(way)
	}
	res := &schemas.GetAllWaysResponse{
		Size: waysRaw.Size,
		Ways: ways,
	}
	return res, nil
}
func mapWayPlainRes(wayRaw openapiGeneral.SchemasWayPlainResponse) schemas.WayPlainResponse {
	return schemas.WayPlainResponse{
		Uuid:              wayRaw.Uuid,
		Name:              wayRaw.Name,
		GoalDescription:   wayRaw.GoalDescription,
		UpdatedAt:         wayRaw.UpdatedAt,
		CreatedAt:         wayRaw.CreatedAt,
		EstimationTime:    wayRaw.EstimationTime,
		IsCompleted:       wayRaw.IsCompleted,
		Owner:             mapOwner(wayRaw.Owner),
		CopiedFromWayUuid: wayRaw.CopiedFromWayUuid.Get(),
		ProjectUuid:       wayRaw.ProjectUuid.Get(),
		IsPrivate:         wayRaw.IsPrivate,
		FavoriteForUsers:  wayRaw.FavoriteForUsers,
		DayReportsAmount:  wayRaw.DayReportsAmount,
		Mentors:           mapMentors(wayRaw.Mentors),
		WayTags:           mapWayTags(wayRaw.WayTags),
		MetricsDone:       wayRaw.MetricsDone,
		MetricsTotal:      wayRaw.MetricsTotal,
		ChildrenUuids:     wayRaw.ChildrenUuids,
	}
}
func (gs *GeneralService) DeleteWayById(ctx *gin.Context, wayID string) error {
	response, err := gs.generalAPI.WayAPI.DeleteWay(ctx, wayID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

func (gs *GeneralService) GetChildrenWayIDs(ctx context.Context, wayID uuid.UUID, maxDepth int) ([]uuid.UUID, error) {
	var collectChildren func(ctx context.Context, wayID uuid.UUID, currentDepth int) ([]uuid.UUID, error)
	collectChildren = func(ctx context.Context, wayID uuid.UUID, currentDepth int) ([]uuid.UUID, error) {
		if currentDepth >= maxDepth {
			return nil, nil
		}

		wayRaw, response, err := gs.generalAPI.WayAPI.GetWayByUuid(ctx, wayID.String()).Execute()
		if err != nil {
			message, extractErr := utils.ExtractErrorMessageFromResponse(response)
			if extractErr != nil {
				return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
			}
			return nil, fmt.Errorf(message)
		}

		children := make([]uuid.UUID, len(wayRaw.Children))
		for i, child := range wayRaw.Children {
			childUUID, parseErr := uuid.Parse(child.GetUuid())
			if parseErr != nil {
				return nil, fmt.Errorf("failed to parse child UUID: %w", parseErr)
			}
			children[i] = childUUID
		}

		for _, childID := range children {
			subChildren, err := collectChildren(ctx, childID, currentDepth+1)
			if err != nil {
				return nil, err
			}
			children = append(children, subChildren...)
		}

		return children, nil
	}

	return collectChildren(ctx, wayID, 0)
}

func (ws *GeneralService) GetNestedWayIDs(ctx context.Context, parentWayUUID uuid.UUID, currentDepth int, maxDepth int) ([]pgtype.UUID, error) {
	return nil, nil
}

func (gs *GeneralService) CreateWayCollection(ctx context.Context, payload *schemas.CreateWayCollectionPayload) (*schemas.WayCollectionPopulatedResponse, error) {
	wayCollectionRaw, response, err := gs.generalAPI.WayCollectionAPI.CreateWayCollection(ctx).Request(openapiGeneral.SchemasCreateWayCollectionPayload{
		Name:      payload.Name,
		OwnerUuid: payload.OwnerUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	ways := lo.Map(wayCollectionRaw.Ways, func(way openapiGeneral.SchemasWayPlainResponse, _ int) schemas.WayPlainResponse {
		wayTags := lo.Map(way.WayTags, func(tag openapiGeneral.SchemasWayTagResponse, _ int) schemas.WayTagResponse {
			return schemas.WayTagResponse{
				Uuid: tag.Uuid,
				Name: tag.Name,
			}
		})

		mentors := lo.Map(way.Mentors, func(mentor openapiGeneral.SchemasUserPlainResponse, _ int) schemas.UserPlainResponse {
			return schemas.UserPlainResponse{
				Uuid:        mentor.Uuid,
				Name:        mentor.Name,
				Email:       mentor.Email,
				Description: mentor.Description,
				CreatedAt:   mentor.CreatedAt,
				ImageUrl:    mentor.ImageUrl,
				IsMentor:    mentor.IsMentor,
			}
		})

		owner := schemas.UserPlainResponse{
			Uuid:        way.Owner.Uuid,
			Name:        way.Owner.Name,
			Email:       way.Owner.Email,
			Description: way.Owner.Description,
			CreatedAt:   way.Owner.CreatedAt,
			ImageUrl:    way.Owner.ImageUrl,
			IsMentor:    way.Owner.IsMentor,
		}

		return schemas.WayPlainResponse{
			Uuid:              way.Uuid,
			Name:              way.Name,
			GoalDescription:   way.GoalDescription,
			UpdatedAt:         way.UpdatedAt,
			CreatedAt:         way.CreatedAt,
			EstimationTime:    way.EstimationTime,
			IsCompleted:       way.IsCompleted,
			Owner:             owner,
			CopiedFromWayUuid: way.CopiedFromWayUuid.Get(),
			ProjectUuid:       way.ProjectUuid.Get(),
			IsPrivate:         way.IsPrivate,
			FavoriteForUsers:  way.FavoriteForUsers,
			DayReportsAmount:  way.DayReportsAmount,
			Mentors:           mentors,
			WayTags:           wayTags,
			MetricsTotal:      way.MetricsTotal,
			MetricsDone:       way.MetricsDone,
			ChildrenUuids:     way.ChildrenUuids,
		}
	})

	wayCollection := &schemas.WayCollectionPopulatedResponse{
		Uuid:      wayCollectionRaw.Uuid,
		Name:      wayCollectionRaw.Name,
		Ways:      ways,
		CreatedAt: wayCollectionRaw.CreatedAt,
		UpdatedAt: wayCollectionRaw.UpdatedAt,
		OwnerUuid: wayCollectionRaw.OwnerUuid,
		Type:      wayCollectionRaw.Type,
	}
	return wayCollection, nil
}

func (gs *GeneralService) UpdateWayCollection(ctx context.Context, wayCollectionID, wayCollectionName string) (*schemas.WayCollectionPlainResponse, error) {
	wayCollectionRaw, response, err := gs.generalAPI.WayCollectionAPI.UpdateWayCollection(ctx, wayCollectionID).Request(openapiGeneral.SchemasUpdateWayCollectionPayload{
		Name: &wayCollectionName,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	wayCollection := &schemas.WayCollectionPlainResponse{
		Uuid: wayCollectionRaw.Uuid,
		Name: wayCollectionRaw.Name,
	}
	return wayCollection, nil
}

func (gs *GeneralService) DeleteWayCollectionById(ctx context.Context, wayCollectionID string) error {
	response, err := gs.generalAPI.WayCollectionAPI.DeleteWayCollection(ctx, wayCollectionID).Execute()
	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}
	return nil
}

func (gs *GeneralService) CreateWayCollectionWay(ctx context.Context, payload *schemas.CreateWayCollectionWay) (*schemas.WayCollectionWayResponse, error) {
	wayCollectionRaw, response, err := gs.generalAPI.WayCollectionWayAPI.CreateWayCollectionWay(ctx).Request(openapiGeneral.SchemasCreateWayCollectionWay{
		WayUuid:           payload.WayCollectionUuid,
		WayCollectionUuid: payload.WayCollectionUuid,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}

	wayCollectionWay := &schemas.WayCollectionWayResponse{
		WayID:           wayCollectionRaw.WayCollectionId,
		WayCollectionID: wayCollectionRaw.WayCollectionId,
	}

	return wayCollectionWay, nil
}

func (gs *GeneralService) DeleteWayCollectionWayById(ctx context.Context, wayID, wayCollectionID string) error {
	response, err := gs.generalAPI.WayCollectionWayAPI.DeleteWayCollectionWay(ctx, wayCollectionID, wayID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}

type GetWayStatisticsTriplePeriodParams struct {
	WayUUIDs       []uuid.UUID
	TotalStartDate time.Time
	EndDate        time.Time
}

func (gs *GeneralService) GetWayStatisticsTriplePeriod(ctx context.Context, params *GetWayStatisticsTriplePeriodParams) (*schemas.WayStatisticsTriplePeriod, error) {
	//wayStatisticsRaw, response, err := gs.generalAPI.WayAPI.GetWayStatisticsByUuid(ctx, params.WayUUIDs).Execute()
	//
	//
	//wayStatistics := &schemas.WayStatistics{
	//	TimeSpentByDayChart:,
	//	OverallInformation: ,
	//	LabelStatistics:
	//}
	return nil, nil
}

type GetWayStatisticsParams struct {
	WayPgUUIDs           []uuid.UUID
	StartDatePgTimestamp pgtype.Timestamp
	EndDatePgTimestamp   pgtype.Timestamp
}

func (gs *GeneralService) GetWayStatistics(ctx context.Context, params *GetWayStatisticsParams) (*schemas.WayStatistics, error) {
	//wayStatisticsRaw, response, err := gs.generalAPI.WayAPI.GetWayStatisticsByUuid(ctx, params.WayPgUUIDs).Execute()
	return nil, nil
}

func (ws *GeneralService) GetTimeSpentByDayChart(ctx context.Context, params *GetWayStatisticsParams) ([]schemas.TimeSpentByDayPoint, error) {
	return nil, nil
}

func (ws *GeneralService) GetOverallInformation(ctx context.Context, params *GetWayStatisticsParams) (*schemas.OverallInformation, error) {
	return nil, nil
}

func (ws *GeneralService) GetLabelStatistics(ctx context.Context, params *GetWayStatisticsParams) (*schemas.LabelStatistics, error) {
	return nil, nil
}

func (gs *GeneralService) AddWayTagToWay(ctx context.Context, name string, wayID string) (*schemas.WayTagResponse, error) {
	wayTagRaw, response, err := gs.generalAPI.WayTagAPI.CreateWayTag(ctx).Request(openapiGeneral.SchemasCreateWayTagPayload{
		WayUuid: wayID,
		Name:    name,
	}).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return nil, fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return nil, fmt.Errorf(message)
	}
	wayTag := &schemas.WayTagResponse{
		Uuid: wayTagRaw.Uuid,
		Name: wayTagRaw.Name,
	}
	return wayTag, nil
}

func (gs *GeneralService) DeleteWayTagFromWayByTagID(ctx context.Context, wayTagID string, wayID string) error {
	response, err := gs.generalAPI.WayTagAPI.DeleteWayTag(ctx, wayTagID, wayID).Execute()

	if err != nil {
		message, extractErr := utils.ExtractErrorMessageFromResponse(response)
		if extractErr != nil {
			return fmt.Errorf("failed to extract error message: %w", extractErr)
		}
		return fmt.Errorf(message)
	}

	return nil
}
