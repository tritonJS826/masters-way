package facades

import (
	"context"
	"fmt"
	openapiGeneral "mw-general-bff/apiAutogenerated/general"
	"mw-general-bff/internal/auth"
	"mw-general-bff/internal/config"
	"mw-general-bff/internal/services"
	"mw-general-bff/pkg/utils"
	"time"
)

type AuthFacade struct {
	authService         *services.AuthService
	notificationService *services.NotificationService
	chatService         *services.ChatService
	config              *config.Config
}

func newAuthFacade(authService *services.AuthService, notificationService *services.NotificationService, chatService *services.ChatService, config *config.Config) *AuthFacade {
	return &AuthFacade{authService, notificationService, chatService, config}
}

func (af *AuthFacade) GetAuthCallbackFunction(ctx context.Context, provider, code, state string) (*openapiGeneral.MwServerInternalSchemasGetAuthCallbackFunctionResponse, error) {
	authCallbackFunctionResponse, err := af.authService.GetAuthCallbackFunction(ctx, provider, code, state)
	if err != nil {
		return nil, err
	}

	if !authCallbackFunctionResponse.IsAlreadyCreated {
		token, err := utils.GetTokenParamFromURL(authCallbackFunctionResponse.Url)
		if err != nil {
			return nil, err
		}
		claims, err := auth.ValidateJWT(token, af.config.SecretSessionKey)
		if err != nil {
			return nil, err
		}
		err = af.notificationService.CreateNotificationSettings(ctx, claims.UserID)
		if err != nil {
			return nil, err
		}

		greetingDeferredTime := 15 * time.Second
		go func() {
			time.Sleep(greetingDeferredTime)
			roomId, err := af.chatService.CreateRoom(ctx, &services.CreateRoomParams{
				Name:     nil,
				RoomType: "private",
				UserId:   &services.GreetingChatUserId,
			})
			if err != nil {
				fmt.Println("Failed to create greeting chat room !! This issue should not block use authorization flow")
				return
			}

			err = af.chatService.CreateGreetingMessage(ctx, &services.CreateMessageParams{
				RoomId: roomId,
			})
			if err != nil {
				fmt.Println("Failed to create greeting message !! This issue should not block use authorization flow")
			}
		}()
	}

	return authCallbackFunctionResponse, nil
}

func (af *AuthFacade) GetUserTokenByEmail(ctx context.Context, email string) (*openapiGeneral.MwServerInternalSchemasGetAuthCallbackFunctionResponse, error) {
	authCallbackFunctionResponse, err := af.authService.GetUserTokenByEmail(ctx, email)
	if err != nil {
		return nil, err
	}

	if !authCallbackFunctionResponse.IsAlreadyCreated {
		token, err := utils.GetTokenParamFromURL(authCallbackFunctionResponse.Url)
		if err != nil {
			return nil, err
		}
		claims, err := auth.ValidateJWT(token, af.config.SecretSessionKey)
		if err != nil {
			return nil, err
		}
		err = af.notificationService.CreateNotificationSettings(ctx, claims.UserID)
		if err != nil {
			return nil, err
		}
	}

	return authCallbackFunctionResponse, nil
}

func (af *AuthFacade) GetGoogleAuthURL(ctx context.Context, provider string) (*openapiGeneral.MwServerInternalSchemasBeginAuthResponse, error) {
	return af.authService.GetGoogleAuthURL(ctx, provider)
}

func (af *AuthFacade) GetGoogleAccessTokenByUserID(ctx context.Context) (*openapiGeneral.MwServerInternalSchemasGoogleToken, error) {
	return af.authService.GetGoogleAccessTokenByUserID(ctx)
}

func (af *AuthFacade) GetCurrentAuthorizedUserByToken(ctx context.Context) (*openapiGeneral.MwServerInternalSchemasUserPopulatedResponse, error) {
	return af.authService.GetCurrentAuthorizedUserByToken(ctx)
}

func (af *AuthFacade) Logout(ctx context.Context, provider string) error {
	return af.authService.Logout(ctx, provider)
}

func (af *AuthFacade) RefreshAccessToken(ctx context.Context, refreshToken string) (*openapiGeneral.MwServerInternalSchemasRefreshAccessTokenResponse, error) {
	return af.authService.RefreshAccessToken(ctx, refreshToken)
}
