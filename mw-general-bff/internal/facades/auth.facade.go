package facades

import (
	"context"
	"fmt"
	openapiGeneral "mw-general-bff/apiAutogenerated/general"
	"mw-general-bff/internal/auth"
	"mw-general-bff/internal/config"
	"mw-general-bff/internal/services"
	"mw-general-bff/pkg/utils"
	"time"

	"github.com/gin-gonic/gin"
)

type AuthFacade struct {
	authService          *services.AuthService
	generalService       *services.GeneralService
	notificationService  *services.NotificationService
	chatService          *services.ChatService
	chatWebSocketService *services.ChatWebSocketService
	mailService          *services.MailService
	config               *config.Config
}

func newAuthFacade(
	authService *services.AuthService,
	generalService *services.GeneralService,
	notificationService *services.NotificationService,
	chatService *services.ChatService,
	chatWebSocketService *services.ChatWebSocketService,
	mailService *services.MailService,
	config *config.Config,
) *AuthFacade {
	return &AuthFacade{
		authService,
		generalService,
		notificationService,
		chatService,
		chatWebSocketService,
		mailService,
		config,
	}
}

func (af *AuthFacade) GetAuthCallbackFunction(ctx *gin.Context, provider, code, state string) (*openapiGeneral.MwServerInternalSchemasGetAuthCallbackFunctionResponse, error) {
	authCallbackFunctionResponse, err := af.authService.GetAuthCallbackFunction(ctx, provider, code, state)
	if err != nil {
		return nil, err
	}

	if !authCallbackFunctionResponse.IsAlreadyCreated {
		token, err := utils.GetTokenParamFromURL(authCallbackFunctionResponse.Url)
		fmt.Println("token", token)
		if err != nil {
			return nil, err
		}
		claims, err := auth.ValidateJWT(token, af.config.SecretSessionKey)
		if err != nil {
			return nil, err
		}
		err = af.notificationService.CreateNotificationSettings(ctx, claims.UserID)
		if err != nil {
			return nil, err
		}

		// For creating greeting chat room and message we need to set auth headers
		ctx.Set(auth.ContextKeyUserID, claims.UserID)
		ctx.Set(auth.ContextKeyAuthorization, "Bearer "+token)
		ctx.Request.Header.Set(auth.HeaderKeyAuthorization, "Bearer "+token)
		greetingDeferredTime := 15 * time.Second

		// Copy the necessary context values and headers for use in the goroutine
		userID := claims.UserID
		authHeader := "Bearer " + token

		// Create a shallow copy of the request with the correct header
		req := ctx.Request.Clone(ctx.Request.Context())
		req.Header.Set(auth.HeaderKeyAuthorization, authHeader)

		// Create a new gin.Context with the copied request and set values
		newCtx := &gin.Context{
			Request: req,
		}
		newCtx.Set(auth.ContextKeyUserID, userID)
		newCtx.Set(auth.ContextKeyAuthorization, authHeader)

		// Email greeting message
		{
			fmt.Println("Sending greeting email!!!!!!!!!!!!!!")
			user, err := af.generalService.GetUserByIds(newCtx, []string{claims.UserID})
			if err != nil {
				fmt.Println("Failed to get created User " + err.Error())
			}

			args := &services.SendMailParams{
				Subject: "Master's way: Nice to see you!",
				To:      []string{user[0].Email},
				Cc:      make([]string, 0),
				Bcc:     services.GreetingChatBcc,
				ReplyTo: make([]string, 0),
				Message: services.GreetingChatMessage,
			}
			af.mailService.SendMail(newCtx, args)
		}

		// In-app notification (in the chat primarily) for greeting message
		go func() {
			time.Sleep(greetingDeferredTime)

			roomId, err := af.chatService.CreateRoom(newCtx, &services.CreateRoomParams{
				Name:     nil,
				RoomType: "private",
				UserId:   &services.GreetingChatUserId,
			})
			if err != nil {
				fmt.Println("Failed to create greeting chat room !! This issue should not block use authorization flow")
				return
			}

			response, err := af.chatService.CreateGreetingMessage(newCtx, &services.CreateMessageParams{
				RoomId:         roomId,
				ReceiverUserId: claims.UserID,
			})
			if err != nil {
				fmt.Println("Failed to create greeting message !! This issue should not block use authorization flow")
				return
			}

			// messageResponse.Message.OwnerName = userMap[messageResponse.Message.OwnerID].Name
			// messageResponse.Message.OwnerImageURL = userMap[messageResponse.Message.OwnerID].ImageURL

			err = af.chatWebSocketService.SendMessage(newCtx, roomId, response)
			utils.HandleErrorGin(ctx, err)

		}()
	}

	return authCallbackFunctionResponse, nil
}

func (af *AuthFacade) GetUserTokenByEmail(ctx context.Context, email string) (*openapiGeneral.MwServerInternalSchemasGetAuthCallbackFunctionResponse, error) {
	authCallbackFunctionResponse, err := af.authService.GetUserTokenByEmail(ctx, email)
	if err != nil {
		return nil, err
	}

	if !authCallbackFunctionResponse.IsAlreadyCreated {
		token, err := utils.GetTokenParamFromURL(authCallbackFunctionResponse.Url)
		if err != nil {
			return nil, err
		}
		claims, err := auth.ValidateJWT(token, af.config.SecretSessionKey)
		if err != nil {
			return nil, err
		}
		err = af.notificationService.CreateNotificationSettings(ctx, claims.UserID)
		if err != nil {
			return nil, err
		}
	}

	return authCallbackFunctionResponse, nil
}

func (af *AuthFacade) GetGoogleAuthURL(ctx context.Context, provider string) (*openapiGeneral.MwServerInternalSchemasBeginAuthResponse, error) {
	return af.authService.GetGoogleAuthURL(ctx, provider)
}

func (af *AuthFacade) GetGoogleAccessTokenByUserID(ctx context.Context) (*openapiGeneral.MwServerInternalSchemasGoogleToken, error) {
	return af.authService.GetGoogleAccessTokenByUserID(ctx)
}

func (af *AuthFacade) GetCurrentAuthorizedUserByToken(ctx context.Context) (*openapiGeneral.MwServerInternalSchemasUserPopulatedResponse, error) {
	return af.authService.GetCurrentAuthorizedUserByToken(ctx)
}

func (af *AuthFacade) Logout(ctx context.Context, provider string) error {
	return af.authService.Logout(ctx, provider)
}

func (af *AuthFacade) RefreshAccessToken(ctx context.Context, refreshToken string) (*openapiGeneral.MwServerInternalSchemasRefreshAccessTokenResponse, error) {
	return af.authService.RefreshAccessToken(ctx, refreshToken)
}
