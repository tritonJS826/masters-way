package facades

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"math/rand"
	openapiGeneral "mw-general-bff/apiAutogenerated/general"
	"mw-general-bff/internal/auth"
	"mw-general-bff/internal/config"
	"mw-general-bff/internal/services"
	"mw-general-bff/pkg/utils"
	"net/http"
	"strings"
	"time"

	"github.com/gin-gonic/gin"
)

type AuthFacade struct {
	authService          *services.AuthService
	generalService       *services.GeneralService
	notificationService  *services.NotificationService
	chatService          *services.ChatService
	chatWebSocketService *services.ChatWebSocketService
	mailService          *services.MailService
	config               *config.Config
}

func newAuthFacade(
	authService *services.AuthService,
	generalService *services.GeneralService,
	notificationService *services.NotificationService,
	chatService *services.ChatService,
	chatWebSocketService *services.ChatWebSocketService,
	mailService *services.MailService,
	config *config.Config,
) *AuthFacade {
	return &AuthFacade{
		authService,
		generalService,
		notificationService,
		chatService,
		chatWebSocketService,
		mailService,
		config,
	}
}

func (af *AuthFacade) GetAuthCallbackFunction(ctx *gin.Context, provider, code, state string) (*openapiGeneral.MwServerInternalSchemasGetAuthCallbackFunctionResponse, error) {
	authCallbackFunctionResponse, err := af.authService.GetAuthCallbackFunction(ctx, provider, code, state)
	if err != nil {
		return nil, err
	}

	if !authCallbackFunctionResponse.IsAlreadyCreated {
		token, err := utils.GetTokenParamFromURL(authCallbackFunctionResponse.Url)
		if err != nil {
			return nil, err
		}
		claims, err := auth.ValidateJWT(token, af.config.SecretSessionKey)
		if err != nil {
			return nil, err
		}
		err = af.notificationService.CreateNotificationSettings(ctx, claims.UserID)
		if err != nil {
			return nil, err
		}

		ctx.Set(auth.ContextKeyUserID, claims.UserID)
		ctx.Set(auth.ContextKeyAuthorization, "Bearer "+token)
		ctx.Request.Header.Set(auth.HeaderKeyAuthorization, "Bearer "+token)
		greetingDeferredTime := 15 * time.Second

		userID := claims.UserID
		authHeader := "Bearer " + token

		req := ctx.Request.Clone(ctx.Request.Context())
		req.Header.Set(auth.HeaderKeyAuthorization, authHeader)

		newCtx := &gin.Context{
			Request: req,
		}
		newCtx.Set(auth.ContextKeyUserID, userID)
		newCtx.Set(auth.ContextKeyAuthorization, authHeader)

		{
			fmt.Println("Sending greeting email!!!!!!!!!!!!!!")
			user, err := af.generalService.GetUserByIds(newCtx, []string{claims.UserID})
			if err != nil {
				fmt.Println("Failed to get created User " + err.Error())
			}

			args := &services.SendMailParams{
				Subject: "Master's way: Nice to see you!",
				To:      []string{user[0].Email},
				Cc:      make([]string, 0),
				Bcc:     services.GreetingChatBcc,
				ReplyTo: make([]string, 0),
				Message: services.GreetingChatMessage,
			}
			af.mailService.SendMail(newCtx, args)
		}

		go func() {
			time.Sleep(greetingDeferredTime)

			roomId, err := af.chatService.CreateRoom(newCtx, &services.CreateRoomParams{
				Name:     nil,
				RoomType: "private",
				UserId:   &services.GreetingChatUserId,
			})
			if err != nil {
				fmt.Println("Failed to create greeting chat room !! This issue should not block use authorization flow")
				return
			}

			response, err := af.chatService.CreateGreetingMessage(newCtx, &services.CreateMessageParams{
				RoomId:         roomId,
				ReceiverUserId: claims.UserID,
			})
			if err != nil {
				fmt.Println("Failed to create greeting message !! This issue should not block use authorization flow")
				return
			}

			err = af.chatWebSocketService.SendMessage(newCtx, roomId, response)
			utils.HandleErrorGin(ctx, err)

		}()
	}

	return authCallbackFunctionResponse, nil
}

func (af *AuthFacade) GetUserTokenByEmail(ctx context.Context, email string) (*openapiGeneral.MwServerInternalSchemasGetAuthCallbackFunctionResponse, error) {
	authCallbackFunctionResponse, err := af.authService.GetUserTokenByEmail(ctx, email)
	if err != nil {
		return nil, err
	}

	if !authCallbackFunctionResponse.IsAlreadyCreated {
		token, err := utils.GetTokenParamFromURL(authCallbackFunctionResponse.Url)
		if err != nil {
			return nil, err
		}
		claims, err := auth.ValidateJWT(token, af.config.SecretSessionKey)
		if err != nil {
			return nil, err
		}
		err = af.notificationService.CreateNotificationSettings(ctx, claims.UserID)
		if err != nil {
			return nil, err
		}
	}

	return authCallbackFunctionResponse, nil
}

func (af *AuthFacade) GetGoogleAuthURL(ctx context.Context, provider string) (*openapiGeneral.MwServerInternalSchemasBeginAuthResponse, error) {
	return af.authService.GetGoogleAuthURL(ctx, provider)
}

func (af *AuthFacade) GetGoogleAccessTokenByUserID(ctx context.Context) (*openapiGeneral.MwServerInternalSchemasGoogleToken, error) {
	return af.authService.GetGoogleAccessTokenByUserID(ctx)
}

func (af *AuthFacade) GetCurrentAuthorizedUserByToken(ctx context.Context) (*openapiGeneral.MwServerInternalSchemasCurrentUserResponse, error) {
	return af.authService.GetCurrentAuthorizedUserByToken(ctx)
}

func (af *AuthFacade) Logout(ctx context.Context, provider string) error {
	return af.authService.Logout(ctx, provider)
}

func (af *AuthFacade) RefreshAccessToken(ctx context.Context, refreshToken string) (*openapiGeneral.MwServerInternalSchemasRefreshAccessTokenResponse, error) {
	return af.authService.RefreshAccessToken(ctx, refreshToken)
}

type TelegramLoginResult struct {
	AuthURL string
	Code    string
}

func randomString(length int) string {
	const letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	b := make([]byte, length)
	for i := range b {
		b[i] = letters[rand.Intn(len(letters))]
	}
	return string(b)
}

func (af *AuthFacade) InitiateTelegramLogin(ctx context.Context, tgId int64, tgName string) (*TelegramLoginResult, error) {
	ginCtx, ok := ctx.(*gin.Context)
	if !ok {
		return nil, fmt.Errorf("invalid context type")
	}

	authHeader := ginCtx.GetHeader("Authorization")
	if authHeader == "" {
		return nil, fmt.Errorf("authorization header required")
	}
	authHeader = strings.TrimPrefix(authHeader, "Bearer ")

	if authHeader != af.config.SecretSessionKey {
		return nil, fmt.Errorf("invalid authorization")
	}

	payload := map[string]interface{}{
		"telegramId":   tgId,
		"telegramName": tgName,
	}
	jsonData, _ := json.Marshal(payload)

	resp, err := http.Post("http://"+af.config.GeneralAPIHost+"/general/auth/telegram/initiate", "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to call mw-server: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("mw-server returned status %d", resp.StatusCode)
	}

	var result struct {
		AuthURL string `json:"authUrl"`
		Code    string `json:"code"`
	}
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	return &TelegramLoginResult{
		AuthURL: result.AuthURL,
		Code:    result.Code,
	}, nil
}

type TelegramValidateResult struct {
	UserUuid string
	Email    string
	Name     string
}

func (af *AuthFacade) ValidateTelegramLogin(ctx context.Context, code string, tgId int64, tgName string) (*TelegramValidateResult, error) {
	ginCtx, ok := ctx.(*gin.Context)
	if !ok {
		return nil, fmt.Errorf("invalid context type")
	}

	authHeader := ginCtx.GetHeader("Authorization")
	if authHeader == "" {
		return nil, fmt.Errorf("authorization header required")
	}
	authHeader = strings.TrimPrefix(authHeader, "Bearer ")

	if authHeader != af.config.SecretSessionKey {
		return nil, fmt.Errorf("invalid authorization")
	}

	payload := map[string]interface{}{
		"code":         code,
		"telegramId":   tgId,
		"telegramName": tgName,
	}
	jsonData, _ := json.Marshal(payload)

	resp, err := http.Post("http://"+af.config.GeneralAPIHost+"/general/auth/telegram/validate", "application/json", bytes.NewBuffer(jsonData))
	if err != nil {
		return nil, fmt.Errorf("failed to call mw-server: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != http.StatusOK {
		var errResp struct {
			Error   string `json:"error"`
			Message string `json:"message"`
		}
		json.NewDecoder(resp.Body).Decode(&errResp)
		return nil, fmt.Errorf("mw-server returned error: %s - %s", errResp.Error, errResp.Message)
	}

	var result TelegramValidateResult
	if err := json.NewDecoder(resp.Body).Decode(&result); err != nil {
		return nil, fmt.Errorf("failed to decode response: %w", err)
	}

	return &result, nil
}
