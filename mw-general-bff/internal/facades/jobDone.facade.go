package facades

import (
	"context"
	"fmt"
	webapprouter "go-common/webapprouter"
	openapiGeneral "mw-general-bff/apiAutogenerated/general"
	"mw-general-bff/internal/config"
	"mw-general-bff/internal/schemas"
	"mw-general-bff/internal/services"

	"github.com/samber/lo"
)

const (
	jobDoneMailSubject         = "New job done created."
	jobDoneMailMessage         = "https://mastersway.netlify.app/way/"
	jobDoneNotificationNature  = "mentoring_way"
	jobDoneNotificationChannel = "mail"
)

type JobDoneFacade struct {
	generalService      *services.GeneralService
	notificationService *services.NotificationService
	mailService         *services.MailService
	config              *config.Config
	router              *webapprouter.WebappRouter
}

func newJobDoneFacade(
	generalService *services.GeneralService,
	notificationService *services.NotificationService,
	mailService *services.MailService,
	config *config.Config,
) *JobDoneFacade {
	router := webapprouter.NewWebappRouter(config.WebappBaseURL)
	return &JobDoneFacade{generalService, notificationService, mailService, config, router}
}

func (jf *JobDoneFacade) CreateJobDone(ctx context.Context, payload *schemas.CreateJobDonePayload) (*openapiGeneral.MwServerInternalSchemasJobDonePopulatedResponse, error) {
	jobDoneResponse, err := jf.generalService.CreateJobDone(ctx, payload)
	if err != nil {
		return nil, err
	}

	WayPlain, err := jf.generalService.GetWayPlainForNotificationById(ctx, jobDoneResponse.WayUuid)
	if err != nil {
		return nil, err
	}

	var recipientMailSlice []string

	for _, c := range WayPlain.Mentors {
		settingList, err := jf.notificationService.GetNotificationSettingList(ctx, c.Uuid)
		if err != nil {
			return nil, err
		}

		for _, NotificationSetting := range settingList {
			if NotificationSetting.Nature == jobDoneNotificationNature &&
				NotificationSetting.Channel == jobDoneNotificationChannel &&
				NotificationSetting.IsEnabled {

				recipientMailSlice = append(recipientMailSlice, c.Email)
			}
		}
	}

	jobDoneUrlMessage := fmt.Sprintf(jobDoneMailMessage + jobDoneResponse.WayUuid)

	err = jf.mailService.SendMail(ctx, recipientMailSlice, jobDoneMailSubject, jobDoneUrlMessage)
	if err != nil {
		return nil, err
	}

	return jobDoneResponse, nil // Не знаю что по итогу возвращать
}

func (jf *JobDoneFacade) UpdateJobDone(ctx context.Context, params *services.UpdateJobDoneParams) (*openapiGeneral.MwServerInternalSchemasJobDonePopulatedResponse, error) {
	jobDone, err := jf.generalService.UpdateJobDone(ctx, params)
	if err != nil {
		return nil, err
	}

	way, err := jf.generalService.GetWayPlainForNotificationById(ctx, jobDone.WayUuid)
	if err != nil {
		return nil, err
	}

	participants := append(way.Mentors, way.Owner)
	notificationPotentialReceiversRaw := lo.FilterMap(
		participants,
		func(participant openapiGeneral.MwServerInternalSchemasUserPlainResponse, _ int) (string, bool) {
			isReceiver := jobDone.OwnerUuid != participant.Uuid
			return participant.Uuid, isReceiver
		},
	)

	notificationPotentialReceivers, err := jf.generalService.GetUserByIds(ctx, notificationPotentialReceiversRaw)
	if err != nil {
		return nil, err
	}

	notificationResponse, err := jf.notificationService.CreateNotifications(ctx, &services.CreateNotificationsParams{
		UserUUIDs:   notificationPotentialReceiversRaw,
		Description: "JobDone test notification",
		Url:         jf.router.GetWayPage(jobDone.WayUuid),
		Nature:      services.OwnWay,
	})
	if err != nil {
		return nil, err
	}

	// mailReceivers := make([]string, 0, len(notificationPotentialReceivers))

	// notificationSettingsForPotentialReceivers := lo.FlatMap(
	// 	notificationResponse.NotificationWithSettingsList,
	// 	func(notificationWithSettings *notification.NotificationWithSettings, _ int) []*notification.NotificationSettingResponse {
	// 		return notificationWithSettings.NotificationSettingList
	// 	},
	// )

	// lo.ForEach(
	// 	notificationSettingsForPotentialReceivers,
	// 	func(notificationSetting *notification.NotificationSettingResponse, _ int) {
	// 		switch notificationSetting.Channel {

	// 		case notification.Channel_mail:
	// 			user := userMap[notificationSetting.UserUuid]
	// 			mailReceivers = append(mailReceivers, user.Email)
	// 		}
	// 	},
	// )

	// err = jf.mailService.SendMail(ctx, mailReceivers, jobDoneMailSubject)
	// if err != nil {
	// 	return nil, err
	// }

	return jobDone, nil
}

func (jf *JobDoneFacade) DeleteJobDoneByID(ctx context.Context, jobDoneID string) error {
	return jf.generalService.DeleteJobDoneByID(ctx, jobDoneID)
}
