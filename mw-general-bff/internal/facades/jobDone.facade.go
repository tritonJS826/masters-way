package facades

import (
	"context"
	"fmt"
	webapprouter "go-common/webappRouter"

	openapiGeneral "mw-general-bff/apiAutogenerated/general"
	"mw-general-bff/internal/config"
	"mw-general-bff/internal/schemas"
	"mw-general-bff/internal/services"
	pb "mw-general-bff/pkg/grpcAutoGenerated/notification"

	"github.com/samber/lo"
)

type JobDoneFacade struct {
	generalService      *services.GeneralService
	notificationService *services.NotificationService
	mailService         *services.MailService
	config              *config.Config
	router              *webapprouter.WebappRouter
}

func newJobDoneFacade(
	generalService *services.GeneralService,
	notificationService *services.NotificationService,
	mailService *services.MailService,
	config *config.Config,
) *JobDoneFacade {
	router := webapprouter.NewWebappRouter(config.WebappBaseURL)
	return &JobDoneFacade{generalService, notificationService, mailService, config, router}
}

func (jf *JobDoneFacade) CreateJobDone(ctx context.Context, payload *schemas.CreateJobDonePayload) (*openapiGeneral.MwServerInternalSchemasJobDonePopulatedResponse, error) {
	return jf.generalService.CreateJobDone(ctx, payload)
}

func (jf *JobDoneFacade) UpdateJobDone(ctx context.Context, params *services.UpdateJobDoneParams) (*openapiGeneral.MwServerInternalSchemasJobDonePopulatedResponse, error) {
	jobDone, err := jf.generalService.UpdateJobDone(ctx, params)
	if err != nil {
		return nil, err
	}

	args := &NotifyWayUpdatedParams{
		generalService:      jf.generalService,
		notificationService: jf.notificationService,
		mailService:         jf.mailService,
		config:              jf.config,
		router:              jf.router,
		wayUuid:             jobDone.WayUuid,
		modifierUuid:        params.ModifierUserUuid,
	}
	NotifyWayUpdated(ctx, args)

	return jobDone, nil
}

func (jf *JobDoneFacade) DeleteJobDoneByID(ctx context.Context, jobDoneID string) error {
	return jf.generalService.DeleteJobDoneByID(ctx, jobDoneID)
}

type NotifyWayUpdatedParams struct {
	generalService      *services.GeneralService
	notificationService *services.NotificationService
	mailService         *services.MailService
	config              *config.Config
	router              *webapprouter.WebappRouter
	wayUuid             string
	modifierUuid        string
}

// notify in app and send mails
func NotifyWayUpdated(ctx context.Context, params *NotifyWayUpdatedParams) error {
	way, err := params.generalService.GetWayPlainForNotificationById(ctx, params.wayUuid)
	if err != nil {
		return err
	}

	participants := append(way.Mentors, way.Owner)
	notificationPotentialReceivers := lo.FilterMap(
		participants,
		func(participant openapiGeneral.MwServerInternalSchemasUserPlainResponse, _ int) (openapiGeneral.MwServerInternalSchemasUserPlainResponse, bool) {
			isReceiver := params.modifierUuid != participant.Uuid
			return participant, isReceiver
		},
	)

	mentorUUIDs := lo.Map(notificationPotentialReceivers, func(mentor openapiGeneral.MwServerInternalSchemasUserPlainResponse, _ int) string {
		return mentor.Uuid
	})

	notificationCreator, isExists := lo.Find(
		participants,
		func(participant openapiGeneral.MwServerInternalSchemasUserPlainResponse) bool {
			return participant.Uuid == params.modifierUuid
		},
	)
	if !isExists {
		return fmt.Errorf("JobDone creator doesn't found %v", params.modifierUuid)
	}

	receiversForOwnWayNotifications := make([]*pb.Receivers, 0, len(notificationPotentialReceivers))
	receiversForMentoringWayNotifications := make([]*pb.Receivers, 0, len(notificationPotentialReceivers))
	lo.ForEach(notificationPotentialReceivers, func(shortUser openapiGeneral.MwServerInternalSchemasUserPlainResponse, _ int) {
		// prepare notifications for way owner
		if shortUser.Uuid == way.Owner.Uuid {
			dataForOwnWayNotifications := &pb.Receivers_OwnWayData{
				OwnWayData: &pb.DataForOwnWayReceiver{
					NotificationCreatorImageUrl: notificationCreator.ImageUrl,
					WayId:                       way.Uuid,
					WayName:                     way.Name,
				},
			}
			receiversForOwnWayNotifications = append(receiversForOwnWayNotifications, &pb.Receivers{
				UserUuid:         shortUser.Uuid,
				Email:            shortUser.Email,
				DataForReceivers: dataForOwnWayNotifications,
			})
			return
		}

		// prepare notifications for way mentor
		if lo.Contains(mentorUUIDs, shortUser.Uuid) {
			dataForMentoringWayNotifications := &pb.Receivers_MentoringWayData{
				MentoringWayData: &pb.DataForMentoringWayReceiver{
					NotificationCreatorImageUrl: notificationCreator.ImageUrl,
					WayId:                       way.Uuid,
					WayName:                     way.Name,
				},
			}
			receiversForMentoringWayNotifications = append(receiversForMentoringWayNotifications, &pb.Receivers{
				UserUuid:         shortUser.Uuid,
				Email:            shortUser.Email,
				DataForReceivers: dataForMentoringWayNotifications,
			})
			return
		}

		fmt.Printf("Can't find user in the way, so notification won't send to user %v", shortUser)
	})

	// make notificationOwnWayResponse
	ownNotificationsResponse, err := params.notificationService.CreateNotifications(ctx, &pb.CreateNotificationRequest{
		Receivers: receiversForOwnWayNotifications,
		Nature:    pb.Nature(pb.Nature_value[string(services.OwnWay)]),
	})
	if err != nil {
		fmt.Println("ERROR: Failed to send own way notification")
	}

	// make notificationMentoringWayResponse
	mentoringNotificationsResponse, err := params.notificationService.CreateNotifications(ctx, &pb.CreateNotificationRequest{
		Receivers: receiversForMentoringWayNotifications,
		Nature:    pb.Nature(pb.Nature_value[string(services.MentoringWay)]),
	})
	if err != nil {
		fmt.Println("ERROR: Failed to send mentoring way notification")
	}

	// send email for owners
	lo.ForEach(ownNotificationsResponse.NotificationWithSettingsList, func(settings *pb.NotificationWithSettings, _ int) {
		lo.ForEach(settings.NotificationSettingList, func(setting *pb.NotificationSettingResponse, _ int) {
			if setting.Channel == pb.Channel_mail && setting.Nature == pb.Nature_own_way && setting.IsEnabled {

				userData, _ := lo.Find(
					notificationPotentialReceivers,
					func(participant openapiGeneral.MwServerInternalSchemasUserPlainResponse) bool {
						return participant.Uuid == setting.UserUuid
					},
				)

				link := params.router.GetWayPage(params.wayUuid)

				args := &services.SendMailParams{
					Subject: "Master's way: New message from your mentor!",
					To:      []string{userData.Email},
					Cc:      make([]string, 0),
					Bcc:     make([]string, 0),
					ReplyTo: make([]string, 0),
					Message: fmt.Sprintf("Hi! New message from your mentor for the way <strong>%s</strong> are <a href='%s'>here</a>", way.Name, link),
				}
				params.mailService.SendMail(ctx, args)
			}
		})
	})

	// send email for mentors
	lo.ForEach(mentoringNotificationsResponse.NotificationWithSettingsList, func(settings *pb.NotificationWithSettings, _ int) {
		lo.ForEach(settings.NotificationSettingList, func(setting *pb.NotificationSettingResponse, _ int) {
			if setting.Channel == pb.Channel_mail && setting.Nature == pb.Nature_mentoring_way && setting.IsEnabled {

				userData, _ := lo.Find(
					notificationPotentialReceivers,
					func(participant openapiGeneral.MwServerInternalSchemasUserPlainResponse) bool {
						return participant.Uuid == setting.UserUuid
					},
				)

				link := params.router.GetWayPage(params.wayUuid)

				args := &services.SendMailParams{
					Subject: "Master's way: new message from your student!",
					To:      []string{userData.Email},
					Cc:      make([]string, 0),
					Bcc:     make([]string, 0),
					ReplyTo: make([]string, 0),
					Message: fmt.Sprintf("Hi! New message from your mentor for the way <strong>%s</strong> are <a href='%s'>here</a>", way.Name, link),
				}
				params.mailService.SendMail(ctx, args)
			}
		})
	})

	return nil
}
