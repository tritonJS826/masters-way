package facades

import (
	"context"
	"fmt"
	webapprouter "go-common/webappRouter"

	openapiGeneral "mw-general-bff/apiAutogenerated/general"
	"mw-general-bff/internal/config"
	"mw-general-bff/internal/schemas"
	"mw-general-bff/internal/services"
	pb "mw-general-bff/pkg/grpcAutoGenerated/notification"

	"github.com/samber/lo"
)

const (
	jobDoneMailSubject         = "New job done created."
	jobDoneMailMessage         = "https://mastersway.netlify.app/way/"
	jobDoneNotificationNature  = "mentoring_way"
	jobDoneNotificationChannel = "mail"
)

type JobDoneFacade struct {
	generalService      *services.GeneralService
	notificationService *services.NotificationService
	config              *config.Config
	router              *webapprouter.WebappRouter
}

func newJobDoneFacade(
	generalService *services.GeneralService,
	notificationService *services.NotificationService,
	config *config.Config,
) *JobDoneFacade {
	router := webapprouter.NewWebappRouter(config.WebappBaseURL)
	return &JobDoneFacade{generalService, notificationService, config, router}
}

func (jf *JobDoneFacade) CreateJobDone(ctx context.Context, payload *schemas.CreateJobDonePayload) (*openapiGeneral.MwServerInternalSchemasJobDonePopulatedResponse, error) {
	return jf.generalService.CreateJobDone(ctx, payload)
}

func (jf *JobDoneFacade) UpdateJobDone(ctx context.Context, params *services.UpdateJobDoneParams) (*openapiGeneral.MwServerInternalSchemasJobDonePopulatedResponse, error) {
	jobDone, err := jf.generalService.UpdateJobDone(ctx, params)
	if err != nil {
		return nil, err
	}

	way, err := jf.generalService.GetWayPlainForNotificationById(ctx, jobDone.WayUuid)
	if err != nil {
		return nil, err
	}

	participants := append(way.Mentors, way.Owner)
	notificationPotentialReceivers := lo.FilterMap(
		participants,
		func(participant openapiGeneral.MwServerInternalSchemasUserPlainResponse, _ int) (openapiGeneral.MwServerInternalSchemasUserPlainResponse, bool) {
			isReceiver := jobDone.OwnerUuid != participant.Uuid
			return participant, isReceiver
		},
	)

	mentorUUIDs := lo.Map(notificationPotentialReceivers, func(mentor openapiGeneral.MwServerInternalSchemasUserPlainResponse, _ int) string {
		return mentor.Uuid
	})

	notificationCreator, isExists := lo.Find(
		participants,
		func(participant openapiGeneral.MwServerInternalSchemasUserPlainResponse) bool {
			return participant.Uuid == params.ModifierUserUuid
		},
	)
	if !isExists {
		return nil, fmt.Errorf("JobDone creator doesn't found %v", jobDone.OwnerUuid)
	}

	receiversForOwnWayNotifications := make([]*pb.Receivers, 0, len(notificationPotentialReceivers))
	receiversForMentoringWayNotifications := make([]*pb.Receivers, 0, len(notificationPotentialReceivers))
	lo.ForEach(notificationPotentialReceivers, func(shortUser openapiGeneral.MwServerInternalSchemasUserPlainResponse, _ int) {
		// prepare notifications for way owner
		if shortUser.Uuid == way.Owner.Uuid {
			dataForOwnWayNotifications := &pb.Receivers_OwnWayData{
				OwnWayData: &pb.DataForOwnWayReceiver{
					NotificationCreatorImageUrl: notificationCreator.ImageUrl,
					WayId:                       way.Uuid,
					WayName:                     way.Name,
				},
			}
			receiversForOwnWayNotifications = append(receiversForOwnWayNotifications, &pb.Receivers{
				UserUuid:         shortUser.Uuid,
				Email:            shortUser.Email,
				DataForReceivers: dataForOwnWayNotifications,
			})
			return
		}

		// prepare notifications for way mentor
		if lo.Contains(mentorUUIDs, shortUser.Uuid) {
			dataForMentoringWayNotifications := &pb.Receivers_MentoringWayData{
				MentoringWayData: &pb.DataForMentoringWayReceiver{
					NotificationCreatorImageUrl: notificationCreator.ImageUrl,
					WayId:                       way.Uuid,
					WayName:                     way.Name,
				},
			}
			receiversForMentoringWayNotifications = append(receiversForMentoringWayNotifications, &pb.Receivers{
				UserUuid:         shortUser.Uuid,
				Email:            shortUser.Email,
				DataForReceivers: dataForMentoringWayNotifications,
			})
			return
		}

		fmt.Printf("Can't find user in the way, so notification won't send to user %v", shortUser)
	})

	// make notificationOwnWayResponse
	_, err = jf.notificationService.CreateNotifications(ctx, &pb.CreateNotificationRequest{
		Receivers: receiversForOwnWayNotifications,
		Nature:    pb.Nature(pb.Nature_value[string(services.OwnWay)]),
	})
	if err != nil {
		fmt.Println("ERROR: Failed to send own way notification")
	}

	// make notificationMentoringWayResponse
	_, err = jf.notificationService.CreateNotifications(ctx, &pb.CreateNotificationRequest{
		Receivers: receiversForMentoringWayNotifications,
		Nature:    pb.Nature(pb.Nature_value[string(services.MentoringWay)]),
	})
	if err != nil {
		fmt.Println("ERROR: Failed to send mentoring way notification")
	}

	return jobDone, nil
}

func (jf *JobDoneFacade) DeleteJobDoneByID(ctx context.Context, jobDoneID string) error {
	return jf.generalService.DeleteJobDoneByID(ctx, jobDoneID)
}
