package facades

import (
	"context"
	openapiGeneral "mw-general-bff/apiAutogenerated/general"
	"mw-general-bff/internal/config"
	"mw-general-bff/internal/schemas"
	"mw-general-bff/internal/services"
)

type JobDoneFacade struct {
	generalService      *services.GeneralService
	notificationService *services.NotificationService
	config              *config.Config
}

func newJobDoneFacade(
	generalService *services.GeneralService,
	notificationService *services.NotificationService,
	config *config.Config,
) *JobDoneFacade {
	return &JobDoneFacade{generalService, notificationService, config}
}

func (jf *JobDoneFacade) CreateJobDone(ctx context.Context, payload *schemas.CreateJobDonePayload) (*openapiGeneral.MwServerInternalSchemasJobDonePopulatedResponse, error) {
	return jf.generalService.CreateJobDone(ctx, payload)
}

func (jf *JobDoneFacade) UpdateJobDone(ctx context.Context, params *services.UpdateJobDoneParams) (*openapiGeneral.MwServerInternalSchemasJobDonePopulatedResponse, error) {
	jobDone, err := jf.generalService.UpdateJobDone(ctx, params)
	if err != nil {
		return nil, err
	}

	way, err := jf.generalService.GetWayPlainForNotificationById(ctx, jobDone.WayUuid)
	if err != nil {
		return nil, err
	}

	participants := append(way.Mentors, way.Owner)
	for _, participant := range participants {
		if jobDone.OwnerUuid == participant.Uuid {
			continue
		}
		_, err = jf.notificationService.CreateNotifications(ctx, &services.CreateNotificationsParams{
			UserUUID:    participant.Uuid,
			Description: "JobDone test notification",
			Url:         jf.config.WebappBaseURL + "/way/" + jobDone.WayUuid,
			Nature:      services.OwnWay,
		})
		if err != nil {
			return nil, err
		}
	}

	return jobDone, nil
}

func (jf *JobDoneFacade) DeleteJobDoneByID(ctx context.Context, jobDoneID string) error {
	return jf.generalService.DeleteJobDoneByID(ctx, jobDoneID)
}
